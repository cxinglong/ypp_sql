{"version":3,"sources":["webpack:///static/js/30.4b1b4033534c8185208f.js","webpack:///./~/emmet/emmet.js"],"names":["webpackJsonp","212","module","exports","__webpack_require__","process","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","constructor","prototype","_","eq","a","b","stack","_chain","_wrapped","isEqual","isFunction","className","toString","call","String","source","global","multiline","ignoreCase","length","push","size","result","has","pop","root","this","previousUnderscore","breaker","ArrayProto","Array","ObjProto","FuncProto","Function","slice","unshift","hasOwnProperty","nativeForEach","forEach","nativeMap","map","nativeReduce","reduce","nativeReduceRight","reduceRight","nativeFilter","filter","nativeEvery","every","nativeSome","some","nativeIndexOf","indexOf","nativeLastIndexOf","lastIndexOf","nativeIsArray","isArray","nativeKeys","keys","nativeBind","bind","wrapper","VERSION","each","context","i","l","collect","results","index","list","foldl","inject","memo","initial","arguments","TypeError","foldr","reversed","toArray","reverse","find","detect","any","select","reject","all","identity","include","contains","target","found","invoke","method","args","apply","pluck","max","Math","isEmpty","Infinity","computed","min","shuffle","rand","shuffled","floor","random","sortBy","val","criteria","sort","left","right","groupBy","sortedIndex","array","low","high","mid","isArguments","values","first","head","take","n","guard","last","rest","tail","compact","flatten","shallow","concat","without","difference","uniq","unique","isSorted","union","intersection","intersect","item","other","zip","range","start","stop","step","len","ceil","idx","ctor","func","bound","self","bindAll","funcs","functions","f","memoize","hasher","delay","wait","setTimeout","defer","throttle","timeout","throttling","more","whenDone","debounce","later","immediate","clearTimeout","once","ran","wrap","compose","after","times","methods","names","extend","prop","pick","defaults","clone","isObject","tap","interceptor","isString","isElement","nodeType","isNumber","isFinite","isNaN","isBoolean","isDate","isRegExp","isNull","isUndefined","noConflict","escape","string","replace","object","property","mixin","name","addToWrapper","idCounter","uniqueId","prefix","id","templateSettings","evaluate","interpolate","noMatch","escapes","\\","'","r","t","u2028","u2029","p","escaper","unescaper","unescape","code","match","template","text","data","settings","variable","render","chain","wrapped","emmet","inherits","parent","protoProps","staticProps","child","__super__","modules","moduleLoader","e","define","factory","exec","require","fn","classProps","expandAbbreviation","abbr","syntax","profile","contextNode","filters","parser","get","resetTabstopIndex","extractFromAbbreviation","outputTree","parse","filtersList","composeList","defaultSyntax","defaultProfile","log","console","setModuleLoader","undefined","AbbreviationNode","children","_attributes","abbreviation","counter","_name","_text","repeatCount","hasImplicitRepeat","_data","end","content","padding","stripped","str","substring","consumeQuotedValue","stream","quote","ch","next","parseAbbreviation","trim","multiplier","addChild","create","loopProtector","eol","peek","pos","skipToPair","inner","current","_setRepeat","eatWhile","c","pairs","backUp","isMarker","isAllowedChar","setAbbreviation","extractAttributes","attrSet","attrs","eatSpace","reWord","attrName","attrValue","parseAttributes","attrMap","#",".","nameEnd","element","attributes","optimizeAttributes","attr","lookup","la","toLowerCase","extractText","unroll","node","j","maxCount","isRepeating","updateProperty","squash","isGroup","remove","charCode","charCodeAt","reValidName","[","(","{","spliceFn","splice","preprocessors","postprocessors","outputProcessors","position","ix","items","findAll","elemName","is","insertChildContent","res","matchedResource","attributeList","attribute","count","parseInt","that","abbrText","abbrAttrs","test","utils","innerContent","join","keepVariable","padString","hasEmptyChildren","hasImplicitName","isTextNode","deepestChild","replaceCounter","options","tree","attrLookup","addPreprocessor","removeFilter","preprocessor","addPostprocessor","removePostprocessor","addOutputProcessor","removeOutputProcessor","matchResources","resources","elements","getMatchedResource","subtree","repeatedChildren","locateOutputPlaceholder","outputPlaceholder","replaceOutputPlaceholders","ranges","replaceSubstring","hasOutputPlaceholder","insertPastedContent","overwrite","nodesWithPlaceholders","deepest","pastedContent","lines","splitByLines","pastedContentObj","resolveNodeNames","tagName","resolve","isset","v","getConf","char","walker","chnum","line","linenum","tokener","type","conf","w","tokens","charstart","charend","linestart","lineend","error","m","config","message","white","token","nextChar","comment","cnext","pk","q","brace","depth","identifier","pre","isNameChar","isDigit","num","nondigit","point","op","isOp","tokenize","getNewline","charAt","total_lines","init","me","split","nextLine","opsa","opsmatcha","ops","opsmatch","matchattr","lex","toSource","toks","src","inText","state","eat","inBlock","doctype","inTag","ok","inAttribute","style","terminator","pass","curState","cc","cont","pushContext","startOfLine","noIndent","Kludges","doNotIndent","prev","indent","indented","popContext","endtag","err","implicitlyClosed","setStyle","endclosetag","autoSelfClosers","maybePopContext","callee","nextTagName","parentTagName","contextGrabbers","attvalue","allowMissing","attvaluemaybe","allowUnquoted","startState","sol","comb","offset","score","fuzziness","start_of_string_bonus","abbreviation_score","final_score","character_score","index_in_string","index_c_lowercase","index_c_uppercase","min_index","total_character_score","abbreviation_length","string_length","fuzzies","toUpperCase","StringBuilder","append","caretPlaceholder","valueOf","reTag","endsWithTag","isNumeric","nl","getVariable","setNewline","setVariable","removeEmpty","normalizeNewline","repeatString","howMany","getStringsPads","strings","lengths","s","pad","padStr","zeroPadString","il","unindentString","search","substr","replaceUnescapedSymbol","symbol","sl","matchCount","curSl","newValue","replaceData","replaceVariables","vars","resolver","p1","processText","total","matchNum","base","decrement","matchesTag","escapeText","unescapeText","getCaretPlaceholder","setCaretPlaceholder","getLinePadding","getLinePaddingFromPosition","lineRange","findNewlineBounds","escapeForRegexp","specials","RegExp","prettifyNumber","fraction","toFixed","stringBuilder","narrowToNonSpace","reSpace","from","deepMerge","copy","copyIsArray","cmp","Range","abs","equal","shift","delta","overlap","inside","loc","create2","HandlerList","_list","add","order","listFn","skipValue","h","TokenIterator","_position","reset","hasNext","_i","_il","itemNext","itemPrev","nextUntil","callback","StringStream","skipToEnd","skipTo","open","close","braceCount","pattern","consume","caseInsensitive","cased","normalizeCaretPlaceholder","parseItem","normalizeName","cache","systemSettings","userSettings","resolvers","setVocabulary","getVocabulary","findSnippet","getSection","voc","variables","hasSyntax","addResolver","removeResolver","subsections","findItem","topSection","subsection","matchedItem","sectionName","fuzzyFindSnippet","minScore","payload","getAllSnippets","sc","scores","nk","parsedValue","cacheKey","sectionKey","section","stackItem","k","zc","humanizeActionName","actions","label","run","action","getAll","getList","getMenu","skipActions","hidden","actionName","ctx","parts","menuName","submenu","getActionNameForMenuTitle","title","menu","OutputProfile","stringCase","caseValue","createProfile","profiles","createDefaultProfiles","self_closing_tag","tag_nl","place_cursor","extraFilters","tag_case","attr_case","attr_quotes","tag_nl_leaf","inline_break","attributeName","attributeQuote","selfClosing","param","cursor","plain","isInsideTag","html","caretPos","outputInfo","editor","getProfileName","getSyntax","getContent","unindent","getCurrentLinePadding","getCurrentLine","mimeTypes","gif","png","jpg","jpeg","svg","htm","extractAbbreviation","curOffset","startIndex","groupCount","textCount","getImageSize","nextByte","width","height","marker","captureContext","allowedSyntaxes","xml","xsl","tag","getCaretPos","startTag","tagTree","findExpressionBounds","exprStart","exprEnd","compoundUpdate","sel","getSelectionRange","replaceContent","createSelection","caret","detectSyntax","hint","isStyle","isInlineCSS","detectProfile","isXHTML","innerRange","parseFromPosition","itemFromPosition","valueRange","_ref","isSnippet","isUnary","is_empty","isInline","isInlineLevel","isBlock","hasTagsInContent","childContent","appendIfNoChild","childVariableReplaced","output","chars","encode","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","cdp1","cdp2","cdp3","b64","decode","o1","o2","o3","h1","h2","h3","h4","bits","ac","tmpArr","fromCharCode","openTag","selfClose","closeTag","createMatcher","matches","reOpenTag","reCloseTag","findClosingPair","matcher","jl","outerRange","_c","outerContent","startPlaceholderNum","tabstopIndex","defaultOptions","replaceCarets","tabstop","maxNum","tabstops","tsOptions","group","placeholder","variablesResolver","extract","placeholders","carets","marks","ret","buf","lastIx","tabStops","mark","ph","upgrade","placeholderMemo","varName","varValue","toBoolean","isValueObj","preferences","_dbgDefaults","_dbgPreferences","description","prefs","set","getArray","getDict","load","json","exportModified","_startTest","_stopTest","registeredFilters","additionalFilters","commonFactory","factories","reAttrs","elem","elementName","core","EditContainer","_children","_positions","initialize","EditElement","nameToken","valueToken","_value","_updateSource","update","indexes","fullRange","nameRange","isAbsolute","_pos","namePosition","valuePosition","createToken","trimWhitespaceTokens","mask","WHITESPACE_REMOVE_FROM_START","WHITESPACE_REMOVE_FROM_END","whitespace","findSelectorRange","it","findValueRange","skipTokens","tok","findParts","sep","isValidIdentifier","styleBefore","styleSeparator","CSSEditContainer","editTree","selectorRange","contentStart","propertyRange","CSSEditElement","_saveStyle","styles","donor","rule","_end","valueParts","isBackward","bounds","extractRule","stopChars","bracePos","selector","baseName","styleQuote","XMLEditContainer","attrToken","XMLEditElement","extractTag","maxLen","handlers","info","getSelection","selRange","replaceRange","findAbbreviation","addHandler","removeHandler","curLine","getCurrentLineRange","editorUtils","prompt","newContent","parsedTree","toggleHTMLComment","genericCommentToggle","toggleCSSComment","cssItemFromPosition","absPos","relPos","reSafeChar","searchComment","startToken","endToken","commentStart","commentEnd","hasMatch","contentLen","commentRange","setCaretPos","findNewEditPoint","inc","curPoint","nextPoint","reEmptyLine","curChar","prevChar","curPos","newPoint","extractFn","rangeFn","itemRange","rng","contentLength","prevRange","searchPos","loop","findNextHTMLItem","isFirst","findOpeningTagFromPosition","getOpeningTagFromPosition","getRangeForHTMLItem","findPrevHTMLItem","makePossibleRangesHTML","attrValueRange","attrStart","isQuote","classNameRanges","curRange","matchedRanges","makePossibleRangesCSS","stringStream","cssEditTree","fnBody","part","matchedRangeForCSSProperty","possibleRanges","searchFn","nearestItemFn","findNextCSSItem","getRangeForNextItemInCSS","findPrevCSSItem","getRangeForPrevItemInCSS","matchPair","direction","lastMatch","narrowed","tagContentRange","startLineBounds","startLinePad","tagContent","joinTag","slash","splitTag","profileName","doCSSReflection","cssRule","oldRule","caretDelta","getReflectedCSSName","vendorPrefix","reflectValue","receiver","getReflectedValue","curName","curValue","refName","refValue","parseFloat","reName","actionUtils","expr","incrementNumber","hasSign","hasDecimal","strNum","minus","$1","intLength","hasCloseBrace","insValue","curPadding","nextPadding","selection","pair","textLen","startsWith","encodeToBase64","imgPath","file","editorFile","getFilePath","realImgPath","locateFile","read","getExt","decodeFromBase64","filePath","absPath","createPath","save","updateImageSizeHTML","xmlElem","getImageSizeForSource","compoundData","updateImageSizeCSS","fileContent","au","isSingleProperty","snippet","normalizeValue","normalizeHexColor","getKeyword","hex","repeat","color","aliases","getUnit","isValidKeyword","keyword","hasPrefix","vendorPrefixes","supports","findPrefixes","noAutofill","obsolete","addPrefix","prefixObj","getSyntaxPreference","formatProperty","transformSnippet","isImportant","getProperties","transformName","properties","descTemplate","descAddonTemplate","props","webkit","moz","ms","o","vendor","cssSyntaxes","expandToSnippet","ea","replaceFrom","replaceTo","supportsPrefix","prefixed","listPrefixes","getPrefix","removePrefix","extractPrefixes","prefixes","findValuesInAbbreviation","keywords","lastPart","parseValues","extractValues","abbrValues","unitlessProps","unit","expand","autoInsertPrefixes","prefixData","valuesData","abbrData","snippetObj","splitSnippet","propName","pads","normalizeSpace","parseLinearGradient","gradient","defaultLinearDirections","colorStops","reDeg","reKeyword","parseColorStop","colorStop","resolvePropertyName","fillImpliedPositions","cs","cs2","textualDirection","angle","oldWebkitDirection","getPrefixedNames","getPropertiesForGradient","propertyName","css","oldWebkitLinearGradient","pasteGradient","alignVendor","before","propsToInsert","valuePads","namePads","findGradient","cssProp","matchedPart","expandGradientOutsideValue","findGradientFromPosition","g","ruleStart","ruleEnd","insertPos","newCss","resolvedName","definition","generators","addGenerator","regexp","elementTypes","empty","blockLevel","inlineLevel","elementMap","ul","ol","table","tr","tbody","thead","tfoot","colgroup","optgroup","audio","video","getMapping","isTypeOf","isBlockLevel","isEmptyElement","addMapping","removeMapping","addElementToCollection","collection","col","getCollection","removeElementFromCollection","getSeparators","modifier","bemParse","__bem","block","classNames","normalizeClassName","reBlockName","processClassName","shortSymbol","re","transformClassName","separators","blockElem","elemModifiers","blockModifiers","entityType","reSep","cleanName","abbrUtils","shouldRunHtmlFilter","addComments","templateBefore","templateAfter","trigger","nodeBefore","nodeAfter","escapeChars","charMap","<",">","&","getIndentation","hasBlockSibling","hasBlockChildren","isVeryFirstChild","shouldAddLineBreak","shouldFormatInline","shouldBreakChild","nodeCount","isRoot","processSnippet","level","shouldBreakInsideInline","processTag","forceNl","makeAttributesString","otherAttrs","attrQuote","rePad","reNl","trimAttribute","tags","xsl:variable","xsl:with-param","randint","to","round","sample","arr","iterations","randIx","choice","sentence","words","insertCommas","totalCommas","paragraph","lang","wordCount","startWithCommon","langs","totalWords","common","en","ru","wordCound","addLang","snippets","locale","charset","indentation","newline","@i","@import","@m","@media","@f","@f+","@kf","anim","anim-","animdel","animdir","animdir:n","animdir:r","animdir:a","animdir:ar","animdur","animfm","animfm:f","animfm:b","animfm:bt","animfm:bh","animic","animic:i","animn","animps","animps:p","animps:r","animtf","animtf:e","animtf:ei","animtf:eo","animtf:eio","animtf:l","animtf:cb","ap","!","pos:s","pos:a","pos:r","pos:f","t:a","r:a","b:a","l:a","z","z:a","fl","fl:n","fl:l","fl:r","cl","cl:n","cl:l","cl:r","cl:b","colm","colmc","colmf","colmg","colmr","colmrc","colmrs","colmrw","colms","colmw","d","d:n","d:b","d:i","d:ib","d:ib+","d:li","d:ri","d:cp","d:tb","d:itb","d:tbcp","d:tbcl","d:tbclg","d:tbhg","d:tbfg","d:tbr","d:tbrg","d:tbc","d:rb","d:rbb","d:rbbg","d:rbt","d:rbtg","v:v","v:h","v:c","ov","ov:v","ov:h","ov:s","ov:a","ovx","ovx:v","ovx:h","ovx:s","ovx:a","ovy","ovy:v","ovy:h","ovy:s","ovy:a","ovs","ovs:a","ovs:s","ovs:p","ovs:m","ovs:mq","zoo","zm","cp","cp:a","cp:r","bxz","bxz:cb","bxz:bb","bxsh","bxsh:r","bxsh:ra","bxsh:n","m:a","mt","mt:a","mr","mr:a","mb","mb:a","ml","ml:a","pt","pr","pb","pl","w:a","h:a","maw","maw:n","mah","mah:n","miw","mih","mar","mir","ori","ori:l","ori:p","ol:n","olo","olw","olw:tn","olw:m","olw:tc","ols","ols:n","ols:dt","ols:ds","ols:s","ols:db","ols:g","ols:r","ols:i","ols:o","olc","olc:i","bd","bd+","bd:n","bdbk","bdbk:c","bdcl","bdcl:c","bdcl:s","bdc","bdc:t","bdi","bdi:n","bdti","bdti:n","bdri","bdri:n","bdbi","bdbi:n","bdli","bdli:n","bdci","bdci:n","bdci:c","bdtli","bdtli:n","bdtli:c","bdtri","bdtri:n","bdtri:c","bdbri","bdbri:n","bdbri:c","bdbli","bdbli:n","bdbli:c","bdf","bdf:c","bdf:r","bdf:sc","bdf:st","bdf:ow","bdf:of","bdf:sp","bdlen","bdlen:a","bdsp","bds","bds:n","bds:h","bds:dt","bds:ds","bds:s","bds:db","bds:dtds","bds:dtdtds","bds:w","bds:g","bds:r","bds:i","bds:o","bdw","bdtw","bdrw","bdbw","bdlw","bdt","bt","bdt+","bdt:n","bdts","bdts:n","bdtc","bdtc:t","bdr","br","bdr+","bdr:n","bdrst","bdrst:n","bdrc","bdrc:t","bdb","bb","bdb+","bdb:n","bdbs","bdbs:n","bdbc","bdbc:t","bdl","bl","bdl+","bdl:n","bdls","bdls:n","bdlc","bdlc:t","bdrs","bdtrrs","bdtlrs","bdbrrs","bdblrs","bg","bg+","bg:n","bg:ie","bgc","bgc:t","bgi","bgi:n","bgr","bgr:n","bgr:x","bgr:y","bgr:sp","bgr:rd","bga","bga:f","bga:s","bgp","bgpx","bgpy","bgbk","bgbk:bb","bgbk:eb","bgbk:c","bgcp","bgcp:bb","bgcp:pb","bgcp:cb","bgcp:nc","bgo","bgo:pb","bgo:bb","bgo:cb","bgsz","bgsz:a","bgsz:ct","bgsz:cv","c:r","c:ra","cm","cnt","cnt:n","cnt:oq","cnt:noq","cnt:cq","cnt:ncq","cnt:a","cnt:c","cnt:cs","tbl","tbl:a","tbl:f","cps","cps:t","cps:b","ec","ec:s","ec:h","lis","lis:n","lisp","lisp:i","lisp:o","list:n","list:d","list:c","list:s","list:dc","list:dclz","list:lr","list:ur","lisi","lisi:n","q:n","q:ru","q:en","ct","ct:n","ct:oq","ct:noq","ct:cq","ct:ncq","ct:a","ct:c","ct:cs","coi","cor","va","va:sup","va:t","va:tt","va:m","va:bl","va:b","va:tb","va:sub","ta","ta:l","ta:c","ta:r","ta:j","ta-lst","tal:a","tal:l","tal:c","tal:r","td","td:n","td:u","td:o","td:l","te","te:n","te:ac","te:dt","te:c","te:ds","te:b","te:a","th","th:a","th:f","th:t","th:m","ti","ti:-","tj","tj:a","tj:iw","tj:ii","tj:ic","tj:d","tj:k","tj:t","tov","tov:e","tov:c","to+","to:n","tr:n","tt","tt:n","tt:c","tt:u","tt:l","tw","tw:n","tw:no","tw:u","tw:s","tsh","tsh:r","tsh:ra","tsh+","tsh:n","trf","trf:skx","trf:sky","trf:sc","trf:scx","trf:scy","trf:r","trf:t","trf:tx","trf:ty","trfo","trfs","trs","trsde","trsdu","trsp","trstf","lh","whs","whs:n","whs:p","whs:nw","whs:pw","whs:pl","whsc","whsc:n","whsc:k","whsc:l","whsc:bs","whsc:ba","wob","wob:n","wob:k","wob:ba","wos","wow","wow:nm","wow:n","wow:u","wow:s","wow:b","wm","wm:lrt","wm:lrb","wm:rlt","wm:rlb","wm:tbr","wm:tbl","wm:btl","wm:btr","lts","lts-n","f+","fw","fw:n","fw:b","fw:br","fw:lr","fs","fs:n","fs:i","fs:o","fv","fv:n","fv:sc","fz","fza","fza:n","ff","ff:s","ff:ss","ff:c","ff:f","ff:m","ff:a","ff:t","ff:v","fef","fef:n","fef:eg","fef:eb","fef:o","fem","femp","femp:b","femp:a","fems","fems:n","fems:ac","fems:dt","fems:c","fems:ds","fsm","fsm:a","fsm:n","fsm:aw","fst","fst:n","fst:uc","fst:ec","fst:c","fst:sc","fst:se","fst:e","fst:ee","fst:ue","op+","op:ie","op:ms","rsz","rsz:n","rsz:b","rsz:h","rsz:v","cur","cur:a","cur:d","cur:c","cur:ha","cur:he","cur:m","cur:p","cur:t","pgbb","pgbb:au","pgbb:al","pgbb:l","pgbb:r","pgbi","pgbi:au","pgbi:av","pgba","pgba:au","pgba:al","pgba:l","pgba:r","orp","us","wid","wfsm","wfsm:a","wfsm:s","wfsm:sa","wfsm:n","!!!","!!!4t","!!!4s","!!!xt","!!!xs","!!!xxs","cc:ie6","cc:ie","cc:noie","abbreviations","a:link","a:mail","acronym","basefont","frame","hr","bdo","bdo:r","bdo:l","link","link:css","link:print","link:favicon","link:touch","link:rss","link:atom","meta","meta:utf","meta:win","meta:vp","meta:compat","script","script:src","img","iframe","embed","area","area:d","area:c","area:r","area:p","form","form:get","form:post","inp","input:hidden","input:h","input:text","input:t","input:search","input:email","input:url","input:password","input:p","input:datetime","input:date","input:datetime-local","input:month","input:week","input:time","input:number","input:color","input:checkbox","input:c","input:radio","input:r","input:range","input:file","input:f","input:submit","input:s","input:image","input:i","input:button","input:b","isindex","input:reset","select:disabled","select:d","option","textarea","marquee","menu:context","menu:c","menu:toolbar","menu:t","html:xml","keygen","command","button:submit","button:s","button:reset","button:r","button:disabled","button:d","fieldset:disabled","fieldset:d","bq","acr","fig","figc","ifr","emb","cap","colg","fst:d","btn","btn:b","btn:r","btn:s","btn:d","optg","opt","tarea","leg","sect","art","hdr","ftr","adr","dlg","prog","fset","fset:d","datag","datal","kg","out","det","cmd","doc","doc4","html:4t","html:4s","html:xt","html:xs","html:xxs","html:5","ol+","ul+","dl+","map+","table+","colgroup+","colg+","tr+","select+","optgroup+","optg+","extends","tm","tmatch","tn","tname","api","imp","xsl:when","wh","ot","if","par","pare","var","vare","wp","co","for","tex","com","msg","fall","nam","pres","strip","proc","choose+","haml","scss","sass","less","stylus","styl","userData"],"mappings":"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","file":"static/js/30.4b1b4033534c8185208f.js","sourcesContent":["webpackJsonp([30],{\n\n/***/ 212:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\nvar _ = function () {\n\n\t// Baseline setup\n\t// --------------\n\n\t// Establish the root object, `window` in the browser, or `global` on the server.\n\tvar root = this;\n\n\t// Save the previous value of the `_` variable.\n\tvar previousUnderscore = root._;\n\n\t// Establish the object that gets returned to break out of a loop iteration.\n\tvar breaker = {};\n\n\t// Save bytes in the minified (but not gzipped) version:\n\tvar ArrayProto = Array.prototype,\n\t    ObjProto = Object.prototype,\n\t    FuncProto = Function.prototype;\n\n\t// Create quick reference variables for speed access to core prototypes.\n\tvar slice = ArrayProto.slice,\n\t    unshift = ArrayProto.unshift,\n\t    toString = ObjProto.toString,\n\t    hasOwnProperty = ObjProto.hasOwnProperty;\n\n\t// All **ECMAScript 5** native function implementations that we hope to use\n\t// are declared here.\n\tvar nativeForEach = ArrayProto.forEach,\n\t    nativeMap = ArrayProto.map,\n\t    nativeReduce = ArrayProto.reduce,\n\t    nativeReduceRight = ArrayProto.reduceRight,\n\t    nativeFilter = ArrayProto.filter,\n\t    nativeEvery = ArrayProto.every,\n\t    nativeSome = ArrayProto.some,\n\t    nativeIndexOf = ArrayProto.indexOf,\n\t    nativeLastIndexOf = ArrayProto.lastIndexOf,\n\t    nativeIsArray = Array.isArray,\n\t    nativeKeys = Object.keys,\n\t    nativeBind = FuncProto.bind;\n\n\t// Create a safe reference to the Underscore object for use below.\n\tvar _ = function _(obj) {\n\t\treturn new wrapper(obj);\n\t};\n\n\t// Export the Underscore object for **Node.js**, with\n\t// backwards-compatibility for the old `require()` API. If we're in\n\t// the browser, add `_` as a global object via a string identifier,\n\t// for Closure Compiler \"advanced\" mode.\n\tif (true) {\n\t\tif (typeof module !== 'undefined' && module.exports) {\n\t\t\texports = module.exports = _;\n\t\t}\n\t\texports._ = _;\n\t} else {\n\t\troot['_'] = _;\n\t}\n\n\t// Current version.\n\t_.VERSION = '1.3.3';\n\n\t// Collection Functions\n\t// --------------------\n\n\t// The cornerstone, an `each` implementation, aka `forEach`.\n\t// Handles objects with the built-in `forEach`, arrays, and raw objects.\n\t// Delegates to **ECMAScript 5**'s native `forEach` if available.\n\tvar each = _.each = _.forEach = function (obj, iterator, context) {\n\t\tif (obj == null) return;\n\t\tif (nativeForEach && obj.forEach === nativeForEach) {\n\t\t\tobj.forEach(iterator, context);\n\t\t} else if (obj.length === +obj.length) {\n\t\t\tfor (var i = 0, l = obj.length; i < l; i++) {\n\t\t\t\tif (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var key in obj) {\n\t\t\t\tif (_.has(obj, key)) {\n\t\t\t\t\tif (iterator.call(context, obj[key], key, obj) === breaker) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Return the results of applying the iterator to each element.\n\t// Delegates to **ECMAScript 5**'s native `map` if available.\n\t_.map = _.collect = function (obj, iterator, context) {\n\t\tvar results = [];\n\t\tif (obj == null) return results;\n\t\tif (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n\t\teach(obj, function (value, index, list) {\n\t\t\tresults[results.length] = iterator.call(context, value, index, list);\n\t\t});\n\t\tif (obj.length === +obj.length) results.length = obj.length;\n\t\treturn results;\n\t};\n\n\t// **Reduce** builds up a single result from a list of values, aka `inject`,\n\t// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n\t_.reduce = _.foldl = _.inject = function (obj, iterator, memo, context) {\n\t\tvar initial = arguments.length > 2;\n\t\tif (obj == null) obj = [];\n\t\tif (nativeReduce && obj.reduce === nativeReduce) {\n\t\t\tif (context) iterator = _.bind(iterator, context);\n\t\t\treturn initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n\t\t}\n\t\teach(obj, function (value, index, list) {\n\t\t\tif (!initial) {\n\t\t\t\tmemo = value;\n\t\t\t\tinitial = true;\n\t\t\t} else {\n\t\t\t\tmemo = iterator.call(context, memo, value, index, list);\n\t\t\t}\n\t\t});\n\t\tif (!initial) throw new TypeError('Reduce of empty array with no initial value');\n\t\treturn memo;\n\t};\n\n\t// The right-associative version of reduce, also known as `foldr`.\n\t// Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n\t_.reduceRight = _.foldr = function (obj, iterator, memo, context) {\n\t\tvar initial = arguments.length > 2;\n\t\tif (obj == null) obj = [];\n\t\tif (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n\t\t\tif (context) iterator = _.bind(iterator, context);\n\t\t\treturn initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n\t\t}\n\t\tvar reversed = _.toArray(obj).reverse();\n\t\tif (context && !initial) iterator = _.bind(iterator, context);\n\t\treturn initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n\t};\n\n\t// Return the first value which passes a truth test. Aliased as `detect`.\n\t_.find = _.detect = function (obj, iterator, context) {\n\t\tvar result;\n\t\tany(obj, function (value, index, list) {\n\t\t\tif (iterator.call(context, value, index, list)) {\n\t\t\t\tresult = value;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn result;\n\t};\n\n\t// Return all the elements that pass a truth test.\n\t// Delegates to **ECMAScript 5**'s native `filter` if available.\n\t// Aliased as `select`.\n\t_.filter = _.select = function (obj, iterator, context) {\n\t\tvar results = [];\n\t\tif (obj == null) return results;\n\t\tif (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n\t\teach(obj, function (value, index, list) {\n\t\t\tif (iterator.call(context, value, index, list)) results[results.length] = value;\n\t\t});\n\t\treturn results;\n\t};\n\n\t// Return all the elements for which a truth test fails.\n\t_.reject = function (obj, iterator, context) {\n\t\tvar results = [];\n\t\tif (obj == null) return results;\n\t\teach(obj, function (value, index, list) {\n\t\t\tif (!iterator.call(context, value, index, list)) results[results.length] = value;\n\t\t});\n\t\treturn results;\n\t};\n\n\t// Determine whether all of the elements match a truth test.\n\t// Delegates to **ECMAScript 5**'s native `every` if available.\n\t// Aliased as `all`.\n\t_.every = _.all = function (obj, iterator, context) {\n\t\tvar result = true;\n\t\tif (obj == null) return result;\n\t\tif (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n\t\teach(obj, function (value, index, list) {\n\t\t\tif (!(result = result && iterator.call(context, value, index, list))) return breaker;\n\t\t});\n\t\treturn !!result;\n\t};\n\n\t// Determine if at least one element in the object matches a truth test.\n\t// Delegates to **ECMAScript 5**'s native `some` if available.\n\t// Aliased as `any`.\n\tvar any = _.some = _.any = function (obj, iterator, context) {\n\t\titerator || (iterator = _.identity);\n\t\tvar result = false;\n\t\tif (obj == null) return result;\n\t\tif (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n\t\teach(obj, function (value, index, list) {\n\t\t\tif (result || (result = iterator.call(context, value, index, list))) return breaker;\n\t\t});\n\t\treturn !!result;\n\t};\n\n\t// Determine if a given value is included in the array or object using `===`.\n\t// Aliased as `contains`.\n\t_.include = _.contains = function (obj, target) {\n\t\tvar found = false;\n\t\tif (obj == null) return found;\n\t\tif (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n\t\tfound = any(obj, function (value) {\n\t\t\treturn value === target;\n\t\t});\n\t\treturn found;\n\t};\n\n\t// Invoke a method (with arguments) on every item in a collection.\n\t_.invoke = function (obj, method) {\n\t\tvar args = slice.call(arguments, 2);\n\t\treturn _.map(obj, function (value) {\n\t\t\treturn (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n\t\t});\n\t};\n\n\t// Convenience version of a common use case of `map`: fetching a property.\n\t_.pluck = function (obj, key) {\n\t\treturn _.map(obj, function (value) {\n\t\t\treturn value[key];\n\t\t});\n\t};\n\n\t// Return the maximum element or (element-based computation).\n\t_.max = function (obj, iterator, context) {\n\t\tif (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n\t\tif (!iterator && _.isEmpty(obj)) return -Infinity;\n\t\tvar result = { computed: -Infinity };\n\t\teach(obj, function (value, index, list) {\n\t\t\tvar computed = iterator ? iterator.call(context, value, index, list) : value;\n\t\t\tcomputed >= result.computed && (result = { value: value, computed: computed });\n\t\t});\n\t\treturn result.value;\n\t};\n\n\t// Return the minimum element (or element-based computation).\n\t_.min = function (obj, iterator, context) {\n\t\tif (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n\t\tif (!iterator && _.isEmpty(obj)) return Infinity;\n\t\tvar result = { computed: Infinity };\n\t\teach(obj, function (value, index, list) {\n\t\t\tvar computed = iterator ? iterator.call(context, value, index, list) : value;\n\t\t\tcomputed < result.computed && (result = { value: value, computed: computed });\n\t\t});\n\t\treturn result.value;\n\t};\n\n\t// Shuffle an array.\n\t_.shuffle = function (obj) {\n\t\tvar shuffled = [],\n\t\t    rand;\n\t\teach(obj, function (value, index, list) {\n\t\t\trand = Math.floor(Math.random() * (index + 1));\n\t\t\tshuffled[index] = shuffled[rand];\n\t\t\tshuffled[rand] = value;\n\t\t});\n\t\treturn shuffled;\n\t};\n\n\t// Sort the object's values by a criterion produced by an iterator.\n\t_.sortBy = function (obj, val, context) {\n\t\tvar iterator = _.isFunction(val) ? val : function (obj) {\n\t\t\treturn obj[val];\n\t\t};\n\t\treturn _.pluck(_.map(obj, function (value, index, list) {\n\t\t\treturn {\n\t\t\t\tvalue: value,\n\t\t\t\tcriteria: iterator.call(context, value, index, list)\n\t\t\t};\n\t\t}).sort(function (left, right) {\n\t\t\tvar a = left.criteria,\n\t\t\t    b = right.criteria;\n\t\t\tif (a === void 0) return 1;\n\t\t\tif (b === void 0) return -1;\n\t\t\treturn a < b ? -1 : a > b ? 1 : 0;\n\t\t}), 'value');\n\t};\n\n\t// Groups the object's values by a criterion. Pass either a string attribute\n\t// to group by, or a function that returns the criterion.\n\t_.groupBy = function (obj, val) {\n\t\tvar result = {};\n\t\tvar iterator = _.isFunction(val) ? val : function (obj) {\n\t\t\treturn obj[val];\n\t\t};\n\t\teach(obj, function (value, index) {\n\t\t\tvar key = iterator(value, index);\n\t\t\t(result[key] || (result[key] = [])).push(value);\n\t\t});\n\t\treturn result;\n\t};\n\n\t// Use a comparator function to figure out at what index an object should\n\t// be inserted so as to maintain order. Uses binary search.\n\t_.sortedIndex = function (array, obj, iterator) {\n\t\titerator || (iterator = _.identity);\n\t\tvar low = 0,\n\t\t    high = array.length;\n\t\twhile (low < high) {\n\t\t\tvar mid = low + high >> 1;\n\t\t\titerator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n\t\t}\n\t\treturn low;\n\t};\n\n\t// Safely convert anything iterable into a real, live array.\n\t_.toArray = function (obj) {\n\t\tif (!obj) return [];\n\t\tif (_.isArray(obj)) return slice.call(obj);\n\t\tif (_.isArguments(obj)) return slice.call(obj);\n\t\tif (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n\t\treturn _.values(obj);\n\t};\n\n\t// Return the number of elements in an object.\n\t_.size = function (obj) {\n\t\treturn _.isArray(obj) ? obj.length : _.keys(obj).length;\n\t};\n\n\t// Array Functions\n\t// ---------------\n\n\t// Get the first element of an array. Passing **n** will return the first N\n\t// values in the array. Aliased as `head` and `take`. The **guard** check\n\t// allows it to work with `_.map`.\n\t_.first = _.head = _.take = function (array, n, guard) {\n\t\treturn n != null && !guard ? slice.call(array, 0, n) : array[0];\n\t};\n\n\t// Returns everything but the last entry of the array. Especcialy useful on\n\t// the arguments object. Passing **n** will return all the values in\n\t// the array, excluding the last N. The **guard** check allows it to work with\n\t// `_.map`.\n\t_.initial = function (array, n, guard) {\n\t\treturn slice.call(array, 0, array.length - (n == null || guard ? 1 : n));\n\t};\n\n\t// Get the last element of an array. Passing **n** will return the last N\n\t// values in the array. The **guard** check allows it to work with `_.map`.\n\t_.last = function (array, n, guard) {\n\t\tif (n != null && !guard) {\n\t\t\treturn slice.call(array, Math.max(array.length - n, 0));\n\t\t} else {\n\t\t\treturn array[array.length - 1];\n\t\t}\n\t};\n\n\t// Returns everything but the first entry of the array. Aliased as `tail`.\n\t// Especially useful on the arguments object. Passing an **index** will return\n\t// the rest of the values in the array from that index onward. The **guard**\n\t// check allows it to work with `_.map`.\n\t_.rest = _.tail = function (array, index, guard) {\n\t\treturn slice.call(array, index == null || guard ? 1 : index);\n\t};\n\n\t// Trim out all falsy values from an array.\n\t_.compact = function (array) {\n\t\treturn _.filter(array, function (value) {\n\t\t\treturn !!value;\n\t\t});\n\t};\n\n\t// Return a completely flattened version of an array.\n\t_.flatten = function (array, shallow) {\n\t\treturn _.reduce(array, function (memo, value) {\n\t\t\tif (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n\t\t\tmemo[memo.length] = value;\n\t\t\treturn memo;\n\t\t}, []);\n\t};\n\n\t// Return a version of the array that does not contain the specified value(s).\n\t_.without = function (array) {\n\t\treturn _.difference(array, slice.call(arguments, 1));\n\t};\n\n\t// Produce a duplicate-free version of the array. If the array has already\n\t// been sorted, you have the option of using a faster algorithm.\n\t// Aliased as `unique`.\n\t_.uniq = _.unique = function (array, isSorted, iterator) {\n\t\tvar initial = iterator ? _.map(array, iterator) : array;\n\t\tvar results = [];\n\t\t// The `isSorted` flag is irrelevant if the array only contains two elements.\n\t\tif (array.length < 3) isSorted = true;\n\t\t_.reduce(initial, function (memo, value, index) {\n\t\t\tif (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n\t\t\t\tmemo.push(value);\n\t\t\t\tresults.push(array[index]);\n\t\t\t}\n\t\t\treturn memo;\n\t\t}, []);\n\t\treturn results;\n\t};\n\n\t// Produce an array that contains the union: each distinct element from all of\n\t// the passed-in arrays.\n\t_.union = function () {\n\t\treturn _.uniq(_.flatten(arguments, true));\n\t};\n\n\t// Produce an array that contains every item shared between all the\n\t// passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n\t_.intersection = _.intersect = function (array) {\n\t\tvar rest = slice.call(arguments, 1);\n\t\treturn _.filter(_.uniq(array), function (item) {\n\t\t\treturn _.every(rest, function (other) {\n\t\t\t\treturn _.indexOf(other, item) >= 0;\n\t\t\t});\n\t\t});\n\t};\n\n\t// Take the difference between one array and a number of other arrays.\n\t// Only the elements present in just the first array will remain.\n\t_.difference = function (array) {\n\t\tvar rest = _.flatten(slice.call(arguments, 1), true);\n\t\treturn _.filter(array, function (value) {\n\t\t\treturn !_.include(rest, value);\n\t\t});\n\t};\n\n\t// Zip together multiple lists into a single array -- elements that share\n\t// an index go together.\n\t_.zip = function () {\n\t\tvar args = slice.call(arguments);\n\t\tvar length = _.max(_.pluck(args, 'length'));\n\t\tvar results = new Array(length);\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tresults[i] = _.pluck(args, \"\" + i);\n\t\t}return results;\n\t};\n\n\t// If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n\t// we need this function. Return the position of the first occurrence of an\n\t// item in an array, or -1 if the item is not included in the array.\n\t// Delegates to **ECMAScript 5**'s native `indexOf` if available.\n\t// If the array is large and already in sort order, pass `true`\n\t// for **isSorted** to use binary search.\n\t_.indexOf = function (array, item, isSorted) {\n\t\tif (array == null) return -1;\n\t\tvar i, l;\n\t\tif (isSorted) {\n\t\t\ti = _.sortedIndex(array, item);\n\t\t\treturn array[i] === item ? i : -1;\n\t\t}\n\t\tif (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n\t\tfor (i = 0, l = array.length; i < l; i++) {\n\t\t\tif (i in array && array[i] === item) return i;\n\t\t}return -1;\n\t};\n\n\t// Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n\t_.lastIndexOf = function (array, item) {\n\t\tif (array == null) return -1;\n\t\tif (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n\t\tvar i = array.length;\n\t\twhile (i--) {\n\t\t\tif (i in array && array[i] === item) return i;\n\t\t}return -1;\n\t};\n\n\t// Generate an integer Array containing an arithmetic progression. A port of\n\t// the native Python `range()` function. See\n\t// [the Python documentation](http://docs.python.org/library/functions.html#range).\n\t_.range = function (start, stop, step) {\n\t\tif (arguments.length <= 1) {\n\t\t\tstop = start || 0;\n\t\t\tstart = 0;\n\t\t}\n\t\tstep = arguments[2] || 1;\n\n\t\tvar len = Math.max(Math.ceil((stop - start) / step), 0);\n\t\tvar idx = 0;\n\t\tvar range = new Array(len);\n\n\t\twhile (idx < len) {\n\t\t\trange[idx++] = start;\n\t\t\tstart += step;\n\t\t}\n\n\t\treturn range;\n\t};\n\n\t// Function (ahem) Functions\n\t// ------------------\n\n\t// Reusable constructor function for prototype setting.\n\tvar ctor = function ctor() {};\n\n\t// Create a function bound to a given object (assigning `this`, and arguments,\n\t// optionally). Binding with arguments is also known as `curry`.\n\t// Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n\t// We check for `func.bind` first, to fail fast when `func` is undefined.\n\t_.bind = function bind(func, context) {\n\t\tvar _bound, args;\n\t\tif (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n\t\tif (!_.isFunction(func)) throw new TypeError();\n\t\targs = slice.call(arguments, 2);\n\t\treturn _bound = function bound() {\n\t\t\tif (!(this instanceof _bound)) return func.apply(context, args.concat(slice.call(arguments)));\n\t\t\tctor.prototype = func.prototype;\n\t\t\tvar self = new ctor();\n\t\t\tvar result = func.apply(self, args.concat(slice.call(arguments)));\n\t\t\tif (Object(result) === result) return result;\n\t\t\treturn self;\n\t\t};\n\t};\n\n\t// Bind all of an object's methods to that object. Useful for ensuring that\n\t// all callbacks defined on an object belong to it.\n\t_.bindAll = function (obj) {\n\t\tvar funcs = slice.call(arguments, 1);\n\t\tif (funcs.length == 0) funcs = _.functions(obj);\n\t\teach(funcs, function (f) {\n\t\t\tobj[f] = _.bind(obj[f], obj);\n\t\t});\n\t\treturn obj;\n\t};\n\n\t// Memoize an expensive function by storing its results.\n\t_.memoize = function (func, hasher) {\n\t\tvar memo = {};\n\t\thasher || (hasher = _.identity);\n\t\treturn function () {\n\t\t\tvar key = hasher.apply(this, arguments);\n\t\t\treturn _.has(memo, key) ? memo[key] : memo[key] = func.apply(this, arguments);\n\t\t};\n\t};\n\n\t// Delays a function for the given number of milliseconds, and then calls\n\t// it with the arguments supplied.\n\t_.delay = function (func, wait) {\n\t\tvar args = slice.call(arguments, 2);\n\t\treturn setTimeout(function () {\n\t\t\treturn func.apply(null, args);\n\t\t}, wait);\n\t};\n\n\t// Defers a function, scheduling it to run after the current call stack has\n\t// cleared.\n\t_.defer = function (func) {\n\t\treturn _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n\t};\n\n\t// Returns a function, that, when invoked, will only be triggered at most once\n\t// during a given window of time.\n\t_.throttle = function (func, wait) {\n\t\tvar context, args, timeout, throttling, more, result;\n\t\tvar whenDone = _.debounce(function () {\n\t\t\tmore = throttling = false;\n\t\t}, wait);\n\t\treturn function () {\n\t\t\tcontext = this;args = arguments;\n\t\t\tvar later = function later() {\n\t\t\t\ttimeout = null;\n\t\t\t\tif (more) func.apply(context, args);\n\t\t\t\twhenDone();\n\t\t\t};\n\t\t\tif (!timeout) timeout = setTimeout(later, wait);\n\t\t\tif (throttling) {\n\t\t\t\tmore = true;\n\t\t\t} else {\n\t\t\t\tresult = func.apply(context, args);\n\t\t\t}\n\t\t\twhenDone();\n\t\t\tthrottling = true;\n\t\t\treturn result;\n\t\t};\n\t};\n\n\t// Returns a function, that, as long as it continues to be invoked, will not\n\t// be triggered. The function will be called after it stops being called for\n\t// N milliseconds. If `immediate` is passed, trigger the function on the\n\t// leading edge, instead of the trailing.\n\t_.debounce = function (func, wait, immediate) {\n\t\tvar timeout;\n\t\treturn function () {\n\t\t\tvar context = this,\n\t\t\t    args = arguments;\n\t\t\tvar later = function later() {\n\t\t\t\ttimeout = null;\n\t\t\t\tif (!immediate) func.apply(context, args);\n\t\t\t};\n\t\t\tif (immediate && !timeout) func.apply(context, args);\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(later, wait);\n\t\t};\n\t};\n\n\t// Returns a function that will be executed at most one time, no matter how\n\t// often you call it. Useful for lazy initialization.\n\t_.once = function (func) {\n\t\tvar ran = false,\n\t\t    memo;\n\t\treturn function () {\n\t\t\tif (ran) return memo;\n\t\t\tran = true;\n\t\t\treturn memo = func.apply(this, arguments);\n\t\t};\n\t};\n\n\t// Returns the first function passed as an argument to the second,\n\t// allowing you to adjust arguments, run code before and after, and\n\t// conditionally execute the original function.\n\t_.wrap = function (func, wrapper) {\n\t\treturn function () {\n\t\t\tvar args = [func].concat(slice.call(arguments, 0));\n\t\t\treturn wrapper.apply(this, args);\n\t\t};\n\t};\n\n\t// Returns a function that is the composition of a list of functions, each\n\t// consuming the return value of the function that follows.\n\t_.compose = function () {\n\t\tvar funcs = arguments;\n\t\treturn function () {\n\t\t\tvar args = arguments;\n\t\t\tfor (var i = funcs.length - 1; i >= 0; i--) {\n\t\t\t\targs = [funcs[i].apply(this, args)];\n\t\t\t}\n\t\t\treturn args[0];\n\t\t};\n\t};\n\n\t// Returns a function that will only be executed after being called N times.\n\t_.after = function (times, func) {\n\t\tif (times <= 0) return func();\n\t\treturn function () {\n\t\t\tif (--times < 1) {\n\t\t\t\treturn func.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t};\n\n\t// Object Functions\n\t// ----------------\n\n\t// Retrieve the names of an object's properties.\n\t// Delegates to **ECMAScript 5**'s native `Object.keys`\n\t_.keys = nativeKeys || function (obj) {\n\t\tif (obj !== Object(obj)) throw new TypeError('Invalid object');\n\t\tvar keys = [];\n\t\tfor (var key in obj) {\n\t\t\tif (_.has(obj, key)) keys[keys.length] = key;\n\t\t}return keys;\n\t};\n\n\t// Retrieve the values of an object's properties.\n\t_.values = function (obj) {\n\t\treturn _.map(obj, _.identity);\n\t};\n\n\t// Return a sorted list of the function names available on the object.\n\t// Aliased as `methods`\n\t_.functions = _.methods = function (obj) {\n\t\tvar names = [];\n\t\tfor (var key in obj) {\n\t\t\tif (_.isFunction(obj[key])) names.push(key);\n\t\t}\n\t\treturn names.sort();\n\t};\n\n\t// Extend a given object with all the properties in passed-in object(s).\n\t_.extend = function (obj) {\n\t\teach(slice.call(arguments, 1), function (source) {\n\t\t\tfor (var prop in source) {\n\t\t\t\tobj[prop] = source[prop];\n\t\t\t}\n\t\t});\n\t\treturn obj;\n\t};\n\n\t// Return a copy of the object only containing the whitelisted properties.\n\t_.pick = function (obj) {\n\t\tvar result = {};\n\t\teach(_.flatten(slice.call(arguments, 1)), function (key) {\n\t\t\tif (key in obj) result[key] = obj[key];\n\t\t});\n\t\treturn result;\n\t};\n\n\t// Fill in a given object with default properties.\n\t_.defaults = function (obj) {\n\t\teach(slice.call(arguments, 1), function (source) {\n\t\t\tfor (var prop in source) {\n\t\t\t\tif (obj[prop] == null) obj[prop] = source[prop];\n\t\t\t}\n\t\t});\n\t\treturn obj;\n\t};\n\n\t// Create a (shallow-cloned) duplicate of an object.\n\t_.clone = function (obj) {\n\t\tif (!_.isObject(obj)) return obj;\n\t\treturn _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n\t};\n\n\t// Invokes interceptor with the obj, and then returns obj.\n\t// The primary purpose of this method is to \"tap into\" a method chain, in\n\t// order to perform operations on intermediate results within the chain.\n\t_.tap = function (obj, interceptor) {\n\t\tinterceptor(obj);\n\t\treturn obj;\n\t};\n\n\t// Internal recursive comparison function.\n\tfunction eq(a, b, stack) {\n\t\t// Identical objects are equal. `0 === -0`, but they aren't identical.\n\t\t// See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n\t\tif (a === b) return a !== 0 || 1 / a == 1 / b;\n\t\t// A strict comparison is necessary because `null == undefined`.\n\t\tif (a == null || b == null) return a === b;\n\t\t// Unwrap any wrapped objects.\n\t\tif (a._chain) a = a._wrapped;\n\t\tif (b._chain) b = b._wrapped;\n\t\t// Invoke a custom `isEqual` method if one is provided.\n\t\tif (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n\t\tif (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n\t\t// Compare `[[Class]]` names.\n\t\tvar className = toString.call(a);\n\t\tif (className != toString.call(b)) return false;\n\t\tswitch (className) {\n\t\t\t// Strings, numbers, dates, and booleans are compared by value.\n\t\t\tcase '[object String]':\n\t\t\t\t// Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n\t\t\t\t// equivalent to `new String(\"5\")`.\n\t\t\t\treturn a == String(b);\n\t\t\tcase '[object Number]':\n\t\t\t\t// `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n\t\t\t\t// other numeric values.\n\t\t\t\treturn a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;\n\t\t\tcase '[object Date]':\n\t\t\tcase '[object Boolean]':\n\t\t\t\t// Coerce dates and booleans to numeric primitive values. Dates are compared by their\n\t\t\t\t// millisecond representations. Note that invalid dates with millisecond representations\n\t\t\t\t// of `NaN` are not equivalent.\n\t\t\t\treturn +a == +b;\n\t\t\t// RegExps are compared by their source patterns and flags.\n\t\t\tcase '[object RegExp]':\n\t\t\t\treturn a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;\n\t\t}\n\t\tif ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) != 'object' || (typeof b === 'undefined' ? 'undefined' : _typeof(b)) != 'object') return false;\n\t\t// Assume equality for cyclic structures. The algorithm for detecting cyclic\n\t\t// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\t\tvar length = stack.length;\n\t\twhile (length--) {\n\t\t\t// Linear search. Performance is inversely proportional to the number of\n\t\t\t// unique nested structures.\n\t\t\tif (stack[length] == a) return true;\n\t\t}\n\t\t// Add the first object to the stack of traversed objects.\n\t\tstack.push(a);\n\t\tvar size = 0,\n\t\t    result = true;\n\t\t// Recursively compare objects and arrays.\n\t\tif (className == '[object Array]') {\n\t\t\t// Compare array lengths to determine if a deep comparison is necessary.\n\t\t\tsize = a.length;\n\t\t\tresult = size == b.length;\n\t\t\tif (result) {\n\t\t\t\t// Deep compare the contents, ignoring non-numeric properties.\n\t\t\t\twhile (size--) {\n\t\t\t\t\t// Ensure commutative equality for sparse arrays.\n\t\t\t\t\tif (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Objects with different constructors are not equivalent.\n\t\t\tif ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n\t\t\t// Deep compare objects.\n\t\t\tfor (var key in a) {\n\t\t\t\tif (_.has(a, key)) {\n\t\t\t\t\t// Count the expected number of properties.\n\t\t\t\t\tsize++;\n\t\t\t\t\t// Deep compare each member.\n\t\t\t\t\tif (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Ensure that both objects contain the same number of properties.\n\t\t\tif (result) {\n\t\t\t\tfor (key in b) {\n\t\t\t\t\tif (_.has(b, key) && !size--) break;\n\t\t\t\t}\n\t\t\t\tresult = !size;\n\t\t\t}\n\t\t}\n\t\t// Remove the first object from the stack of traversed objects.\n\t\tstack.pop();\n\t\treturn result;\n\t}\n\n\t// Perform a deep comparison to check if two objects are equal.\n\t_.isEqual = function (a, b) {\n\t\treturn eq(a, b, []);\n\t};\n\n\t// Is a given array, string, or object empty?\n\t// An \"empty\" object has no enumerable own-properties.\n\t_.isEmpty = function (obj) {\n\t\tif (obj == null) return true;\n\t\tif (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n\t\tfor (var key in obj) {\n\t\t\tif (_.has(obj, key)) return false;\n\t\t}return true;\n\t};\n\n\t// Is a given value a DOM element?\n\t_.isElement = function (obj) {\n\t\treturn !!(obj && obj.nodeType == 1);\n\t};\n\n\t// Is a given value an array?\n\t// Delegates to ECMA5's native Array.isArray\n\t_.isArray = nativeIsArray || function (obj) {\n\t\treturn toString.call(obj) == '[object Array]';\n\t};\n\n\t// Is a given variable an object?\n\t_.isObject = function (obj) {\n\t\treturn obj === Object(obj);\n\t};\n\n\t// Is a given variable an arguments object?\n\t_.isArguments = function (obj) {\n\t\treturn toString.call(obj) == '[object Arguments]';\n\t};\n\tif (!_.isArguments(arguments)) {\n\t\t_.isArguments = function (obj) {\n\t\t\treturn !!(obj && _.has(obj, 'callee'));\n\t\t};\n\t}\n\n\t// Is a given value a function?\n\t_.isFunction = function (obj) {\n\t\treturn toString.call(obj) == '[object Function]';\n\t};\n\n\t// Is a given value a string?\n\t_.isString = function (obj) {\n\t\treturn toString.call(obj) == '[object String]';\n\t};\n\n\t// Is a given value a number?\n\t_.isNumber = function (obj) {\n\t\treturn toString.call(obj) == '[object Number]';\n\t};\n\n\t// Is a given object a finite number?\n\t_.isFinite = function (obj) {\n\t\treturn _.isNumber(obj) && isFinite(obj);\n\t};\n\n\t// Is the given value `NaN`?\n\t_.isNaN = function (obj) {\n\t\t// `NaN` is the only value for which `===` is not reflexive.\n\t\treturn obj !== obj;\n\t};\n\n\t// Is a given value a boolean?\n\t_.isBoolean = function (obj) {\n\t\treturn obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n\t};\n\n\t// Is a given value a date?\n\t_.isDate = function (obj) {\n\t\treturn toString.call(obj) == '[object Date]';\n\t};\n\n\t// Is the given value a regular expression?\n\t_.isRegExp = function (obj) {\n\t\treturn toString.call(obj) == '[object RegExp]';\n\t};\n\n\t// Is a given value equal to null?\n\t_.isNull = function (obj) {\n\t\treturn obj === null;\n\t};\n\n\t// Is a given variable undefined?\n\t_.isUndefined = function (obj) {\n\t\treturn obj === void 0;\n\t};\n\n\t// Has own property?\n\t_.has = function (obj, key) {\n\t\treturn hasOwnProperty.call(obj, key);\n\t};\n\n\t// Utility Functions\n\t// -----------------\n\n\t// Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n\t// previous owner. Returns a reference to the Underscore object.\n\t_.noConflict = function () {\n\t\troot._ = previousUnderscore;\n\t\treturn this;\n\t};\n\n\t// Keep the identity function around for default iterators.\n\t_.identity = function (value) {\n\t\treturn value;\n\t};\n\n\t// Run a function **n** times.\n\t_.times = function (n, iterator, context) {\n\t\tfor (var i = 0; i < n; i++) {\n\t\t\titerator.call(context, i);\n\t\t}\n\t};\n\n\t// Escape a string for HTML interpolation.\n\t_.escape = function (string) {\n\t\treturn ('' + string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n\t};\n\n\t// If the value of the named property is a function then invoke it;\n\t// otherwise, return it.\n\t_.result = function (object, property) {\n\t\tif (object == null) return null;\n\t\tvar value = object[property];\n\t\treturn _.isFunction(value) ? value.call(object) : value;\n\t};\n\n\t// Add your own custom functions to the Underscore object, ensuring that\n\t// they're correctly added to the OOP wrapper as well.\n\t_.mixin = function (obj) {\n\t\teach(_.functions(obj), function (name) {\n\t\t\taddToWrapper(name, _[name] = obj[name]);\n\t\t});\n\t};\n\n\t// Generate a unique integer id (unique within the entire client session).\n\t// Useful for temporary DOM ids.\n\tvar idCounter = 0;\n\t_.uniqueId = function (prefix) {\n\t\tvar id = idCounter++;\n\t\treturn prefix ? prefix + id : id;\n\t};\n\n\t// By default, Underscore uses ERB-style template delimiters, change the\n\t// following template settings to use alternative delimiters.\n\t_.templateSettings = {\n\t\tevaluate: /<%([\\s\\S]+?)%>/g,\n\t\tinterpolate: /<%=([\\s\\S]+?)%>/g,\n\t\tescape: /<%-([\\s\\S]+?)%>/g\n\t};\n\n\t// When customizing `templateSettings`, if you don't want to define an\n\t// interpolation, evaluation or escaping regex, we need one that is\n\t// guaranteed not to match.\n\tvar noMatch = /.^/;\n\n\t// Certain characters need to be escaped so that they can be put into a\n\t// string literal.\n\tvar escapes = {\n\t\t'\\\\': '\\\\',\n\t\t\"'\": \"'\",\n\t\t'r': '\\r',\n\t\t'n': '\\n',\n\t\t't': '\\t',\n\t\t'u2028': '\\u2028',\n\t\t'u2029': '\\u2029'\n\t};\n\n\tfor (var p in escapes) {\n\t\tescapes[escapes[p]] = p;\n\t}var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\tvar unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n\t// Within an interpolation, evaluation, or escaping, remove HTML escaping\n\t// that had been previously added.\n\tvar unescape = function unescape(code) {\n\t\treturn code.replace(unescaper, function (match, escape) {\n\t\t\treturn escapes[escape];\n\t\t});\n\t};\n\n\t// JavaScript micro-templating, similar to John Resig's implementation.\n\t// Underscore templating handles arbitrary delimiters, preserves whitespace,\n\t// and correctly escapes quotes within interpolated code.\n\t_.template = function (text, data, settings) {\n\t\tsettings = _.defaults(settings || {}, _.templateSettings);\n\n\t\t// Compile the template source, taking care to escape characters that\n\t\t// cannot be included in a string literal and then unescape them in code\n\t\t// blocks.\n\t\tvar source = \"__p+='\" + text.replace(escaper, function (match) {\n\t\t\treturn '\\\\' + escapes[match];\n\t\t}).replace(settings.escape || noMatch, function (match, code) {\n\t\t\treturn \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n\t\t}).replace(settings.interpolate || noMatch, function (match, code) {\n\t\t\treturn \"'+\\n(\" + unescape(code) + \")+\\n'\";\n\t\t}).replace(settings.evaluate || noMatch, function (match, code) {\n\t\t\treturn \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n\t\t}) + \"';\\n\";\n\n\t\t// If a variable is not specified, place data values in local scope.\n\t\tif (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n\t\tsource = \"var __p='';\" + \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" + source + \"return __p;\\n\";\n\n\t\tvar render = new Function(settings.variable || 'obj', '_', source);\n\t\tif (data) return render(data, _);\n\t\tvar template = function template(data) {\n\t\t\treturn render.call(this, data, _);\n\t\t};\n\n\t\t// Provide the compiled function source as a convenience for build time\n\t\t// precompilation.\n\t\ttemplate.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n\t\treturn template;\n\t};\n\n\t// Add a \"chain\" function, which will delegate to the wrapper.\n\t_.chain = function (obj) {\n\t\treturn _(obj).chain();\n\t};\n\n\t// The OOP Wrapper\n\t// ---------------\n\n\t// If Underscore is called as a function, it returns a wrapped object that\n\t// can be used OO-style. This wrapper holds altered versions of all the\n\t// underscore functions. Wrapped objects may be chained.\n\tvar wrapper = function wrapper(obj) {\n\t\tthis._wrapped = obj;\n\t};\n\n\t// Expose `wrapper.prototype` as `_.prototype`\n\t_.prototype = wrapper.prototype;\n\n\t// Helper function to continue chaining intermediate results.\n\tvar result = function result(obj, chain) {\n\t\treturn chain ? _(obj).chain() : obj;\n\t};\n\n\t// A method to easily add functions to the OOP wrapper.\n\tvar addToWrapper = function addToWrapper(name, func) {\n\t\twrapper.prototype[name] = function () {\n\t\t\tvar args = slice.call(arguments);\n\t\t\tunshift.call(args, this._wrapped);\n\t\t\treturn result(func.apply(_, args), this._chain);\n\t\t};\n\t};\n\n\t// Add all of the Underscore functions to the wrapper object.\n\t_.mixin(_);\n\n\t// Add all mutator Array functions to the wrapper.\n\teach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function (name) {\n\t\tvar method = ArrayProto[name];\n\t\twrapper.prototype[name] = function () {\n\t\t\tvar wrapped = this._wrapped;\n\t\t\tmethod.apply(wrapped, arguments);\n\t\t\tvar length = wrapped.length;\n\t\t\tif ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n\t\t\treturn result(wrapped, this._chain);\n\t\t};\n\t});\n\n\t// Add all accessor Array functions to the wrapper.\n\teach(['concat', 'join', 'slice'], function (name) {\n\t\tvar method = ArrayProto[name];\n\t\twrapper.prototype[name] = function () {\n\t\t\treturn result(method.apply(this._wrapped, arguments), this._chain);\n\t\t};\n\t});\n\n\t// Start chaining a wrapped Underscore object.\n\twrapper.prototype.chain = function () {\n\t\tthis._chain = true;\n\t\treturn this;\n\t};\n\n\t// Extracts the result from a wrapped and chained object.\n\twrapper.prototype.value = function () {\n\t\treturn this._wrapped;\n\t};\n\treturn _;\n}.call({});\n/**\n * Core Emmet object, available in global scope\n */\nvar emmet = function (global) {\n\tvar _defaultSyntax = 'html';\n\tvar _defaultProfile = 'plain';\n\n\tif (typeof _ == 'undefined') {\n\t\ttry {\n\t\t\t// avoid collisions with RequireJS loader\n\t\t\t// also, JS obfuscators tends to translate\n\t\t\t// a[\"name\"] to a.name, which also breaks RequireJS\n\t\t\t_ = global[['require'][0]]('underscore'); // node.js\n\t\t} catch (e) {}\n\t}\n\n\tif (typeof _ == 'undefined') {\n\t\tthrow 'Cannot access to Underscore.js lib';\n\t}\n\n\t/** List of registered modules */\n\tvar modules = {\n\t\t_: _\n\t};\n\n\t/**\n  * Shared empty constructor function to aid in prototype-chain creation.\n  */\n\tvar ctor = function ctor() {};\n\n\t/**\n  * Helper function to correctly set up the prototype chain, for subclasses.\n  * Similar to `goog.inherits`, but uses a hash of prototype properties and\n  * class properties to be extended.\n  * Took it from Backbone.\n  * @param {Object} parent\n  * @param {Object} protoProps\n  * @param {Object} staticProps\n  * @returns {Object}\n  */\n\tfunction inherits(parent, protoProps, staticProps) {\n\t\tvar child;\n\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function child() {\n\t\t\t\tparent.apply(this, arguments);\n\t\t\t};\n\t\t}\n\n\t\t// Inherit class (static) properties from parent.\n\t\t_.extend(child, parent);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tctor.prototype = parent.prototype;\n\t\tchild.prototype = new ctor();\n\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif (protoProps) _.extend(child.prototype, protoProps);\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif (staticProps) _.extend(child, staticProps);\n\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tchild.prototype.constructor = child;\n\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t};\n\n\t/**\n  * @type Function Function that loads module definition if it's not defined\n  */\n\tvar moduleLoader = null;\n\n\t/**\n  * Generic Emmet module loader (actually, it doesnt load anything, just \n  * returns module reference). Not using `require` name to avoid conflicts\n  * with Node.js and RequireJS\n  */\n\tfunction r(name) {\n\t\tif (!(name in modules) && moduleLoader) moduleLoader(name);\n\n\t\treturn modules[name];\n\t}\n\n\treturn {\n\t\t/**\n   * Simple, AMD-like module definition. The module will be added into\n   * <code>emmet</code> object and will be available via\n   * <code>emmet.require(name)</code> or <code>emmet[name]</code>\n   * @param {String} name\n   * @param {Function} factory\n   * @memberOf emmet\n   */\n\t\tdefine: function define(name, factory) {\n\t\t\t// do not let redefine existing properties\n\t\t\tif (!(name in modules)) {\n\t\t\t\tmodules[name] = _.isFunction(factory) ? this.exec(factory) : factory;\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Returns reference to Emmet module\n   * @param {String} name Module name\n   */\n\t\trequire: r,\n\n\t\t/**\n   * Helper method that just executes passed function but with all \n   * important arguments like 'require' and '_'\n   * @param {Function} fn\n   * @param {Object} context Execution context\n   */\n\t\texec: function exec(fn, context) {\n\t\t\treturn fn.call(context || global, _.bind(r, this), _, this);\n\t\t},\n\n\t\t/**\n   * The self-propagating extend function for classes.\n   * Took it from Backbone \n   * @param {Object} protoProps\n   * @param {Object} classProps\n   * @returns {Object}\n   */\n\t\textend: function extend(protoProps, classProps) {\n\t\t\tvar child = inherits(this, protoProps, classProps);\n\t\t\tchild.extend = this.extend;\n\t\t\t// a hack required to WSH inherit `toString` method\n\t\t\tif (protoProps.hasOwnProperty('toString')) child.prototype.toString = protoProps.toString;\n\t\t\treturn child;\n\t\t},\n\n\t\t/**\n   * The essential function that expands Emmet abbreviation\n   * @param {String} abbr Abbreviation to parse\n   * @param {String} syntax Abbreviation's context syntax\n   * @param {String} profile Output profile (or its name)\n   * @param {Object} contextNode Contextual node where abbreviation is\n   * written\n   * @return {String}\n   */\n\t\texpandAbbreviation: function expandAbbreviation(abbr, syntax, profile, contextNode) {\n\t\t\tif (!abbr) return '';\n\n\t\t\tsyntax = syntax || _defaultSyntax;\n\t\t\t//\t\t\tprofile = profile || defaultProfile;\n\n\t\t\tvar filters = r('filters');\n\t\t\tvar parser = r('abbreviationParser');\n\n\t\t\tprofile = r('profile').get(profile, syntax);\n\t\t\tr('tabStops').resetTabstopIndex();\n\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar outputTree = parser.parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\n\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\tfilters.apply(outputTree, filtersList, profile);\n\t\t\treturn outputTree.toString();\n\t\t},\n\n\t\t/**\n   * Returns default syntax name used in abbreviation engine\n   * @returns {String}\n   */\n\t\tdefaultSyntax: function defaultSyntax() {\n\t\t\treturn _defaultSyntax;\n\t\t},\n\n\t\t/**\n   * Returns default profile name used in abbreviation engine\n   * @returns {String}\n   */\n\t\tdefaultProfile: function defaultProfile() {\n\t\t\treturn _defaultProfile;\n\t\t},\n\n\t\t/**\n   * Log message into console if it exists\n   */\n\t\tlog: function log() {\n\t\t\tif (global.console && global.console.log) global.console.log.apply(global.console, arguments);\n\t\t},\n\n\t\t/**\n   * Setups function that should synchronously load undefined modules\n   * @param {Function} fn\n   */\n\t\tsetModuleLoader: function setModuleLoader(fn) {\n\t\t\tmoduleLoader = fn;\n\t\t}\n\t};\n}(undefined);\n\n// export core for Node.JS\nif (true) {\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\texports = module.exports = emmet;\n\t}\n\texports.emmet = emmet;\n}\n\n// export as Require.js module\nif (true) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (emmet),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} /**\n  * Emmet abbreviation parser.\n  * Takes string abbreviation and recursively parses it into a tree. The parsed \n  * tree can be transformed into a string representation with \n  * <code>toString()</code> method. Note that string representation is defined\n  * by custom processors (called <i>filters</i>), not by abbreviation parser \n  * itself.\n  * \n  * This module can be extended with custom pre-/post-processors to shape-up\n  * final tree or its representation. Actually, many features of abbreviation \n  * engine are defined in other modules as tree processors\n  * \n  * \n  * @author Sergey Chikuyonok (serge.che@gmail.com)\n  * @link http://chikuyonok.ru\n  * @memberOf __abbreviationParser\n  * @constructor\n  * @param {Function} require\n  * @param {Underscore} _\n  */\nemmet.define('abbreviationParser', function (require, _) {\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\n\tvar reWord = /[\\w\\-:\\$@]/;\n\n\tvar pairs = {\n\t\t'[': ']',\n\t\t'(': ')',\n\t\t'{': '}'\n\t};\n\n\tvar spliceFn = Array.prototype.splice;\n\n\tvar preprocessors = [];\n\tvar postprocessors = [];\n\tvar outputProcessors = [];\n\n\t/**\n  * @type AbbreviationNode\n  */\n\tfunction AbbreviationNode(parent) {\n\t\t/** @type AbbreviationNode */\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\tthis._attributes = [];\n\n\t\t/** @type String Raw abbreviation for current node */\n\t\tthis.abbreviation = '';\n\t\tthis.counter = 1;\n\t\tthis._name = null;\n\t\tthis._text = '';\n\t\tthis.repeatCount = 1;\n\t\tthis.hasImplicitRepeat = false;\n\n\t\t/** Custom data dictionary */\n\t\tthis._data = {};\n\n\t\t// output properties\n\t\tthis.start = '';\n\t\tthis.end = '';\n\t\tthis.content = '';\n\t\tthis.padding = '';\n\t}\n\n\tAbbreviationNode.prototype = {\n\t\t/**\n   * Adds passed node as child or creates new child\n   * @param {AbbreviationNode} child\n   * @param {Number} position Index in children array where child should \n   * be inserted\n   * @return {AbbreviationNode}\n   */\n\t\taddChild: function addChild(child, position) {\n\t\t\tchild = child || new AbbreviationNode();\n\t\t\tchild.parent = this;\n\n\t\t\tif (_.isUndefined(position)) {\n\t\t\t\tthis.children.push(child);\n\t\t\t} else {\n\t\t\t\tthis.children.splice(position, 0, child);\n\t\t\t}\n\n\t\t\treturn child;\n\t\t},\n\n\t\t/**\n   * Creates a deep copy of current node\n   * @returns {AbbreviationNode}\n   */\n\t\tclone: function clone() {\n\t\t\tvar node = new AbbreviationNode();\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\n\t\t\t_.each(attrs, function (a) {\n\t\t\t\tnode[a] = this[a];\n\t\t\t}, this);\n\n\t\t\t// clone attributes\n\t\t\tnode._attributes = _.map(this._attributes, function (attr) {\n\t\t\t\treturn _.clone(attr);\n\t\t\t});\n\n\t\t\tnode._data = _.clone(this._data);\n\n\t\t\t// clone children\n\t\t\tnode.children = _.map(this.children, function (child) {\n\t\t\t\tchild = child.clone();\n\t\t\t\tchild.parent = node;\n\t\t\t\treturn child;\n\t\t\t});\n\n\t\t\treturn node;\n\t\t},\n\n\t\t/**\n   * Removes current node from parents child list\n   * @returns {AbbreviationNode} Current node itself\n   */\n\t\tremove: function remove() {\n\t\t\tif (this.parent) {\n\t\t\t\tthis.parent.children = _.without(this.parent.children, this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n   * Replaces current node in parents children list with passed nodes\n   * @param {AbbreviationNode} node Replacement node or array of nodes\n   */\n\t\treplace: function replace() {\n\t\t\tvar parent = this.parent;\n\t\t\tvar ix = _.indexOf(parent.children, this);\n\t\t\tvar items = _.flatten(arguments);\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\n\n\t\t\t// update parent\n\t\t\t_.each(items, function (item) {\n\t\t\t\titem.parent = parent;\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Recursively sets <code>property</code> to <code>value</code> of current\n   * node and its children \n   * @param {String} name Property to update\n   * @param {Object} value New property value\n   */\n\t\tupdateProperty: function updateProperty(name, value) {\n\t\t\tthis[name] = value;\n\t\t\t_.each(this.children, function (child) {\n\t\t\t\tchild.updateProperty(name, value);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n   * Finds first child node that matches truth test for passed \n   * <code>fn</code> function\n   * @param {Function} fn\n   * @returns {AbbreviationNode}\n   */\n\t\tfind: function find(fn) {\n\t\t\treturn this.findAll(fn)[0];\n\t\t\t//\t\t\tif (!_.isFunction(fn)) {\n\t\t\t//\t\t\t\tvar elemName = fn.toLowerCase();\n\t\t\t//\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\t\n\t\t\t//\t\t\tvar result = null;\n\t\t\t//\t\t\t_.find(this.children, function(child) {\n\t\t\t//\t\t\t\tif (fn(child)) {\n\t\t\t//\t\t\t\t\treturn result = child;\n\t\t\t//\t\t\t\t}\n\t\t\t//\t\t\t\t\n\t\t\t//\t\t\t\treturn result = child.find(fn);\n\t\t\t//\t\t\t});\n\t\t\t//\t\t\t\n\t\t\t//\t\t\treturn result;\n\t\t},\n\n\t\t/**\n   * Finds all child nodes that matches truth test for passed \n   * <code>fn</code> function\n   * @param {Function} fn\n   * @returns {Array}\n   */\n\t\tfindAll: function findAll(fn) {\n\t\t\tif (!_.isFunction(fn)) {\n\t\t\t\tvar elemName = fn.toLowerCase();\n\t\t\t\tfn = function fn(item) {\n\t\t\t\t\treturn item.name().toLowerCase() == elemName;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar result = [];\n\t\t\t_.each(this.children, function (child) {\n\t\t\t\tif (fn(child)) result.push(child);\n\n\t\t\t\tresult = result.concat(child.findAll(fn));\n\t\t\t});\n\n\t\t\treturn _.compact(result);\n\t\t},\n\n\t\t/**\n   * Sets/gets custom data\n   * @param {String} name\n   * @param {Object} value\n   * @returns {Object}\n   */\n\t\tdata: function data(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tthis._data[name] = value;\n\n\t\t\t\tif (name == 'resource' && require('elements').is(value, 'snippet')) {\n\t\t\t\t\t// setting snippet as matched resource: update `content`\n\t\t\t\t\t// property with snippet value\n\t\t\t\t\tthis.content = value.data;\n\t\t\t\t\tif (this._text) {\n\t\t\t\t\t\tthis.content = require('abbreviationUtils').insertChildContent(value.data, this._text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn this._data[name];\n\t\t},\n\n\t\t/**\n   * Returns name of current node\n   * @returns {String}\n   */\n\t\tname: function name() {\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element')) {\n\t\t\t\treturn res.name;\n\t\t\t}\n\n\t\t\treturn this._name;\n\t\t},\n\n\t\t/**\n   * Returns list of attributes for current node\n   * @returns {Array}\n   */\n\t\tattributeList: function attributeList() {\n\t\t\tvar attrs = [];\n\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element') && _.isArray(res.attributes)) {\n\t\t\t\tattrs = attrs.concat(res.attributes);\n\t\t\t}\n\n\t\t\treturn optimizeAttributes(attrs.concat(this._attributes));\n\t\t},\n\n\t\t/**\n   * Returns or sets attribute value\n   * @param {String} name Attribute name\n   * @param {String} value New attribute value\n   * @returns {String}\n   */\n\t\tattribute: function attribute(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\t// modifying attribute\n\t\t\t\tvar ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn (_.find(this.attributeList(), function (attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t},\n\n\t\t/**\n   * Returns reference to the matched <code>element</code>, if any.\n   * See {@link elements} module for a list of available elements\n   * @returns {Object}\n   */\n\t\tmatchedResource: function matchedResource() {\n\t\t\treturn this.data('resource');\n\t\t},\n\n\t\t/**\n   * Returns index of current node in parents children list\n   * @returns {Number}\n   */\n\t\tindex: function index() {\n\t\t\treturn this.parent ? _.indexOf(this.parent.children, this) : -1;\n\t\t},\n\n\t\t/**\n   * Sets how many times current element should be repeated\n   * @private\n   */\n\t\t_setRepeat: function _setRepeat(count) {\n\t\t\tif (count) {\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\n\t\t\t} else {\n\t\t\t\tthis.hasImplicitRepeat = true;\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Sets abbreviation that belongs to current node\n   * @param {String} abbr\n   */\n\t\tsetAbbreviation: function setAbbreviation(abbr) {\n\t\t\tabbr = abbr || '';\n\n\t\t\tvar that = this;\n\n\t\t\t// find multiplier\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function (str, repeatCount) {\n\t\t\t\tthat._setRepeat(repeatCount);\n\t\t\t\treturn '';\n\t\t\t});\n\n\t\t\tthis.abbreviation = abbr;\n\n\t\t\tvar abbrText = extractText(abbr);\n\t\t\tif (abbrText) {\n\t\t\t\tabbr = abbrText.element;\n\t\t\t\tthis.content = this._text = abbrText.text;\n\t\t\t}\n\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\n\t\t\tif (abbrAttrs) {\n\t\t\t\tabbr = abbrAttrs.element;\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\n\t\t\t}\n\n\t\t\tthis._name = abbr;\n\n\t\t\t// validate name\n\t\t\tif (this._name && !reValidName.test(this._name)) {\n\t\t\t\tthrow 'Invalid abbreviation';\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Returns string representation of current node\n   * @return {String}\n   */\n\t\ttoString: function toString() {\n\t\t\tvar utils = require('utils');\n\n\t\t\tvar start = this.start;\n\t\t\tvar end = this.end;\n\t\t\tvar content = this.content;\n\n\t\t\t// apply output processors\n\t\t\tvar node = this;\n\t\t\t_.each(outputProcessors, function (fn) {\n\t\t\t\tstart = fn(start, node, 'start');\n\t\t\t\tcontent = fn(content, node, 'content');\n\t\t\t\tend = fn(end, node, 'end');\n\t\t\t});\n\n\t\t\tvar innerContent = _.map(this.children, function (child) {\n\t\t\t\treturn child.toString();\n\t\t\t}).join('');\n\n\t\t\tcontent = require('abbreviationUtils').insertChildContent(content, innerContent, {\n\t\t\t\tkeepVariable: false\n\t\t\t});\n\n\t\t\treturn start + utils.padString(content, this.padding) + end;\n\t\t},\n\n\t\t/**\n   * Check if current node contains children with empty <code>expr</code>\n   * property\n   * @return {Boolean}\n   */\n\t\thasEmptyChildren: function hasEmptyChildren() {\n\t\t\treturn !!_.find(this.children, function (child) {\n\t\t\t\treturn child.isEmpty();\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Check if current node has implied name that should be resolved\n   * @returns {Boolean}\n   */\n\t\thasImplicitName: function hasImplicitName() {\n\t\t\treturn !this._name && !this.isTextNode();\n\t\t},\n\n\t\t/**\n   * Indicates that current element is a grouping one, e.g. has no \n   * representation but serves as a container for other nodes\n   * @returns {Boolean}\n   */\n\t\tisGroup: function isGroup() {\n\t\t\treturn !this.abbreviation;\n\t\t},\n\n\t\t/**\n   * Indicates empty node (i.e. without abbreviation). It may be a \n   * grouping node and should not be outputted\n   * @return {Boolean}\n   */\n\t\tisEmpty: function isEmpty() {\n\t\t\treturn !this.abbreviation && !this.children.length;\n\t\t},\n\n\t\t/**\n   * Indicates that current node should be repeated\n   * @returns {Boolean}\n   */\n\t\tisRepeating: function isRepeating() {\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\n\t\t},\n\n\t\t/**\n   * Check if current node is a text-only node\n   * @return {Boolean}\n   */\n\t\tisTextNode: function isTextNode() {\n\t\t\treturn !this.name() && !this.attributeList().length;\n\t\t},\n\n\t\t/**\n   * Indicates whether this node may be used to build elements or snippets\n   * @returns {Boolean}\n   */\n\t\tisElement: function isElement() {\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\n\t\t},\n\n\t\t/**\n   * Returns latest and deepest child of current tree\n   * @returns {AbbreviationNode}\n   */\n\t\tdeepestChild: function deepestChild() {\n\t\t\tif (!this.children.length) return null;\n\n\t\t\tvar deepestChild = this;\n\t\t\twhile (deepestChild.children.length) {\n\t\t\t\tdeepestChild = _.last(deepestChild.children);\n\t\t\t}\n\n\t\t\treturn deepestChild;\n\t\t}\n\t};\n\n\t/**\n  * Returns stripped string: a string without first and last character.\n  * Used for unquoting strings\n  * @param {String} str\n  * @returns {String}\n  */\n\tfunction stripped(str) {\n\t\treturn str.substring(1, str.length - 1);\n\t}\n\n\tfunction consumeQuotedValue(stream, quote) {\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch === quote) return true;\n\n\t\t\tif (ch == '\\\\') continue;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n  * Parses abbreviation into a tree\n  * @param {String} abbr\n  * @returns {AbbreviationNode}\n  */\n\tfunction parseAbbreviation(abbr) {\n\t\tabbr = require('utils').trim(abbr);\n\n\t\tvar root = new AbbreviationNode();\n\t\tvar context = root.addChild(),\n\t\t    ch;\n\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\tvar loopProtector = 1000,\n\t\t    multiplier;\n\n\t\twhile (!stream.eol() && --loopProtector > 0) {\n\t\t\tch = stream.peek();\n\n\t\t\tswitch (ch) {\n\t\t\t\tcase '(':\n\t\t\t\t\t// abbreviation group\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\n\t\t\t\t\t\tif (multiplier = stream.match(/^\\*(\\d+)?/, true)) {\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_.each(inner.children, function (child) {\n\t\t\t\t\t\t\tcontext.addChild(child);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '>':\n\t\t\t\t\t// child operator\n\t\t\t\t\tcontext = context.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '+':\n\t\t\t\t\t// sibling operator\n\t\t\t\t\tcontext = context.parent.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '^':\n\t\t\t\t\t// climb up operator\n\t\t\t\t\tvar parent = context.parent || context;\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// consume abbreviation\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(function (c) {\n\t\t\t\t\t\tif (c == '[' || c == '{') {\n\t\t\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\n\t\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (c == '+') {\n\t\t\t\t\t\t\t// let's see if this is an expando marker\n\t\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\t\tvar isMarker = stream.eol() || ~'+>^*'.indexOf(stream.peek());\n\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\treturn isMarker;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn c != '(' && _isAllowedChar(c);\n\t\t\t\t\t});\n\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\n\t\tif (loopProtector < 1) throw 'Endless loop detected';\n\n\t\treturn root;\n\t}\n\n\t/**\n  * Extract attributes and their values from attribute set: \n  * <code>[attr col=3 title=\"Quoted string\"]</code>\n  * @param {String} attrSet\n  * @returns {Array}\n  */\n\tfunction extractAttributes(attrSet, attrs) {\n\t\tattrSet = require('utils').trim(attrSet);\n\t\tvar result = [];\n\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(attrSet);\n\t\tstream.eatSpace();\n\n\t\twhile (!stream.eol()) {\n\t\t\tstream.start = stream.pos;\n\t\t\tif (stream.eatWhile(reWord)) {\n\t\t\t\tvar attrName = stream.current();\n\t\t\t\tvar attrValue = '';\n\t\t\t\tif (stream.peek() == '=') {\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tvar quote = stream.peek();\n\n\t\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\tif (consumeQuotedValue(stream, quote)) {\n\t\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t\t\t// strip quotes\n\t\t\t\t\t\t\tattrValue = attrValue.substring(1, attrValue.length - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (stream.eatWhile(/[^\\s\\]]/)) {\n\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tresult.push({\n\t\t\t\t\tname: attrName,\n\t\t\t\t\tvalue: attrValue\n\t\t\t\t});\n\t\t\t\tstream.eatSpace();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n  * Parses tag attributes extracted from abbreviation. If attributes found, \n  * returns object with <code>element</code> and <code>attributes</code>\n  * properties\n  * @param {String} abbr\n  * @returns {Object} Returns <code>null</code> if no attributes found in \n  * abbreviation\n  */\n\tfunction parseAttributes(abbr) {\n\t\t/*\n   * Example of incoming data:\n   * #header\n   * .some.data\n   * .some.data#header\n   * [attr]\n   * #item[attr=Hello other=\"World\"].class\n   */\n\t\tvar result = [];\n\t\tvar attrMap = { '#': 'id', '.': 'class' };\n\t\tvar nameEnd = null;\n\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '#': // id\n\t\t\t\tcase '.':\n\t\t\t\t\t// class\n\t\t\t\t\tif (nameEnd === null) nameEnd = stream.pos;\n\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\n\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(reWord);\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tname: attrName,\n\t\t\t\t\t\tvalue: stream.current()\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[':\n\t\t\t\t\t//begin attribute set\n\t\t\t\t\tif (nameEnd === null) nameEnd = stream.pos;\n\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) throw 'Invalid attribute set definition';\n\n\t\t\t\t\tresult = result.concat(extractAttributes(stripped(stream.current())));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\n\t\tif (!result.length) return null;\n\n\t\treturn {\n\t\t\telement: abbr.substring(0, nameEnd),\n\t\t\tattributes: optimizeAttributes(result)\n\t\t};\n\t}\n\n\t/**\n  * Optimize attribute set: remove duplicates and merge class attributes\n  * @param attrs\n  */\n\tfunction optimizeAttributes(attrs) {\n\t\t// clone all attributes to make sure that original objects are \n\t\t// not modified\n\t\tattrs = _.map(attrs, function (attr) {\n\t\t\treturn _.clone(attr);\n\t\t});\n\n\t\tvar lookup = {};\n\t\treturn _.filter(attrs, function (attr) {\n\t\t\tif (!(attr.name in lookup)) {\n\t\t\t\treturn lookup[attr.name] = attr;\n\t\t\t}\n\n\t\t\tvar la = lookup[attr.name];\n\n\t\t\tif (attr.name.toLowerCase() == 'class') {\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\n\t\t\t} else {\n\t\t\t\tla.value = attr.value;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t});\n\t}\n\n\t/**\n  * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\n  * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\n  * If nothing found, returns <code>null</code>\n  * @param {String} abbr\n  * \n  */\n\tfunction extractText(abbr) {\n\t\tif (!~abbr.indexOf('{')) return null;\n\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]);break;\n\n\t\t\t\tcase '{':\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\n\t\t\t\t\t\ttext: stripped(stream.current())\n\t\t\t\t\t};\n\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Un-rolls contents of current node: recursively replaces all repeating \n  * children with their repeated clones\n  * @param {AbbreviationNode} node\n  * @returns {AbbreviationNode}\n  */\n\tfunction unroll(node) {\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\n\t\t\tchild = node.children[i];\n\n\t\t\tif (child.isRepeating()) {\n\t\t\t\tmaxCount = j = child.repeatCount;\n\t\t\t\tchild.repeatCount = 1;\n\t\t\t\tchild.updateProperty('counter', 1);\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\n\t\t\t\twhile (--j > 0) {\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1).updateProperty('counter', j + 1).updateProperty('maxCount', maxCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// to keep proper 'counter' property, we need to walk\n\t\t// on children once again\n\t\t_.each(node.children, unroll);\n\n\t\treturn node;\n\t}\n\n\t/**\n  * Optimizes tree node: replaces empty nodes with their children\n  * @param {AbbreviationNode} node\n  * @return {AbbreviationNode}\n  */\n\tfunction squash(node) {\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\n\t\t\t/** @type AbbreviationNode */\n\t\t\tvar n = node.children[i];\n\t\t\tif (n.isGroup()) {\n\t\t\t\tn.replace(squash(n).children);\n\t\t\t} else if (n.isEmpty()) {\n\t\t\t\tn.remove();\n\t\t\t}\n\t\t}\n\n\t\t_.each(node.children, squash);\n\n\t\treturn node;\n\t}\n\n\tfunction _isAllowedChar(ch) {\n\t\tvar charCode = ch.charCodeAt(0);\n\t\tvar specialChars = '#.*:$-_!@|%';\n\n\t\treturn charCode > 64 && charCode < 91 || // uppercase letter\n\t\tcharCode > 96 && charCode < 123 // lowercase letter\n\t\t|| charCode > 47 && charCode < 58 // number\n\t\t|| specialChars.indexOf(ch) != -1; // special character\n\t}\n\n\t// XXX add counter replacer function as output processor\n\toutputProcessors.push(function (text, node) {\n\t\treturn require('utils').replaceCounter(text, node.counter, node.maxCount);\n\t});\n\n\treturn {\n\t\t/**\n   * Parses abbreviation into tree with respect of groups, \n   * text nodes and attributes. Each node of the tree is a single \n   * abbreviation. Tree represents actual structure of the outputted \n   * result\n   * @memberOf abbreviationParser\n   * @param {String} abbr Abbreviation to parse\n   * @param {Object} options Additional options for parser and processors\n   * \n   * @return {AbbreviationNode}\n   */\n\t\tparse: function parse(abbr, options) {\n\t\t\toptions = options || {};\n\n\t\t\tvar tree = parseAbbreviation(abbr);\n\n\t\t\tif (options.contextNode) {\n\t\t\t\t// add info about context node \n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \n\t\t\t\t// expanded\n\t\t\t\ttree._name = options.contextNode.name;\n\t\t\t\tvar attrLookup = {};\n\t\t\t\t_.each(tree._attributes, function (attr) {\n\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t});\n\n\t\t\t\t_.each(options.contextNode.attributes, function (attr) {\n\t\t\t\t\tif (attr.name in attrLookup) {\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr = _.clone(attr);\n\t\t\t\t\t\ttree._attributes.push(attr);\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// apply preprocessors\n\t\t\t_.each(preprocessors, function (fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\n\t\t\ttree = squash(unroll(tree));\n\n\t\t\t// apply postprocessors\n\t\t\t_.each(postprocessors, function (fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\n\t\t\treturn tree;\n\t\t},\n\n\t\tAbbreviationNode: AbbreviationNode,\n\n\t\t/**\n   * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\n   * that applies to a parsed abbreviation tree right after it get parsed.\n   * The passed tree is in unoptimized state.\n   * @param {Function} fn Preprocessor function. This function receives\n   * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n   * and <code>options</code> hash that was passed to <code>parse</code>\n   * method\n   */\n\t\taddPreprocessor: function addPreprocessor(fn) {\n\t\t\tif (!_.include(preprocessors, fn)) preprocessors.push(fn);\n\t\t},\n\n\t\t/**\n   * Removes registered preprocessor\n   */\n\t\tremoveFilter: function removeFilter(fn) {\n\t\t\tpreprocessor = _.without(preprocessors, fn);\n\t\t},\n\n\t\t/**\n   * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \n   * functinon that applies to <i>optimized</i> parsed abbreviation tree\n   * right before it returns from <code>parse()</code> method\n   * @param {Function} fn Postprocessor function. This function receives\n   * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n   * and <code>options</code> hash that was passed to <code>parse</code>\n   * method\n   */\n\t\taddPostprocessor: function addPostprocessor(fn) {\n\t\t\tif (!_.include(postprocessors, fn)) postprocessors.push(fn);\n\t\t},\n\n\t\t/**\n   * Removes registered postprocessor function\n   */\n\t\tremovePostprocessor: function removePostprocessor(fn) {\n\t\t\tpostprocessors = _.without(postprocessors, fn);\n\t\t},\n\n\t\t/**\n   * Registers output postprocessor. <i>Output processor</i> is a \n   * function that applies to output part (<code>start</code>, \n   * <code>end</code> and <code>content</code>) when \n   * <code>AbbreviationNode.toString()</code> method is called\n   */\n\t\taddOutputProcessor: function addOutputProcessor(fn) {\n\t\t\tif (!_.include(outputProcessors, fn)) outputProcessors.push(fn);\n\t\t},\n\n\t\t/**\n   * Removes registered output processor\n   */\n\t\tremoveOutputProcessor: function removeOutputProcessor(fn) {\n\t\t\toutputProcessors = _.without(outputProcessors, fn);\n\t\t},\n\n\t\t/**\n   * Check if passed symbol is valid symbol for abbreviation expression\n   * @param {String} ch\n   * @return {Boolean}\n   */\n\t\tisAllowedChar: function isAllowedChar(ch) {\n\t\t\tch = String(ch); // convert Java object to JS\n\t\t\treturn _isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\n\t\t}\n\t};\n}); /**\n    * Processor function that matches parsed <code>AbbreviationNode</code>\n    * against resources defined in <code>resource</code> module\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\t/**\n  * Finds matched resources for child nodes of passed <code>node</code> \n  * element. A matched resource is a reference to <i>snippets.json</i> entry\n  * that describes output of parsed node \n  * @param {AbbreviationNode} node\n  * @param {String} syntax\n  */\n\tfunction matchResources(node, syntax) {\n\t\tvar resources = require('resources');\n\t\tvar elements = require('elements');\n\t\tvar parser = require('abbreviationParser');\n\n\t\t// do a shallow copy because the children list can be modified during\n\t\t// resource matching\n\t\t_.each(_.clone(node.children), /** @param {AbbreviationNode} child */function (child) {\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\n\t\t\tif (_.isString(r)) {\n\t\t\t\tchild.data('resource', elements.create('snippet', r));\n\t\t\t} else if (elements.is(r, 'reference')) {\n\t\t\t\t// its a reference to another abbreviation:\n\t\t\t\t// parse it and insert instead of current child\n\t\t\t\t/** @type AbbreviationNode */\n\t\t\t\tvar subtree = parser.parse(r.data, {\n\t\t\t\t\tsyntax: syntax\n\t\t\t\t});\n\n\t\t\t\t// if context element should be repeated, check if we need to \n\t\t\t\t// transfer repeated element to specific child node\n\t\t\t\tif (child.repeatCount > 1) {\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function (node) {\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\n\t\t\t\t\t});\n\n\t\t\t\t\t_.each(repeatedChildren, function (node) {\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// move childs children into the deepest child of new subtree\n\t\t\t\tvar deepestChild = subtree.deepestChild();\n\t\t\t\tif (deepestChild) {\n\t\t\t\t\t_.each(child.children, function (c) {\n\t\t\t\t\t\tdeepestChild.addChild(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// copy current attributes to children\n\t\t\t\t_.each(subtree.children, function (node) {\n\t\t\t\t\t_.each(child.attributeList(), function (attr) {\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tchild.replace(subtree.children);\n\t\t\t} else {\n\t\t\t\tchild.data('resource', r);\n\t\t\t}\n\n\t\t\tmatchResources(child, syntax);\n\t\t});\n\t}\n\n\t// XXX register abbreviation filter that creates references to resources\n\t// on abbreviation nodes\n\t/**\n  * @param {AbbreviationNode} tree\n  */\n\trequire('abbreviationParser').addPreprocessor(function (tree, options) {\n\t\tvar syntax = options.syntax || emmet.defaultSyntax();\n\t\tmatchResources(tree, syntax);\n\t});\n}); /**\n    * Pasted content abbreviation processor. A pasted content is a content that\n    * should be inserted into implicitly repeated abbreviation nodes.\n    * This processor powers Wrap With Abbreviation action\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\tvar parser = require('abbreviationParser');\n\tvar outputPlaceholder = '$#';\n\n\t/**\n  * Locates output placeholders inside text\n  * @param {String} text\n  * @returns {Array} Array of ranges of output placeholder in text\n  */\n\tfunction locateOutputPlaceholder(text) {\n\t\tvar range = require('range');\n\t\tvar result = [];\n\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(text);\n\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == '\\\\') {\n\t\t\t\tstream.next();\n\t\t\t} else {\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstream.next();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n  * Replaces output placeholders inside <code>source</code> with \n  * <code>value</code>\n  * @param {String} source\n  * @param {String} value\n  * @returns {String}\n  */\n\tfunction replaceOutputPlaceholders(source, value) {\n\t\tvar utils = require('utils');\n\t\tvar ranges = locateOutputPlaceholder(source);\n\n\t\tranges.reverse();\n\t\t_.each(ranges, function (r) {\n\t\t\tsource = utils.replaceSubstring(source, value, r);\n\t\t});\n\n\t\treturn source;\n\t}\n\n\t/**\n  * Check if parsed node contains output placeholder  a target where\n  * pasted content should be inserted\n  * @param {AbbreviationNode} node\n  * @returns {Boolean}\n  */\n\tfunction hasOutputPlaceholder(node) {\n\t\tif (locateOutputPlaceholder(node.content).length) return true;\n\n\t\t// check if attributes contains placeholder\n\t\treturn !!_.find(node.attributeList(), function (attr) {\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\n\t\t});\n\t}\n\n\t/**\n  * Insert pasted content into correct positions of parsed node\n  * @param {AbbreviationNode} node\n  * @param {String} content\n  * @param {Boolean} overwrite Overwrite node content if no value placeholders\n  * found instead of appending to existing content\n  */\n\tfunction insertPastedContent(node, content, overwrite) {\n\t\tvar nodesWithPlaceholders = node.findAll(function (item) {\n\t\t\treturn hasOutputPlaceholder(item);\n\t\t});\n\n\t\tif (hasOutputPlaceholder(node)) nodesWithPlaceholders.unshift(node);\n\n\t\tif (nodesWithPlaceholders.length) {\n\t\t\t_.each(nodesWithPlaceholders, function (item) {\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\n\t\t\t\t_.each(item._attributes, function (attr) {\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\t// on output placeholders in subtree, insert content in the deepest\n\t\t\t// child node\n\t\t\tvar deepest = node.deepestChild() || node;\n\t\t\tif (overwrite) {\n\t\t\t\tdeepest.content = content;\n\t\t\t} else {\n\t\t\t\tdeepest.content = require('abbreviationUtils').insertChildContent(deepest.content, content);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * @param {AbbreviationNode} tree\n  * @param {Object} options\n  */\n\tparser.addPreprocessor(function (tree, options) {\n\t\tif (options.pastedContent) {\n\t\t\tvar utils = require('utils');\n\t\t\tvar lines = _.map(utils.splitByLines(options.pastedContent, true), utils.trim);\n\n\t\t\t// set repeat count for implicitly repeated elements before\n\t\t\t// tree is unrolled\n\t\t\ttree.findAll(function (item) {\n\t\t\t\tif (item.hasImplicitRepeat) {\n\t\t\t\t\titem.data('paste', lines);\n\t\t\t\t\treturn item.repeatCount = lines.length;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\t/**\n  * @param {AbbreviationNode} tree\n  * @param {Object} options\n  */\n\tparser.addPostprocessor(function (tree, options) {\n\t\t// for each node with pasted content, update text data\n\t\tvar targets = tree.findAll(function (item) {\n\t\t\tvar pastedContentObj = item.data('paste');\n\t\t\tvar pastedContent = '';\n\t\t\tif (_.isArray(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj[item.counter - 1];\n\t\t\t} else if (_.isFunction(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj(item.counter - 1, item.content);\n\t\t\t} else if (pastedContentObj) {\n\t\t\t\tpastedContent = pastedContentObj;\n\t\t\t}\n\n\t\t\tif (pastedContent) {\n\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\n\t\t\t}\n\n\t\t\titem.data('paste', null);\n\t\t\treturn !!pastedContentObj;\n\t\t});\n\n\t\tif (!targets.length && options.pastedContent) {\n\t\t\t// no implicitly repeated elements, put pasted content in\n\t\t\t// the deepest child\n\t\t\tinsertPastedContent(tree, options.pastedContent);\n\t\t}\n\t});\n}); /**\n    * Resolves tag names in abbreviations with implied name\n    */\nemmet.exec(function (require, _) {\n\t/**\n  * Resolves implicit node names in parsed tree\n  * @param {AbbreviationNode} tree\n  */\n\tfunction resolveNodeNames(tree) {\n\t\tvar tagName = require('tagName');\n\t\t_.each(tree.children, function (node) {\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\n\t\t\t}\n\t\t\tresolveNodeNames(node);\n\t\t});\n\n\t\treturn tree;\n\t}\n\n\trequire('abbreviationParser').addPostprocessor(resolveNodeNames);\n}); /**\n    * @author Stoyan Stefanov\n    * @link https://github.com/stoyan/etc/tree/master/cssex\n    */\n\nemmet.define('cssParser', function (require, _) {\n\tvar walker,\n\t    tokens = [],\n\t    isOp,\n\t    isNameChar,\n\t    isDigit;\n\n\t// walks around the source\n\twalker = {\n\t\tlines: null,\n\t\ttotal_lines: 0,\n\t\tlinenum: -1,\n\t\tline: '',\n\t\tch: '',\n\t\tchnum: -1,\n\t\tinit: function init(source) {\n\t\t\tvar me = walker;\n\n\t\t\t// source, yumm\n\t\t\tme.lines = source.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n').split('\\n');\n\t\t\tme.total_lines = me.lines.length;\n\n\t\t\t// reset\n\t\t\tme.chnum = -1;\n\t\t\tme.linenum = -1;\n\t\t\tme.ch = '';\n\t\t\tme.line = '';\n\n\t\t\t// advance\n\t\t\tme.nextLine();\n\t\t\tme.nextChar();\n\t\t},\n\t\tnextLine: function nextLine() {\n\t\t\tvar me = this;\n\t\t\tme.linenum += 1;\n\t\t\tif (me.total_lines <= me.linenum) {\n\t\t\t\tme.line = false;\n\t\t\t} else {\n\t\t\t\tme.line = me.lines[me.linenum];\n\t\t\t}\n\t\t\tif (me.chnum !== -1) {\n\t\t\t\tme.chnum = 0;\n\t\t\t}\n\t\t\treturn me.line;\n\t\t},\n\t\tnextChar: function nextChar() {\n\t\t\tvar me = this;\n\t\t\tme.chnum += 1;\n\t\t\twhile (me.line.charAt(me.chnum) === '') {\n\t\t\t\tif (this.nextLine() === false) {\n\t\t\t\t\tme.ch = false;\n\t\t\t\t\treturn false; // end of source\n\t\t\t\t}\n\t\t\t\tme.chnum = -1;\n\t\t\t\tme.ch = '\\n';\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\tme.ch = me.line.charAt(me.chnum);\n\t\t\treturn me.ch;\n\t\t},\n\t\tpeek: function peek() {\n\t\t\treturn this.line.charAt(this.chnum + 1);\n\t\t}\n\t};\n\n\t// utility helpers\n\tisNameChar = function isNameChar(c) {\n\t\t// be more tolerate for name tokens: allow & character for LESS syntax\n\t\treturn c == '&' || c === '_' || c === '-' || c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';\n\t};\n\n\tisDigit = function isDigit(ch) {\n\t\treturn ch !== false && ch >= '0' && ch <= '9';\n\t};\n\n\tisOp = function () {\n\t\tvar opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\n\t\t    opsmatcha = \"*^|$~\".split(''),\n\t\t    ops = {},\n\t\t    opsmatch = {},\n\t\t    i = 0;\n\t\tfor (; i < opsa.length; i += 1) {\n\t\t\tops[opsa[i]] = true;\n\t\t}\n\t\tfor (i = 0; i < opsmatcha.length; i += 1) {\n\t\t\topsmatch[opsmatcha[i]] = true;\n\t\t}\n\t\treturn function (ch, matchattr) {\n\t\t\tif (matchattr) {\n\t\t\t\treturn !!opsmatch[ch];\n\t\t\t}\n\t\t\treturn !!ops[ch];\n\t\t};\n\t}();\n\n\t// shorthands\n\tfunction isset(v) {\n\t\treturn typeof v !== 'undefined';\n\t}\n\tfunction getConf() {\n\t\treturn {\n\t\t\t'char': walker.chnum,\n\t\t\tline: walker.linenum\n\t\t};\n\t}\n\n\t// creates token objects and pushes them to a list\n\tfunction tokener(value, type, conf) {\n\t\tvar w = walker,\n\t\t    c = conf || {};\n\t\ttokens.push({\n\t\t\tcharstart: isset(c['char']) ? c['char'] : w.chnum,\n\t\t\tcharend: isset(c.charend) ? c.charend : w.chnum,\n\t\t\tlinestart: isset(c.line) ? c.line : w.linenum,\n\t\t\tlineend: isset(c.lineend) ? c.lineend : w.linenum,\n\t\t\tvalue: value,\n\t\t\ttype: type || value\n\t\t});\n\t}\n\n\t// oops\n\tfunction error(m, config) {\n\t\tvar w = walker,\n\t\t    conf = config || {},\n\t\t    c = isset(conf['char']) ? conf['char'] : w.chnum,\n\t\t    l = isset(conf.line) ? conf.line : w.linenum;\n\t\treturn {\n\t\t\tname: \"ParseError\",\n\t\t\tmessage: m + \" at line \" + (l + 1) + ' char ' + (c + 1),\n\t\t\twalker: w,\n\t\t\ttokens: tokens\n\t\t};\n\t}\n\n\t// token handlers follow for:\n\t// white space, comment, string, identifier, number, operator\n\tfunction white() {\n\n\t\tvar c = walker.ch,\n\t\t    token = '',\n\t\t    conf = getConf();\n\n\t\twhile (c === \" \" || c === \"\\t\") {\n\t\t\ttoken += c;\n\t\t\tc = walker.nextChar();\n\t\t}\n\n\t\ttokener(token, 'white', conf);\n\t}\n\n\tfunction comment() {\n\n\t\tvar w = walker,\n\t\t    c = w.ch,\n\t\t    token = c,\n\t\t    cnext,\n\t\t    conf = getConf();\n\n\t\tcnext = w.nextChar();\n\n\t\tif (cnext === '/') {\n\t\t\t// inline comment in SCSS and such\n\t\t\ttoken += cnext;\n\t\t\tvar pk = w.peek();\n\t\t\twhile (pk && pk !== '\\n') {\n\t\t\t\ttoken += cnext;\n\t\t\t\tcnext = w.nextChar();\n\t\t\t\tpk = w.peek();\n\t\t\t}\n\t\t} else if (cnext === '*') {\n\t\t\t// multiline CSS commment\n\t\t\twhile (!(c === \"*\" && cnext === \"/\")) {\n\t\t\t\ttoken += cnext;\n\t\t\t\tc = cnext;\n\t\t\t\tcnext = w.nextChar();\n\t\t\t}\n\t\t} else {\n\t\t\t// oops, not a comment, just a /\n\t\t\tconf.charend = conf['char'];\n\t\t\tconf.lineend = conf.line;\n\t\t\treturn tokener(token, token, conf);\n\t\t}\n\n\t\ttoken += cnext;\n\t\tw.nextChar();\n\t\ttokener(token, 'comment', conf);\n\t}\n\n\tfunction str() {\n\t\tvar w = walker,\n\t\t    c = w.ch,\n\t\t    q = c,\n\t\t    token = c,\n\t\t    cnext,\n\t\t    conf = getConf();\n\n\t\tc = w.nextChar();\n\n\t\twhile (c !== q) {\n\n\t\t\tif (c === '\\n') {\n\t\t\t\tcnext = w.nextChar();\n\t\t\t\tif (cnext === \"\\\\\") {\n\t\t\t\t\ttoken += c + cnext;\n\t\t\t\t} else {\n\t\t\t\t\t// end of line with no \\ escape = bad\n\t\t\t\t\tthrow error(\"Unterminated string\", conf);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (c === \"\\\\\") {\n\t\t\t\t\ttoken += c + w.nextChar();\n\t\t\t\t} else {\n\t\t\t\t\ttoken += c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc = w.nextChar();\n\t\t}\n\t\ttoken += c;\n\t\tw.nextChar();\n\t\ttokener(token, 'string', conf);\n\t}\n\n\tfunction brace() {\n\t\tvar w = walker,\n\t\t    c = w.ch,\n\t\t    depth = 0,\n\t\t    token = c,\n\t\t    conf = getConf();\n\n\t\tc = w.nextChar();\n\n\t\twhile (c !== ')' && !depth) {\n\t\t\tif (c === '(') {\n\t\t\t\tdepth++;\n\t\t\t} else if (c === ')') {\n\t\t\t\tdepth--;\n\t\t\t} else if (c === false) {\n\t\t\t\tthrow error(\"Unterminated brace\", conf);\n\t\t\t}\n\n\t\t\ttoken += c;\n\t\t\tc = w.nextChar();\n\t\t}\n\n\t\ttoken += c;\n\t\tw.nextChar();\n\t\ttokener(token, 'brace', conf);\n\t}\n\n\tfunction identifier(pre) {\n\t\tvar w = walker,\n\t\t    c = w.ch,\n\t\t    conf = getConf(),\n\t\t    token = pre ? pre + c : c;\n\n\t\tc = w.nextChar();\n\n\t\tif (pre) {\n\t\t\t// adjust token position\n\t\t\tconf['char'] -= pre.length;\n\t\t}\n\n\t\twhile (isNameChar(c) || isDigit(c)) {\n\t\t\ttoken += c;\n\t\t\tc = w.nextChar();\n\t\t}\n\n\t\ttokener(token, 'identifier', conf);\n\t}\n\n\tfunction num() {\n\t\tvar w = walker,\n\t\t    c = w.ch,\n\t\t    conf = getConf(),\n\t\t    token = c,\n\t\t    point = token === '.',\n\t\t    nondigit;\n\n\t\tc = w.nextChar();\n\t\tnondigit = !isDigit(c);\n\n\t\t// .2px or .classname?\n\t\tif (point && nondigit) {\n\t\t\t// meh, NaN, could be a class name, so it's an operator for now\n\t\t\tconf.charend = conf['char'];\n\t\t\tconf.lineend = conf.line;\n\t\t\treturn tokener(token, '.', conf);\n\t\t}\n\n\t\t// -2px or -moz-something\n\t\tif (token === '-' && nondigit) {\n\t\t\treturn identifier('-');\n\t\t}\n\n\t\twhile (c !== false && (isDigit(c) || !point && c === '.')) {\n\t\t\t// not end of source && digit or first instance of .\n\t\t\tif (c === '.') {\n\t\t\t\tpoint = true;\n\t\t\t}\n\t\t\ttoken += c;\n\t\t\tc = w.nextChar();\n\t\t}\n\n\t\ttokener(token, 'number', conf);\n\t}\n\n\tfunction op() {\n\t\tvar w = walker,\n\t\t    c = w.ch,\n\t\t    conf = getConf(),\n\t\t    token = c,\n\t\t    next = w.nextChar();\n\n\t\tif (next === \"=\" && isOp(token, true)) {\n\t\t\ttoken += next;\n\t\t\ttokener(token, 'match', conf);\n\t\t\tw.nextChar();\n\t\t\treturn;\n\t\t}\n\n\t\tconf.charend = conf['char'] + 1;\n\t\tconf.lineend = conf.line;\n\t\ttokener(token, token, conf);\n\t}\n\n\t// call the appropriate handler based on the first character in a token suspect\n\tfunction tokenize() {\n\n\t\tvar ch = walker.ch;\n\n\t\tif (ch === \" \" || ch === \"\\t\") {\n\t\t\treturn white();\n\t\t}\n\n\t\tif (ch === '/') {\n\t\t\treturn comment();\n\t\t}\n\n\t\tif (ch === '\"' || ch === \"'\") {\n\t\t\treturn str();\n\t\t}\n\n\t\tif (ch === '(') {\n\t\t\treturn brace();\n\t\t}\n\n\t\tif (ch === '-' || ch === '.' || isDigit(ch)) {\n\t\t\t// tricky - char: minus (-1px) or dash (-moz-stuff)\n\t\t\treturn num();\n\t\t}\n\n\t\tif (isNameChar(ch)) {\n\t\t\treturn identifier();\n\t\t}\n\n\t\tif (isOp(ch)) {\n\t\t\treturn op();\n\t\t}\n\n\t\tif (ch === \"\\n\") {\n\t\t\ttokener(\"line\");\n\t\t\twalker.nextChar();\n\t\t\treturn;\n\t\t}\n\n\t\tthrow error(\"Unrecognized character\");\n\t}\n\n\t/**\n * Returns newline character at specified position in content\n * @param {String} content\n * @param {Number} pos\n * @return {String}\n */\n\tfunction getNewline(content, pos) {\n\t\treturn content.charAt(pos) == '\\r' && content.charAt(pos + 1) == '\\n' ? '\\r\\n' : content.charAt(pos);\n\t}\n\n\treturn {\n\t\t/**\n   * @param source\n   * @returns\n   * @memberOf emmet.cssParser\n   */\n\t\tlex: function lex(source) {\n\t\t\twalker.init(source);\n\t\t\ttokens = [];\n\t\t\twhile (walker.ch !== false) {\n\t\t\t\ttokenize();\n\t\t\t}\n\t\t\treturn tokens;\n\t\t},\n\n\t\t/**\n   * Tokenizes CSS source\n   * @param {String} source\n   * @returns {Array}\n   */\n\t\tparse: function parse(source) {\n\t\t\t// transform tokens\n\t\t\tvar pos = 0;\n\t\t\treturn _.map(this.lex(source), function (token) {\n\t\t\t\tif (token.type == 'line') {\n\t\t\t\t\ttoken.value = getNewline(source, pos);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\ttype: token.type,\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tend: pos += token.value.length\n\t\t\t\t};\n\t\t\t});\n\t\t},\n\n\t\ttoSource: function toSource(toks) {\n\t\t\tvar i = 0,\n\t\t\t    max = toks.length,\n\t\t\t    t,\n\t\t\t    src = '';\n\t\t\tfor (; i < max; i += 1) {\n\t\t\t\tt = toks[i];\n\t\t\t\tif (t.type === 'line') {\n\t\t\t\t\tsrc += '\\n';\n\t\t\t\t} else {\n\t\t\t\t\tsrc += t.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn src;\n\t\t}\n\t};\n}); /**\n    * HTML tokenizer by Marijn Haverbeke\n    * http://codemirror.net/\n    * @constructor\n    * @memberOf __xmlParseDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('xmlParser', function (require, _) {\n\tvar Kludges = {\n\t\tautoSelfClosers: {},\n\t\timplicitlyClosed: {},\n\t\tcontextGrabbers: {},\n\t\tdoNotIndent: {},\n\t\tallowUnquoted: true,\n\t\tallowMissing: true\n\t};\n\n\t// Return variables for tokenizers\n\tvar tagName = null,\n\t    type = null;\n\n\tfunction inText(stream, state) {\n\t\tfunction chain(parser) {\n\t\t\tstate.tokenize = parser;\n\t\t\treturn parser(stream, state);\n\t\t}\n\n\t\tvar ch = stream.next();\n\t\tif (ch == \"<\") {\n\t\t\tif (stream.eat(\"!\")) {\n\t\t\t\tif (stream.eat(\"[\")) {\n\t\t\t\t\tif (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));else return null;\n\t\t\t\t} else if (stream.match(\"--\")) return chain(inBlock(\"comment\", \"-->\"));else if (stream.match(\"DOCTYPE\", true, true)) {\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\t\treturn chain(doctype(1));\n\t\t\t\t} else return null;\n\t\t\t} else if (stream.eat(\"?\")) {\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\n\t\t\t\treturn \"meta\";\n\t\t\t} else {\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t\t\t\tstream.eatSpace();\n\t\t\t\ttagName = \"\";\n\t\t\t\tvar c;\n\t\t\t\twhile (c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)) {\n\t\t\t\t\ttagName += c;\n\t\t\t\t}state.tokenize = inTag;\n\t\t\t\treturn \"tag\";\n\t\t\t}\n\t\t} else if (ch == \"&\") {\n\t\t\tvar ok;\n\t\t\tif (stream.eat(\"#\")) {\n\t\t\t\tif (stream.eat(\"x\")) {\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t\t\t\t} else {\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t\t\t}\n\t\t\treturn ok ? \"atom\" : \"error\";\n\t\t} else {\n\t\t\tstream.eatWhile(/[^&<]/);\n\t\t\treturn \"text\";\n\t\t}\n\t}\n\n\tfunction inTag(stream, state) {\n\t\tvar ch = stream.next();\n\t\tif (ch == \">\" || ch == \"/\" && stream.eat(\">\")) {\n\t\t\tstate.tokenize = inText;\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t\t\treturn \"tag\";\n\t\t} else if (ch == \"=\") {\n\t\t\ttype = \"equals\";\n\t\t\treturn null;\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\n\t\t\tstate.tokenize = inAttribute(ch);\n\t\t\treturn state.tokenize(stream, state);\n\t\t} else {\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\n\t\t\treturn \"word\";\n\t\t}\n\t}\n\n\tfunction inAttribute(quote) {\n\t\treturn function (stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.next() == quote) {\n\t\t\t\t\tstate.tokenize = inTag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"string\";\n\t\t};\n\t}\n\n\tfunction inBlock(style, terminator) {\n\t\treturn function (stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.match(terminator)) {\n\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t\treturn style;\n\t\t};\n\t}\n\n\tfunction doctype(depth) {\n\t\treturn function (stream, state) {\n\t\t\tvar ch;\n\t\t\twhile ((ch = stream.next()) != null) {\n\t\t\t\tif (ch == \"<\") {\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\n\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t} else if (ch == \">\") {\n\t\t\t\t\tif (depth == 1) {\n\t\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\n\t\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"meta\";\n\t\t};\n\t}\n\n\tvar curState = null,\n\t    setStyle;\n\tfunction pass() {\n\t\tfor (var i = arguments.length - 1; i >= 0; i--) {\n\t\t\tcurState.cc.push(arguments[i]);\n\t\t}\n\t}\n\n\tfunction cont() {\n\t\tpass.apply(null, arguments);\n\t\treturn true;\n\t}\n\n\tfunction pushContext(tagName, startOfLine) {\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || curState.context && curState.context.noIndent;\n\t\tcurState.context = {\n\t\t\tprev: curState.context,\n\t\t\ttagName: tagName,\n\t\t\tindent: curState.indented,\n\t\t\tstartOfLine: startOfLine,\n\t\t\tnoIndent: noIndent\n\t\t};\n\t}\n\n\tfunction popContext() {\n\t\tif (curState.context) curState.context = curState.context.prev;\n\t}\n\n\tfunction element(type) {\n\t\tif (type == \"openTag\") {\n\t\t\tcurState.tagName = tagName;\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\n\t\t} else if (type == \"closeTag\") {\n\t\t\tvar err = false;\n\t\t\tif (curState.context) {\n\t\t\t\tif (curState.context.tagName != tagName) {\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\n\t\t\t\t\t\tpopContext();\n\t\t\t\t\t}\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = true;\n\t\t\t}\n\n\t\t\tif (err) setStyle = \"error\";\n\t\t\treturn cont(endclosetag(err));\n\t\t}\n\t\treturn cont();\n\t}\n\n\tfunction endtag(startOfLine) {\n\t\treturn function (type) {\n\t\t\tif (type == \"selfcloseTag\" || type == \"endTag\" && Kludges.autoSelfClosers.hasOwnProperty(curState.tagName.toLowerCase())) {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\tpushContext(curState.tagName, startOfLine);\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\treturn cont();\n\t\t};\n\t}\n\n\tfunction endclosetag(err) {\n\t\treturn function (type) {\n\t\t\tif (err) setStyle = \"error\";\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tpopContext();\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(arguments.callee);\n\t\t};\n\t}\n\n\tfunction maybePopContext(nextTagName) {\n\t\tvar parentTagName;\n\t\twhile (true) {\n\t\t\tif (!curState.context) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) || !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpopContext();\n\t\t}\n\t}\n\n\tfunction attributes(type) {\n\t\tif (type == \"word\") {\n\t\t\tsetStyle = \"attribute\";\n\t\t\treturn cont(attribute, attributes);\n\t\t}\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\") return pass();\n\t\tsetStyle = \"error\";\n\t\treturn cont(attributes);\n\t}\n\n\tfunction attribute(type) {\n\t\tif (type == \"equals\") return cont(attvalue, attributes);\n\t\tif (!Kludges.allowMissing) setStyle = \"error\";\n\t\treturn type == \"endTag\" || type == \"selfcloseTag\" ? pass() : cont();\n\t}\n\n\tfunction attvalue(type) {\n\t\tif (type == \"string\") return cont(attvaluemaybe);\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\n\t\t\tsetStyle = \"string\";\n\t\t\treturn cont();\n\t\t}\n\t\tsetStyle = \"error\";\n\t\treturn type == \"endTag\" || type == \"selfCloseTag\" ? pass() : cont();\n\t}\n\n\tfunction attvaluemaybe(type) {\n\t\tif (type == \"string\") return cont(attvaluemaybe);else return pass();\n\t}\n\n\tfunction startState() {\n\t\treturn {\n\t\t\ttokenize: inText,\n\t\t\tcc: [],\n\t\t\tindented: 0,\n\t\t\tstartOfLine: true,\n\t\t\ttagName: null,\n\t\t\tcontext: null\n\t\t};\n\t}\n\n\tfunction token(stream, state) {\n\t\tif (stream.sol()) {\n\t\t\tstate.startOfLine = true;\n\t\t\tstate.indented = 0;\n\t\t}\n\n\t\tif (stream.eatSpace()) return null;\n\n\t\tsetStyle = type = tagName = null;\n\t\tvar style = state.tokenize(stream, state);\n\t\tstate.type = type;\n\t\tif ((style || type) && style != \"comment\") {\n\t\t\tcurState = state;\n\t\t\twhile (true) {\n\t\t\t\tvar comb = state.cc.pop() || element;\n\t\t\t\tif (comb(type || style)) break;\n\t\t\t}\n\t\t}\n\t\tstate.startOfLine = false;\n\t\treturn setStyle || style;\n\t}\n\n\treturn {\n\t\t/**\n   * @memberOf emmet.xmlParser\n   * @returns\n   */\n\t\tparse: function parse(data, offset) {\n\t\t\toffset = offset || 0;\n\t\t\tvar state = startState();\n\t\t\tvar stream = require('stringStream').create(data);\n\t\t\tvar tokens = [];\n\t\t\twhile (!stream.eol()) {\n\t\t\t\ttokens.push({\n\t\t\t\t\ttype: token(stream, state),\n\t\t\t\t\tstart: stream.start + offset,\n\t\t\t\t\tend: stream.pos + offset\n\t\t\t\t});\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\n\t\t\treturn tokens;\n\t\t}\n\t};\n});\n/*!\n * string_score.js: String Scoring Algorithm 0.1.10 \n *\n * http://joshaven.com/string_score\n * https://github.com/joshaven/string_score\n *\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\n * MIT license: http://www.opensource.org/licenses/mit-license.php\n *\n * Date: Tue Mar 1 2011\n*/\n\n/**\n * Scores a string against another string.\n *  'Hello World'.score('he');     //=> 0.5931818181818181\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\n */\nemmet.define('string-score', function (require, _) {\n\treturn {\n\t\tscore: function score(string, abbreviation, fuzziness) {\n\t\t\t// If the string is equal to the abbreviation, perfect match.\n\t\t\tif (string == abbreviation) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t//if it's not a perfect match and is empty return 0\n\t\t\tif (abbreviation == \"\") {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar total_character_score = 0,\n\t\t\t    abbreviation_length = abbreviation.length,\n\t\t\t    string_length = string.length,\n\t\t\t    start_of_string_bonus,\n\t\t\t    abbreviation_score,\n\t\t\t    fuzzies = 1,\n\t\t\t    final_score;\n\n\t\t\t// Walk through abbreviation and add up scores.\n\t\t\tfor (var i = 0, character_score /* = 0*/\n\t\t\t, index_in_string /* = 0*/\n\t\t\t, c /* = ''*/\n\t\t\t, index_c_lowercase /* = 0*/\n\t\t\t, index_c_uppercase /* = 0*/\n\t\t\t, min_index /* = 0*/; i < abbreviation_length; ++i) {\n\n\t\t\t\t// Find the first case-insensitive match of a character.\n\t\t\t\tc = abbreviation.charAt(i);\n\n\t\t\t\tindex_c_lowercase = string.indexOf(c.toLowerCase());\n\t\t\t\tindex_c_uppercase = string.indexOf(c.toUpperCase());\n\t\t\t\tmin_index = Math.min(index_c_lowercase, index_c_uppercase);\n\t\t\t\tindex_in_string = min_index > -1 ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\n\n\t\t\t\tif (index_in_string === -1) {\n\t\t\t\t\tif (fuzziness) {\n\t\t\t\t\t\tfuzzies += 1 - fuzziness;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcharacter_score = 0.1;\n\t\t\t\t}\n\n\t\t\t\t// Set base score for matching 'c'.\n\n\t\t\t\t// Same case bonus.\n\t\t\t\tif (string[index_in_string] === c) {\n\t\t\t\t\tcharacter_score += 0.1;\n\t\t\t\t}\n\n\t\t\t\t// Consecutive letter & start-of-string Bonus\n\t\t\t\tif (index_in_string === 0) {\n\t\t\t\t\t// Increase the score when matching first character of the remainder of the string\n\t\t\t\t\tcharacter_score += 0.6;\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\t// If match is the first character of the string\n\t\t\t\t\t\t// & the first character of abbreviation, add a\n\t\t\t\t\t\t// start-of-string match bonus.\n\t\t\t\t\t\tstart_of_string_bonus = 1; //true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Acronym Bonus\n\t\t\t\t\t// Weighing Logic: Typing the first character of an acronym is as if you\n\t\t\t\t\t// preceded it with two perfect character matches.\n\t\t\t\t\tif (string.charAt(index_in_string - 1) === ' ') {\n\t\t\t\t\t\tcharacter_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Left trim the already matched part of the string\n\t\t\t\t// (forces sequential matching).\n\t\t\t\tstring = string.substring(index_in_string + 1, string_length);\n\n\t\t\t\ttotal_character_score += character_score;\n\t\t\t} // end of for loop\n\n\t\t\t// Uncomment to weigh smaller words higher.\n\t\t\t// return total_character_score / string_length;\n\n\t\t\tabbreviation_score = total_character_score / abbreviation_length;\n\t\t\t//percentage_of_matched_string = abbreviation_length / string_length;\n\t\t\t//word_score = abbreviation_score * percentage_of_matched_string;\n\n\t\t\t// Reduce penalty for longer strings.\n\t\t\t//final_score = (word_score + abbreviation_score) / 2;\n\t\t\tfinal_score = (abbreviation_score * (abbreviation_length / string_length) + abbreviation_score) / 2;\n\n\t\t\tfinal_score = final_score / fuzzies;\n\n\t\t\tif (start_of_string_bonus && final_score + 0.15 < 1) {\n\t\t\t\tfinal_score += 0.15;\n\t\t\t}\n\n\t\t\treturn final_score;\n\t\t}\n\t};\n}); /**\n    * Utility module for Emmet\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('utils', function (require, _) {\n\t/** \n  * Special token used as a placeholder for caret positions inside \n  * generated output \n  */\n\tvar caretPlaceholder = '${0}';\n\n\t/**\n  * A simple string builder, optimized for faster text concatenation\n  * @param {String} value Initial value\n  */\n\tfunction StringBuilder(value) {\n\t\tthis._data = [];\n\t\tthis.length = 0;\n\n\t\tif (value) this.append(value);\n\t}\n\n\tStringBuilder.prototype = {\n\t\t/**\n   * Append string\n   * @param {String} text\n   */\n\t\tappend: function append(text) {\n\t\t\tthis._data.push(text);\n\t\t\tthis.length += text.length;\n\t\t},\n\n\t\t/**\n   * @returns {String}\n   */\n\t\ttoString: function toString() {\n\t\t\treturn this._data.join('');\n\t\t},\n\n\t\t/**\n   * @returns {String}\n   */\n\t\tvalueOf: function valueOf() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\n\treturn {\n\t\t/** @memberOf utils */\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\n\n\t\t/**\n   * Test if passed string ends with XHTML tag. This method is used for testing\n   * '>' character: it belongs to tag or it's a part of abbreviation? \n   * @param {String} str\n   * @return {Boolean}\n   */\n\t\tendsWithTag: function endsWithTag(str) {\n\t\t\treturn this.reTag.test(str);\n\t\t},\n\n\t\t/**\n   * Check if passed symbol is a number\n   * @param {String} ch\n   * @returns {Boolean}\n   */\n\t\tisNumeric: function isNumeric(ch) {\n\t\t\tif (typeof ch == 'string') ch = ch.charCodeAt(0);\n\n\t\t\treturn ch && ch > 47 && ch < 58;\n\t\t},\n\n\t\t/**\n   * Trim whitespace from string\n   * @param {String} text\n   * @return {String}\n   */\n\t\ttrim: function trim(text) {\n\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\n\t\t},\n\n\t\t/**\n   * Returns newline character\n   * @returns {String}\n   */\n\t\tgetNewline: function getNewline() {\n\t\t\tvar res = require('resources');\n\t\t\tif (!res) {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\n\t\t\tvar nl = res.getVariable('newline');\n\t\t\treturn _.isString(nl) ? nl : '\\n';\n\t\t},\n\n\t\t/**\n   * Sets new newline character that will be used in output\n   * @param {String} str\n   */\n\t\tsetNewline: function setNewline(str) {\n\t\t\tvar res = require('resources');\n\t\t\tres.setVariable('newline', str);\n\t\t\tres.setVariable('nl', str);\n\t\t},\n\n\t\t/**\n   * Split text into lines. Set <code>remove_empty</code> to true to filter\n   * empty lines\n   * @param {String} text Text to split\n   * @param {Boolean} removeEmpty Remove empty lines from result\n   * @return {Array}\n   */\n\t\tsplitByLines: function splitByLines(text, removeEmpty) {\n\t\t\t// IE fails to split string by regexp, \n\t\t\t// need to normalize newlines first\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\n\t\t\tvar nl = this.getNewline();\n\t\t\tvar lines = (text || '').replace(/\\r\\n/g, '\\n').replace(/\\n\\r/g, '\\n').replace(/\\r/g, '\\n').replace(/\\n/g, nl).split(nl);\n\n\t\t\tif (removeEmpty) {\n\t\t\t\tlines = _.filter(lines, function (line) {\n\t\t\t\t\treturn line.length && !!this.trim(line);\n\t\t\t\t}, this);\n\t\t\t}\n\n\t\t\treturn lines;\n\t\t},\n\n\t\t/**\n   * Normalizes newline character: replaces newlines in <code>text</code> \n   * with newline defined in preferences\n   * @param {String} text\n   * @returns {String}\n   */\n\t\tnormalizeNewline: function normalizeNewline(text) {\n\t\t\treturn this.splitByLines(text).join(this.getNewline());\n\t\t},\n\n\t\t/**\n   * Repeats string <code>howMany</code> times\n   * @param {String} str\n   * @param {Number} how_many\n   * @return {String}\n   */\n\t\trepeatString: function repeatString(str, howMany) {\n\t\t\tvar result = [];\n\n\t\t\tfor (var i = 0; i < howMany; i++) {\n\t\t\t\tresult.push(str);\n\t\t\t}return result.join('');\n\t\t},\n\n\t\t/**\n   * Returns list of paddings that should be used to align passed string\n   * @param {Array} strings\n   * @returns {Array}\n   */\n\t\tgetStringsPads: function getStringsPads(strings) {\n\t\t\tvar lengths = _.map(strings, function (s) {\n\t\t\t\treturn _.isString(s) ? s.length : +s;\n\t\t\t});\n\n\t\t\tvar max = _.max(lengths);\n\t\t\treturn _.map(lengths, function (l) {\n\t\t\t\tvar pad = max - l;\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n   * Indents text with padding\n   * @param {String} text Text to indent\n   * @param {String} pad Padding size (number) or padding itself (string)\n   * @return {String}\n   */\n\t\tpadString: function padString(text, pad) {\n\t\t\tvar padStr = _.isNumber(pad) ? this.repeatString(require('resources').getVariable('indentation') || '\\t', pad) : pad;\n\n\t\t\tvar result = [];\n\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tvar nl = this.getNewline();\n\n\t\t\tresult.push(lines[0]);\n\t\t\tfor (var j = 1; j < lines.length; j++) {\n\t\t\t\tresult.push(nl + padStr + lines[j]);\n\t\t\t}return result.join('');\n\t\t},\n\n\t\t/**\n   * Pad string with zeroes\n   * @param {String} str String to pad\n   * @param {Number} pad Desired string length\n   * @return {String}\n   */\n\t\tzeroPadString: function zeroPadString(str, pad) {\n\t\t\tvar padding = '';\n\t\t\tvar il = str.length;\n\n\t\t\twhile (pad > il++) {\n\t\t\t\tpadding += '0';\n\t\t\t}return padding + str;\n\t\t},\n\n\t\t/**\n   * Removes padding at the beginning of each text's line\n   * @param {String} text\n   * @param {String} pad\n   */\n\t\tunindentString: function unindentString(text, pad) {\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\tif (lines[i].search(pad) == 0) lines[i] = lines[i].substr(pad.length);\n\t\t\t}\n\n\t\t\treturn lines.join(this.getNewline());\n\t\t},\n\n\t\t/**\n   * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\n   * will be replaced in 'item$count', but not in 'item\\$count'.\n   * @param {String} str Original string\n   * @param {String} symbol Symbol to replace\n   * @param {String} replace Symbol replacement. Might be a function that \n   * returns new value\n   * @return {String}\n   */\n\t\treplaceUnescapedSymbol: function replaceUnescapedSymbol(str, symbol, replace) {\n\t\t\tvar i = 0;\n\t\t\tvar il = str.length;\n\t\t\tvar sl = symbol.length;\n\t\t\tvar matchCount = 0;\n\n\t\t\twhile (i < il) {\n\t\t\t\tif (str.charAt(i) == '\\\\') {\n\t\t\t\t\t// escaped symbol, skip next character\n\t\t\t\t\ti += sl + 1;\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\n\t\t\t\t\t// have match\n\t\t\t\t\tvar curSl = sl;\n\t\t\t\t\tmatchCount++;\n\t\t\t\t\tvar newValue = replace;\n\t\t\t\t\tif (_.isFunction(replace)) {\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\n\t\t\t\t\t\tif (replaceData) {\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\n\t\t\t\t\t\t\tnewValue = replaceData[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newValue === false) {\n\t\t\t\t\t\t// skip replacement\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\n\t\t\t\t\t// adjust indexes\n\t\t\t\t\til = str.length;\n\t\t\t\t\ti += newValue.length;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn str;\n\t\t},\n\n\t\t/**\n   * Replace variables like ${var} in string\n   * @param {String} str\n   * @param {Object} vars Variable set (defaults to variables defined in \n   * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\n   * @return {String}\n   */\n\t\treplaceVariables: function replaceVariables(str, vars) {\n\t\t\tvars = vars || {};\n\t\t\tvar resolver = _.isFunction(vars) ? vars : function (str, p1) {\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\n\t\t\t};\n\n\t\t\tvar res = require('resources');\n\t\t\treturn require('tabStops').processText(str, {\n\t\t\t\tvariable: function variable(data) {\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\n\t\t\t\t\tif (newValue === null) {\n\t\t\t\t\t\t// try to find variable in resources\n\t\t\t\t\t\tnewValue = res.getVariable(data.name);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newValue === null || _.isUndefined(newValue))\n\t\t\t\t\t\t// nothing found, return token itself\n\t\t\t\t\t\tnewValue = data.token;\n\t\t\t\t\treturn newValue;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Replaces '$' character in string assuming it might be escaped with '\\'\n   * @param {String} str String where character should be replaced\n   * @param {String} value New value\n   * @return {String}\n   */\n\t\treplaceCounter: function replaceCounter(str, value, total) {\n\t\t\tvar symbol = '$';\n\t\t\t// in case we received strings from Java, convert the to native strings\n\t\t\tstr = String(str);\n\t\t\tvalue = String(value);\n\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\n\t\t\t\tvalue = +value;\n\t\t\t}\n\n\t\t\tvar that = this;\n\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function (str, symbol, pos, matchNum) {\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1))) {\n\t\t\t\t\t// it's a variable, skip it\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// replace sequense of $ symbols with padded number  \n\t\t\t\tvar j = pos + 1;\n\t\t\t\twhile (str.charAt(j) == '$' && str.charAt(j + 1) != '{') {\n\t\t\t\t\tj++;\n\t\t\t\t}var pad = j - pos;\n\n\t\t\t\t// get counter base\n\t\t\t\tvar base = 0,\n\t\t\t\t    decrement = false,\n\t\t\t\t    m;\n\t\t\t\tif (m = str.substr(j).match(/^@(\\-?)(\\d*)/)) {\n\t\t\t\t\tj += m[0].length;\n\n\t\t\t\t\tif (m[1]) {\n\t\t\t\t\t\tdecrement = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbase = parseInt(m[2] || 1) - 1;\n\t\t\t\t}\n\n\t\t\t\tif (decrement && total && _.isNumber(value)) {\n\t\t\t\t\tvalue = total - value + 1;\n\t\t\t\t}\n\n\t\t\t\tvalue += base;\n\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Check if string matches against <code>reTag</code> regexp. This \n   * function may be used to test if provided string contains HTML tags\n   * @param {String} str\n   * @returns {Boolean}\n   */\n\t\tmatchesTag: function matchesTag(str) {\n\t\t\treturn this.reTag.test(str || '');\n\t\t},\n\n\t\t/**\n   * Escapes special characters used in Emmet, like '$', '|', etc.\n   * Use this method before passing to actions like \"Wrap with Abbreviation\"\n   * to make sure that existing special characters won't be altered\n   * @param {String} text\n   * @return {String}\n   */\n\t\tescapeText: function escapeText(text) {\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\n\t\t},\n\n\t\t/**\n   * Unescapes special characters used in Emmet, like '$', '|', etc.\n   * @param {String} text\n   * @return {String}\n   */\n\t\tunescapeText: function unescapeText(text) {\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\n\t\t},\n\n\t\t/**\n   * Returns caret placeholder\n   * @returns {String}\n   */\n\t\tgetCaretPlaceholder: function getCaretPlaceholder() {\n\t\t\treturn _.isFunction(caretPlaceholder) ? caretPlaceholder.apply(this, arguments) : caretPlaceholder;\n\t\t},\n\n\t\t/**\n   * Sets new representation for carets in generated output\n   * @param {String} value New caret placeholder. Might be a \n   * <code>Function</code>\n   */\n\t\tsetCaretPlaceholder: function setCaretPlaceholder(value) {\n\t\t\tcaretPlaceholder = value;\n\t\t},\n\n\t\t/**\n   * Returns line padding\n   * @param {String} line\n   * @return {String}\n   */\n\t\tgetLinePadding: function getLinePadding(line) {\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\n\t\t},\n\n\t\t/**\n   * Helper function that returns padding of line of <code>pos</code>\n   * position in <code>content</code>\n   * @param {String} content\n   * @param {Number} pos\n   * @returns {String}\n   */\n\t\tgetLinePaddingFromPosition: function getLinePaddingFromPosition(content, pos) {\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\n\t\t},\n\n\t\t/**\n   * Escape special regexp chars in string, making it usable for creating dynamic\n   * regular expressions\n   * @param {String} str\n   * @return {String}\n   */\n\t\tescapeForRegexp: function escapeForRegexp(str) {\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\n\t\t\treturn str.replace(specials, \"\\\\$&\");\n\t\t},\n\n\t\t/**\n   * Make decimal number look good: convert it to fixed precision end remove\n   * traling zeroes \n   * @param {Number} num\n   * @param {Number} fracion Fraction numbers (default is 2)\n   * @return {String}\n   */\n\t\tprettifyNumber: function prettifyNumber(num, fraction) {\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\n\t\t},\n\n\t\t/**\n   * A simple mutable string shim, optimized for faster text concatenation\n   * @param {String} value Initial value\n   * @returns {StringBuilder}\n   */\n\t\tstringBuilder: function stringBuilder(value) {\n\t\t\treturn new StringBuilder(value);\n\t\t},\n\n\t\t/**\n   * Replace substring of <code>str</code> with <code>value</code>\n   * @param {String} str String where to replace substring\n   * @param {String} value New substring value\n   * @param {Number} start Start index of substring to replace. May also\n   * be a <code>Range</code> object: in this case, the <code>end</code>\n   * argument is not required\n   * @param {Number} end End index of substring to replace. If ommited, \n   * <code>start</code> argument is used\n   */\n\t\treplaceSubstring: function replaceSubstring(str, value, start, end) {\n\t\t\tif (_.isObject(start) && 'end' in start) {\n\t\t\t\tend = start.end;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\n\t\t\tif (_.isString(end)) end = start + end.length;\n\n\t\t\tif (_.isUndefined(end)) end = start;\n\n\t\t\tif (start < 0 || start > str.length) return str;\n\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\n\t\t},\n\n\t\t/**\n   * Narrows down text range, adjusting selection to non-space characters\n   * @param {String} text\n   * @param {Number} start Starting range in <code>text</code> where \n   * slection should be adjusted. Can also be any object that is accepted\n   * by <code>Range</code> class\n   * @return {Range}\n   */\n\t\tnarrowToNonSpace: function narrowToNonSpace(text, start, end) {\n\t\t\tvar range = require('range').create(start, end);\n\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\n\t\t\t// narrow down selection until first non-space character\n\t\t\twhile (range.start < range.end) {\n\t\t\t\tif (!reSpace.test(text.charAt(range.start))) break;\n\n\t\t\t\trange.start++;\n\t\t\t}\n\n\t\t\twhile (range.end > range.start) {\n\t\t\t\trange.end--;\n\t\t\t\tif (!reSpace.test(text.charAt(range.end))) {\n\t\t\t\t\trange.end++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn range;\n\t\t},\n\n\t\t/**\n   * Find start and end index of text line for <code>from</code> index\n   * @param {String} text \n   * @param {Number} from\n   */\n\t\tfindNewlineBounds: function findNewlineBounds(text, from) {\n\t\t\tvar len = text.length,\n\t\t\t    start = 0,\n\t\t\t    end = len - 1;\n\n\t\t\t// search left\n\t\t\tfor (var i = from - 1; i > 0; i--) {\n\t\t\t\tvar ch = text.charAt(i);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// search right\n\t\t\tfor (var j = from; j < len; j++) {\n\t\t\t\tvar ch = text.charAt(j);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tend = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn require('range').create(start, end - start);\n\t\t},\n\n\t\t/**\n   * Deep merge of two or more objects. Taken from jQuery.extend()\n   */\n\t\tdeepMerge: function deepMerge() {\n\t\t\tvar options,\n\t\t\t    name,\n\t\t\t    src,\n\t\t\t    copy,\n\t\t\t    copyIsArray,\n\t\t\t    clone,\n\t\t\t    target = arguments[0] || {},\n\t\t\t    i = 1,\n\t\t\t    length = arguments.length;\n\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\t\tif (!_.isObject(target) && !_.isFunction(target)) {\n\t\t\t\ttarget = {};\n\t\t\t}\n\n\t\t\tfor (; i < length; i++) {\n\t\t\t\t// Only deal with non-null/undefined values\n\t\t\t\tif ((options = arguments[i]) != null) {\n\t\t\t\t\t// Extend the base object\n\t\t\t\t\tfor (name in options) {\n\t\t\t\t\t\tsrc = target[name];\n\t\t\t\t\t\tcopy = options[name];\n\n\t\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\t\tif (target === copy) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif (copy && (_.isObject(copy) || (copyIsArray = _.isArray(copy)))) {\n\t\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && _.isArray(src) ? src : [];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && _.isObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[name] = this.deepMerge(clone, copy);\n\n\t\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if (copy !== undefined) {\n\t\t\t\t\t\t\ttarget[name] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the modified object\n\t\t\treturn target;\n\t\t}\n\t};\n});\n/**\n * Helper module to work with ranges\n * @constructor\n * @memberOf __rangeDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('range', function (require, _) {\n\tfunction _cmp(a, b, op) {\n\t\tswitch (op) {\n\t\t\tcase 'eq':\n\t\t\tcase '==':\n\t\t\t\treturn a === b;\n\t\t\tcase 'lt':\n\t\t\tcase '<':\n\t\t\t\treturn a < b;\n\t\t\tcase 'lte':\n\t\t\tcase '<=':\n\t\t\t\treturn a <= b;\n\t\t\tcase 'gt':\n\t\t\tcase '>':\n\t\t\t\treturn a > b;\n\t\t\tcase 'gte':\n\t\t\tcase '>=':\n\t\t\t\treturn a >= b;\n\t\t}\n\t}\n\n\t/**\n  * @type Range\n  * @constructor\n  * @param {Object} start\n  * @param {Number} len\n  */\n\tfunction Range(start, len) {\n\t\tif (_.isObject(start) && 'start' in start) {\n\t\t\t// create range from object stub\n\t\t\tthis.start = Math.min(start.start, start.end);\n\t\t\tthis.end = Math.max(start.start, start.end);\n\t\t} else if (_.isArray(start)) {\n\t\t\tthis.start = start[0];\n\t\t\tthis.end = start[1];\n\t\t} else {\n\t\t\tlen = _.isString(len) ? len.length : +len;\n\t\t\tthis.start = start;\n\t\t\tthis.end = start + len;\n\t\t}\n\t}\n\n\tRange.prototype = {\n\t\tlength: function length() {\n\t\t\treturn Math.abs(this.end - this.start);\n\t\t},\n\n\t\t/**\n   * Returns <code>true</code> if passed range is equals to current one\n   * @param {Range} range\n   * @returns {Boolean}\n   */\n\t\tequal: function equal(range) {\n\t\t\treturn this.cmp(range, 'eq', 'eq');\n\t\t\t//\t\t\treturn this.start === range.start && this.end === range.end;\n\t\t},\n\n\t\t/**\n   * Shifts indexes position with passed <code>delat</code>\n   * @param {Number} delta\n   * @returns {Range} range itself\n   */\n\t\tshift: function shift(delta) {\n\t\t\tthis.start += delta;\n\t\t\tthis.end += delta;\n\t\t\treturn this;\n\t\t},\n\n\t\t/**\n   * Check if two ranges are overlapped\n   * @param {Range} range\n   * @returns {Boolean}\n   */\n\t\toverlap: function overlap(range) {\n\t\t\treturn range.start <= this.end && range.end >= this.start;\n\t\t},\n\n\t\t/**\n   * Finds intersection of two ranges\n   * @param {Range} range\n   * @returns {Range} <code>null</code> if ranges does not overlap\n   */\n\t\tintersection: function intersection(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.max(range.start, this.start);\n\t\t\t\tvar end = Math.min(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n   * Returns the union of the thow ranges.\n   * @param {Range} range\n   * @returns {Range} <code>null</code> if ranges are not overlapped\n   */\n\t\tunion: function union(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.min(range.start, this.start);\n\t\t\t\tvar end = Math.max(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n   * Returns a Boolean value that indicates whether a specified position \n   * is in a given range.\n   * @param {Number} loc\n   */\n\t\tinside: function inside(loc) {\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\n\t\t\t//\t\t\treturn this.start <= loc && this.end > loc;\n\t\t},\n\n\t\t/**\n   * Returns a Boolean value that indicates whether a specified position \n   * is in a given range, but not equals bounds.\n   * @param {Number} loc\n   */\n\t\tcontains: function contains(loc) {\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\n\t\t},\n\n\t\t/**\n   * Check if current range completely includes specified one\n   * @param {Range} r\n   * @returns {Boolean} \n   */\n\t\tinclude: function include(r) {\n\t\t\treturn this.cmp(loc, 'lte', 'gte');\n\t\t\t//\t\t\treturn this.start <= r.start && this.end >= r.end;\n\t\t},\n\n\t\t/**\n   * Low-level comparision method\n   * @param {Number} loc\n   * @param {String} left Left comparison operator\n   * @param {String} right Right comaprison operator\n   */\n\t\tcmp: function cmp(loc, left, right) {\n\t\t\tvar a, b;\n\t\t\tif (loc instanceof Range) {\n\t\t\t\ta = loc.start;\n\t\t\t\tb = loc.end;\n\t\t\t} else {\n\t\t\t\ta = b = loc;\n\t\t\t}\n\n\t\t\treturn _cmp(this.start, a, left || '<=') && _cmp(this.end, b, right || '>');\n\t\t},\n\n\t\t/**\n   * Returns substring of specified <code>str</code> for current range\n   * @param {String} str\n   * @returns {String}\n   */\n\t\tsubstring: function substring(str) {\n\t\t\treturn this.length() > 0 ? str.substring(this.start, this.end) : '';\n\t\t},\n\n\t\t/**\n   * Creates copy of current range\n   * @returns {Range}\n   */\n\t\tclone: function clone() {\n\t\t\treturn new Range(this.start, this.length());\n\t\t},\n\n\t\t/**\n   * @returns {Array}\n   */\n\t\ttoArray: function toArray() {\n\t\t\treturn [this.start, this.end];\n\t\t},\n\n\t\ttoString: function toString() {\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\n\t\t}\n\t};\n\n\treturn {\n\t\t/**\n   * Creates new range object instance\n   * @param {Object} start Range start or array with 'start' and 'end'\n   * as two first indexes or object with 'start' and 'end' properties\n   * @param {Number} len Range length or string to produce range from\n   * @returns {Range}\n   * @memberOf emmet.range\n   */\n\t\tcreate: function create(start, len) {\n\t\t\tif (_.isUndefined(start) || start === null) return null;\n\n\t\t\tif (start instanceof Range) return start;\n\n\t\t\tif (_.isObject(start) && 'start' in start && 'end' in start) {\n\t\t\t\tlen = start.end - start.start;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\n\t\t\treturn new Range(start, len);\n\t\t},\n\n\t\t/**\n   * <code>Range</code> object factory, the same as <code>this.create()</code>\n   * but last argument represents end of range, not length\n   * @returns {Range}\n   */\n\t\tcreate2: function create2(start, end) {\n\t\t\tif (_.isNumber(start) && _.isNumber(end)) {\n\t\t\t\tend -= start;\n\t\t\t}\n\n\t\t\treturn this.create(start, end);\n\t\t}\n\t};\n}); /**\n    * Utility module that provides ordered storage of function handlers. \n    * Many Emmet modules' functionality can be extended/overridden by custom\n    * function. This modules provides unified storage of handler functions, their \n    * management and execution\n    * \n    * @constructor\n    * @memberOf __handlerListDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('handlerList', function (require, _) {\n\t/**\n  * @type HandlerList\n  * @constructor\n  */\n\tfunction HandlerList() {\n\t\tthis._list = [];\n\t}\n\n\tHandlerList.prototype = {\n\t\t/**\n   * Adds function handler\n   * @param {Function} fn Handler\n   * @param {Object} options Handler options. Possible values are:<br><br>\n   * <b>order</b> : (<code>Number</code>)  order in handler list. Handlers\n   * with higher order value will be executed earlier.\n   */\n\t\tadd: function add(fn, options) {\n\t\t\tthis._list.push(_.extend({ order: 0 }, options || {}, { fn: fn }));\n\t\t},\n\n\t\t/**\n   * Removes handler from list\n   * @param {Function} fn\n   */\n\t\tremove: function remove(fn) {\n\t\t\tthis._list = _.without(this._list, _.find(this._list, function (item) {\n\t\t\t\treturn item.fn === fn;\n\t\t\t}));\n\t\t},\n\n\t\t/**\n   * Returns ordered list of handlers. By default, handlers \n   * with the same <code>order</code> option returned in reverse order, \n   * i.e. the latter function was added into the handlers list, the higher \n   * it will be in the returned array \n   * @returns {Array}\n   */\n\t\tlist: function list() {\n\t\t\treturn _.sortBy(this._list, 'order').reverse();\n\t\t},\n\n\t\t/**\n   * Returns ordered list of handler functions\n   * @returns {Array}\n   */\n\t\tlistFn: function listFn() {\n\t\t\treturn _.pluck(this.list(), 'fn');\n\t\t},\n\n\t\t/**\n   * Executes handler functions in their designated order. If function\n   * returns <code>skipVal</code>, meaning that function was unable to \n   * handle passed <code>args</code>, the next function will be executed\n   * and so on.\n   * @param {Object} skipValue If function returns this value, execute \n   * next handler.\n   * @param {Array} args Arguments to pass to handler function\n   * @returns {Boolean} Whether any of registered handlers performed\n   * successfully  \n   */\n\t\texec: function exec(skipValue, args) {\n\t\t\targs = args || [];\n\t\t\tvar result = null;\n\t\t\t_.find(this.list(), function (h) {\n\t\t\t\tresult = h.fn.apply(h, args);\n\t\t\t\tif (result !== skipValue) return true;\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\t};\n\n\treturn {\n\t\t/**\n   * Factory method that produces <code>HandlerList</code> instance\n   * @returns {HandlerList}\n   * @memberOf handlerList\n   */\n\t\tcreate: function create() {\n\t\t\treturn new HandlerList();\n\t\t}\n\t};\n}); /**\n    * Helper class for convenient token iteration\n    */\nemmet.define('tokenIterator', function (require, _) {\n\t/**\n  * @type TokenIterator\n  * @param {Array} tokens\n  * @type TokenIterator\n  * @constructor\n  */\n\tfunction TokenIterator(tokens) {\n\t\t/** @type Array */\n\t\tthis.tokens = tokens;\n\t\tthis._position = 0;\n\t\tthis.reset();\n\t}\n\n\tTokenIterator.prototype = {\n\t\tnext: function next() {\n\t\t\tif (this.hasNext()) {\n\t\t\t\tvar token = this.tokens[++this._i];\n\t\t\t\tthis._position = token.start;\n\t\t\t\treturn token;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\tcurrent: function current() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\n\t\tposition: function position() {\n\t\t\treturn this._position;\n\t\t},\n\n\t\thasNext: function hasNext() {\n\t\t\treturn this._i < this._il - 1;\n\t\t},\n\n\t\treset: function reset() {\n\t\t\tthis._i = -1;\n\t\t\tthis._il = this.tokens.length;\n\t\t},\n\n\t\titem: function item() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\n\t\titemNext: function itemNext() {\n\t\t\treturn this.tokens[this._i + 1];\n\t\t},\n\n\t\titemPrev: function itemPrev() {\n\t\t\treturn this.tokens[this._i - 1];\n\t\t},\n\n\t\tnextUntil: function nextUntil(type, callback) {\n\t\t\tvar token;\n\t\t\tvar test = _.isString(type) ? function (t) {\n\t\t\t\treturn t.type == type;\n\t\t\t} : type;\n\n\t\t\twhile (token = this.next()) {\n\t\t\t\tif (callback) callback.call(this, token);\n\t\t\t\tif (test.call(this, token)) break;\n\t\t\t}\n\t\t}\n\t};\n\n\treturn {\n\t\tcreate: function create(tokens) {\n\t\t\treturn new TokenIterator(tokens);\n\t\t}\n\t};\n}); /**\n    * A trimmed version of CodeMirror's StringStream module for string parsing\n    */\nemmet.define('stringStream', function (require, _) {\n\t/**\n  * @type StringStream\n  * @constructor\n  * @param {String} string\n  */\n\tfunction StringStream(string) {\n\t\tthis.pos = this.start = 0;\n\t\tthis.string = string;\n\t}\n\n\tStringStream.prototype = {\n\t\t/**\n   * Returns true only if the stream is at the end of the line.\n   * @returns {Boolean}\n   */\n\t\teol: function eol() {\n\t\t\treturn this.pos >= this.string.length;\n\t\t},\n\n\t\t/**\n   * Returns true only if the stream is at the start of the line\n   * @returns {Boolean}\n   */\n\t\tsol: function sol() {\n\t\t\treturn this.pos == 0;\n\t\t},\n\n\t\t/**\n   * Returns the next character in the stream without advancing it. \n   * Will return <code>undefined</code> at the end of the line.\n   * @returns {String}\n   */\n\t\tpeek: function peek() {\n\t\t\treturn this.string.charAt(this.pos);\n\t\t},\n\n\t\t/**\n   * Returns the next character in the stream and advances it.\n   * Also returns <code>undefined</code> when no more characters are available.\n   * @returns {String}\n   */\n\t\tnext: function next() {\n\t\t\tif (this.pos < this.string.length) return this.string.charAt(this.pos++);\n\t\t},\n\n\t\t/**\n   * match can be a character, a regular expression, or a function that\n   * takes a character and returns a boolean. If the next character in the\n   * stream 'matches' the given argument, it is consumed and returned.\n   * Otherwise, undefined is returned.\n   * @param {Object} match\n   * @returns {String}\n   */\n\t\teat: function eat(match) {\n\t\t\tvar ch = this.string.charAt(this.pos),\n\t\t\t    ok;\n\t\t\tif (typeof match == \"string\") ok = ch == match;else ok = ch && (match.test ? match.test(ch) : match(ch));\n\n\t\t\tif (ok) {\n\t\t\t\t++this.pos;\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Repeatedly calls <code>eat</code> with the given argument, until it\n   * fails. Returns <code>true</code> if any characters were eaten.\n   * @param {Object} match\n   * @returns {Boolean}\n   */\n\t\teatWhile: function eatWhile(match) {\n\t\t\tvar start = this.pos;\n\t\t\twhile (this.eat(match)) {}\n\t\t\treturn this.pos > start;\n\t\t},\n\n\t\t/**\n   * Shortcut for <code>eatWhile</code> when matching white-space.\n   * @returns {Boolean}\n   */\n\t\teatSpace: function eatSpace() {\n\t\t\tvar start = this.pos;\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n\t\t\t\t++this.pos;\n\t\t\t}return this.pos > start;\n\t\t},\n\n\t\t/**\n   * Moves the position to the end of the line.\n   */\n\t\tskipToEnd: function skipToEnd() {\n\t\t\tthis.pos = this.string.length;\n\t\t},\n\n\t\t/**\n   * Skips to the next occurrence of the given character, if found on the\n   * current line (doesn't advance the stream if the character does not\n   * occur on the line). Returns true if the character was found.\n   * @param {String} ch\n   * @returns {Boolean}\n   */\n\t\tskipTo: function skipTo(ch) {\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.pos = found;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Skips to <code>close</code> character which is pair to <code>open</code>\n   * character, considering possible pair nesting. This function is used\n   * to consume pair of characters, like opening and closing braces\n   * @param {String} open\n   * @param {String} close\n   * @returns {Boolean} Returns <code>true</code> if pair was successfully\n   * consumed\n   */\n\t\tskipToPair: function skipToPair(open, close) {\n\t\t\tvar braceCount = 0,\n\t\t\t    ch;\n\t\t\tvar pos = this.pos,\n\t\t\t    len = this.string.length;\n\t\t\twhile (pos < len) {\n\t\t\t\tch = this.string.charAt(pos++);\n\t\t\t\tif (ch == open) {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == close) {\n\t\t\t\t\tbraceCount--;\n\t\t\t\t\tif (braceCount < 1) {\n\t\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n   * Backs up the stream n characters. Backing it up further than the\n   * start of the current token will cause things to break, so be careful.\n   * @param {Number} n\n   */\n\t\tbackUp: function backUp(n) {\n\t\t\tthis.pos -= n;\n\t\t},\n\n\t\t/**\n   * Act like a multi-character <code>eat</code>if <code>consume</code> is true or\n   * not givenor a look-ahead that doesn't update the stream positionif\n   * it is false. <code>pattern</code> can be either a string or a\n   * regular expression starting with ^. When it is a string,\n   * <code>caseInsensitive</code> can be set to true to make the match\n   * case-insensitive. When successfully matching a regular expression,\n   * the returned value will be the array returned by <code>match</code>,\n   * in case you need to extract matched groups.\n   * \n   * @param {RegExp} pattern\n   * @param {Boolean} consume\n   * @param {Boolean} caseInsensitive\n   * @returns\n   */\n\t\tmatch: function match(pattern, consume, caseInsensitive) {\n\t\t\tif (typeof pattern == \"string\") {\n\t\t\t\tvar cased = caseInsensitive ? function (str) {\n\t\t\t\t\treturn str.toLowerCase();\n\t\t\t\t} : function (str) {\n\t\t\t\t\treturn str;\n\t\t\t\t};\n\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n\t\t\t\t\tif (consume !== false) this.pos += pattern.length;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\n\t\t\t\tif (match && consume !== false) this.pos += match[0].length;\n\t\t\t\treturn match;\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Get the string between the start of the current token and the \n   * current stream position.\n   * @returns {String}\n   */\n\t\tcurrent: function current() {\n\t\t\treturn this.string.slice(this.start, this.pos);\n\t\t}\n\t};\n\n\treturn {\n\t\tcreate: function create(string) {\n\t\t\treturn new StringStream(string);\n\t\t}\n\t};\n}); /**\n    * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\n    * Contains convenient method to get access for snippets with respect of \n    * inheritance. Also provides ability to store data in different vocabularies\n    * ('system' and 'user') for fast and safe resource update\n    * @author Sergey Chikuyonok (serge.che@gmail.com)\n    * @link http://chikuyonok.ru\n    * \n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('resources', function (require, _) {\n\tvar VOC_SYSTEM = 'system';\n\tvar VOC_USER = 'user';\n\n\tvar cache = {};\n\n\t/** Regular expression for XML tag matching */\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\n\n\tvar systemSettings = {};\n\tvar userSettings = {};\n\n\t/** @type HandlerList List of registered abbreviation resolvers */\n\tvar resolvers = require('handlerList').create();\n\n\t/**\n  * Normalizes caret plceholder in passed text: replaces | character with\n  * default caret placeholder\n  * @param {String} text\n  * @returns {String}\n  */\n\tfunction normalizeCaretPlaceholder(text) {\n\t\tvar utils = require('utils');\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\n\t}\n\n\tfunction parseItem(name, value, type) {\n\t\tvalue = normalizeCaretPlaceholder(value);\n\n\t\tif (type == 'snippets') {\n\t\t\treturn require('elements').create('snippet', value);\n\t\t}\n\n\t\tif (type == 'abbreviations') {\n\t\t\treturn parseAbbreviation(name, value);\n\t\t}\n\t}\n\n\t/**\n  * Parses single abbreviation\n  * @param {String} key Abbreviation name\n  * @param {String} value Abbreviation value\n  * @return {Object}\n  */\n\tfunction parseAbbreviation(key, value) {\n\t\tkey = require('utils').trim(key);\n\t\tvar elements = require('elements');\n\t\tvar m;\n\t\tif (m = reTag.exec(value)) {\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\n\t\t} else {\n\t\t\t// assume it's reference to another abbreviation\n\t\t\treturn elements.create('reference', value);\n\t\t}\n\t}\n\n\t/**\n  * Normalizes snippet key name for better fuzzy search\n  * @param {String} str\n  * @returns {String}\n  */\n\tfunction normalizeName(str) {\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\n\t}\n\n\treturn {\n\t\t/**\n   * Sets new unparsed data for specified settings vocabulary\n   * @param {Object} data\n   * @param {String} type Vocabulary type ('system' or 'user')\n   * @memberOf resources\n   */\n\t\tsetVocabulary: function setVocabulary(data, type) {\n\t\t\tcache = {};\n\t\t\tif (type == VOC_SYSTEM) systemSettings = data;else userSettings = data;\n\t\t},\n\n\t\t/**\n   * Returns resource vocabulary by its name\n   * @param {String} name Vocabulary name ('system' or 'user')\n   * @return {Object}\n   */\n\t\tgetVocabulary: function getVocabulary(name) {\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\n\t\t},\n\n\t\t/**\n   * Returns resource (abbreviation, snippet, etc.) matched for passed \n   * abbreviation\n   * @param {AbbreviationNode} node\n   * @param {String} syntax\n   * @returns {Object}\n   */\n\t\tgetMatchedResource: function getMatchedResource(node, syntax) {\n\t\t\treturn resolvers.exec(null, _.toArray(arguments)) || this.findSnippet(syntax, node.name());\n\t\t},\n\n\t\t/**\n   * Returns variable value\n   * @return {String}\n   */\n\t\tgetVariable: function getVariable(name) {\n\t\t\treturn (this.getSection('variables') || {})[name];\n\t\t},\n\n\t\t/**\n   * Store runtime variable in user storage\n   * @param {String} name Variable name\n   * @param {String} value Variable value\n   */\n\t\tsetVariable: function setVariable(name, value) {\n\t\t\tvar voc = this.getVocabulary('user') || {};\n\t\t\tif (!('variables' in voc)) voc.variables = {};\n\n\t\t\tvoc.variables[name] = value;\n\t\t\tthis.setVocabulary(voc, 'user');\n\t\t},\n\n\t\t/**\n   * Check if there are resources for specified syntax\n   * @param {String} syntax\n   * @return {Boolean}\n   */\n\t\thasSyntax: function hasSyntax(syntax) {\n\t\t\treturn syntax in this.getVocabulary(VOC_USER) || syntax in this.getVocabulary(VOC_SYSTEM);\n\t\t},\n\n\t\t/**\n   * Registers new abbreviation resolver.\n   * @param {Function} fn Abbreviation resolver which will receive \n   * abbreviation as first argument and should return parsed abbreviation\n   * object if abbreviation has handled successfully, <code>null</code>\n   * otherwise\n   * @param {Object} options Options list as described in \n   * {@link HandlerList#add()} method\n   */\n\t\taddResolver: function addResolver(fn, options) {\n\t\t\tresolvers.add(fn, options);\n\t\t},\n\n\t\tremoveResolver: function removeResolver(fn) {\n\t\t\tresolvers.remove(fn);\n\t\t},\n\n\t\t/**\n   * Returns actual section data, merged from both\n   * system and user data\n   * @param {String} name Section name (syntax)\n   * @param {String} ...args Subsections\n   * @returns\n   */\n\t\tgetSection: function getSection(name) {\n\t\t\tif (!name) return null;\n\n\t\t\tif (!(name in cache)) {\n\t\t\t\tcache[name] = require('utils').deepMerge({}, systemSettings[name], userSettings[name]);\n\t\t\t}\n\n\t\t\tvar data = cache[name],\n\t\t\t    subsections = _.rest(arguments),\n\t\t\t    key;\n\t\t\twhile (data && (key = subsections.shift())) {\n\t\t\t\tif (key in data) {\n\t\t\t\t\tdata = data[key];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t},\n\n\t\t/**\n   * Recursively searches for a item inside top level sections (syntaxes)\n   * with respect of `extends` attribute\n   * @param {String} topSection Top section name (syntax)\n   * @param {String} subsection Inner section name\n   * @returns {Object}\n   */\n\t\tfindItem: function findItem(topSection, subsection) {\n\t\t\tvar data = this.getSection(topSection);\n\t\t\twhile (data) {\n\t\t\t\tif (subsection in data) return data[subsection];\n\n\t\t\t\tdata = this.getSection(data['extends']);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Recursively searches for a snippet definition inside syntax section.\n   * Definition is searched inside `snippets` and `abbreviations` \n   * subsections  \n   * @param {String} syntax Top-level section name (syntax)\n   * @param {String} name Snippet name\n   * @returns {Object}\n   */\n\t\tfindSnippet: function findSnippet(syntax, name, memo) {\n\t\t\tif (!syntax || !name) return null;\n\n\t\t\tmemo = memo || [];\n\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-')) names.push(name.replace(/\\-/g, ':'));\n\n\t\t\tvar data = this.getSection(syntax),\n\t\t\t    matchedItem = null;\n\t\t\t_.find(['snippets', 'abbreviations'], function (sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn _.find(names, function (n) {\n\t\t\t\t\t\tif (data[n]) return matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\n\t\t\treturn matchedItem;\n\t\t},\n\n\t\t/**\n   * Performs fuzzy search of snippet definition\n   * @param {String} syntax Top-level section name (syntax)\n   * @param {String} name Snippet name\n   * @returns\n   */\n\t\tfuzzyFindSnippet: function fuzzyFindSnippet(syntax, name, minScore) {\n\t\t\tminScore = minScore || 0.3;\n\n\t\t\tvar payload = this.getAllSnippets(syntax);\n\t\t\tvar sc = require('string-score');\n\n\t\t\tname = normalizeName(name);\n\t\t\tvar scores = _.map(payload, function (value, key) {\n\t\t\t\treturn {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tscore: sc.score(value.nk, name, 0.1)\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tvar result = _.last(_.sortBy(scores, 'score'));\n\t\t\tif (result && result.score >= minScore) {\n\t\t\t\tvar k = result.key;\n\t\t\t\treturn payload[k].parsedValue;\n\t\t\t\t//\t\t\t\treturn parseItem(k, payload[k].value, payload[k].type);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Returns plain dictionary of all available abbreviations and snippets\n   * for specified syntax with respect of inheritance\n   * @param {String} syntax\n   * @returns {Object}\n   */\n\t\tgetAllSnippets: function getAllSnippets(syntax) {\n\t\t\tvar cacheKey = 'all-' + syntax;\n\t\t\tif (!cache[cacheKey]) {\n\t\t\t\tvar stack = [],\n\t\t\t\t    sectionKey = syntax;\n\t\t\t\tvar memo = [];\n\n\t\t\t\tdo {\n\t\t\t\t\tvar section = this.getSection(sectionKey);\n\t\t\t\t\tif (!section) break;\n\n\t\t\t\t\t_.each(['snippets', 'abbreviations'], function (sectionName) {\n\t\t\t\t\t\tvar stackItem = {};\n\t\t\t\t\t\t_.each(section[sectionName] || null, function (v, k) {\n\t\t\t\t\t\t\tstackItem[k] = {\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\n\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\n\t\t\t\t\t\t\t\ttype: sectionName\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tstack.push(stackItem);\n\t\t\t\t\t});\n\n\t\t\t\t\tmemo.push(sectionKey);\n\t\t\t\t\tsectionKey = section['extends'];\n\t\t\t\t} while (sectionKey && !_.include(memo, sectionKey));\n\n\t\t\t\tcache[cacheKey] = _.extend.apply(_, stack.reverse());\n\t\t\t}\n\n\t\t\treturn cache[cacheKey];\n\t\t}\n\t};\n}); /**\n    * Module describes and performs Emmet actions. The actions themselves are\n    * defined in <i>actions</i> folder\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('actions', function (require, _, zc) {\n\tvar actions = {};\n\n\t/**\n  * Humanizes action name, makes it more readable for people\n  * @param {String} name Action name (like 'expand_abbreviation')\n  * @return Humanized name (like 'Expand Abbreviation')\n  */\n\tfunction humanizeActionName(name) {\n\t\treturn require('utils').trim(name.charAt(0).toUpperCase() + name.substring(1).replace(/_[a-z]/g, function (str) {\n\t\t\treturn ' ' + str.charAt(1).toUpperCase();\n\t\t}));\n\t}\n\n\treturn {\n\t\t/**\n   * Registers new action\n   * @param {String} name Action name\n   * @param {Function} fn Action function\n   * @param {Object} options Custom action options:<br>\n   * <b>label</b> : (<code>String</code>)  Human-readable action name. \n   * May contain '/' symbols as submenu separators<br>\n   * <b>hidden</b> : (<code>Boolean</code>)  Indicates whether action\n   * should be displayed in menu (<code>getMenu()</code> method)\n   * \n   * @memberOf actions\n   */\n\t\tadd: function add(name, fn, options) {\n\t\t\tname = name.toLowerCase();\n\t\t\toptions = options || {};\n\t\t\tif (!options.label) {\n\t\t\t\toptions.label = humanizeActionName(name);\n\t\t\t}\n\n\t\t\tactions[name] = {\n\t\t\t\tname: name,\n\t\t\t\tfn: fn,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t},\n\n\t\t/**\n   * Returns action object\n   * @param {String} name Action name\n   * @returns {Object}\n   */\n\t\tget: function get(name) {\n\t\t\treturn actions[name.toLowerCase()];\n\t\t},\n\n\t\t/**\n   * Runs Emmet action. For list of available actions and their\n   * arguments see <i>actions</i> folder.\n   * @param {String} name Action name \n   * @param {Array} args Additional arguments. It may be array of arguments\n   * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\n   * @returns {Boolean} Status of performed operation, <code>true</code>\n   * means action was performed successfully.\n   * @example\n   * emmet.require('actions').run('expand_abbreviation', editor);  \n   * emmet.require('actions').run('wrap_with_abbreviation', [editor, 'div']);  \n   */\n\t\trun: function run(name, args) {\n\t\t\tif (!_.isArray(args)) {\n\t\t\t\targs = _.rest(arguments);\n\t\t\t}\n\n\t\t\tvar action = this.get(name);\n\t\t\tif (action) {\n\t\t\t\treturn action.fn.apply(emmet, args);\n\t\t\t} else {\n\t\t\t\temmet.log('Action \"%s\" is not defined', name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Returns all registered actions as object\n   * @returns {Object}\n   */\n\t\tgetAll: function getAll() {\n\t\t\treturn actions;\n\t\t},\n\n\t\t/**\n   * Returns all registered actions as array\n   * @returns {Array}\n   */\n\t\tgetList: function getList() {\n\t\t\treturn _.values(this.getAll());\n\t\t},\n\n\t\t/**\n   * Returns actions list as structured menu. If action has <i>label</i>,\n   * it will be splitted by '/' symbol into submenus (for example: \n   * CSS/Reflect Value) and grouped with other items\n   * @param {Array} skipActions List of action identifiers that should be \n   * skipped from menu\n   * @returns {Array}\n   */\n\t\tgetMenu: function getMenu(skipActions) {\n\t\t\tvar result = [];\n\t\t\tskipActions = skipActions || [];\n\t\t\t_.each(this.getList(), function (action) {\n\t\t\t\tif (action.options.hidden || _.include(skipActions, action.name)) return;\n\n\t\t\t\tvar actionName = humanizeActionName(action.name);\n\t\t\t\tvar ctx = result;\n\t\t\t\tif (action.options.label) {\n\t\t\t\t\tvar parts = action.options.label.split('/');\n\t\t\t\t\tactionName = parts.pop();\n\n\t\t\t\t\t// create submenus, if needed\n\t\t\t\t\tvar menuName, submenu;\n\t\t\t\t\twhile (menuName = parts.shift()) {\n\t\t\t\t\t\tsubmenu = _.find(ctx, function (item) {\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (!submenu) {\n\t\t\t\t\t\t\tsubmenu = {\n\t\t\t\t\t\t\t\tname: menuName,\n\t\t\t\t\t\t\t\ttype: 'submenu',\n\t\t\t\t\t\t\t\titems: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tctx.push(submenu);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx = submenu.items;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tctx.push({\n\t\t\t\t\ttype: 'action',\n\t\t\t\t\tname: action.name,\n\t\t\t\t\tlabel: actionName\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n   * Returns action name associated with menu item title\n   * @param {String} title\n   * @returns {String}\n   */\n\t\tgetActionNameForMenuTitle: function getActionNameForMenuTitle(title, menu) {\n\t\t\tvar item = null;\n\t\t\t_.find(menu || this.getMenu(), function (val) {\n\t\t\t\tif (val.type == 'action') {\n\t\t\t\t\tif (val.label == title || val.name == title) {\n\t\t\t\t\t\treturn item = val.name;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn item = this.getActionNameForMenuTitle(title, val.items);\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\treturn item || null;\n\t\t}\n\t};\n}); /**\n    * Output profile module.\n    * Profile defines how XHTML output data should look like\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('profile', function (require, _) {\n\tvar profiles = {};\n\n\tvar defaultProfile = {\n\t\ttag_case: 'asis',\n\t\tattr_case: 'asis',\n\t\tattr_quotes: 'double',\n\n\t\t// each tag on new line\n\t\ttag_nl: 'decide',\n\n\t\t// with tag_nl === true, defines if leaf node (e.g. node with no children)\n\t\t// should have formatted line breaks\n\t\ttag_nl_leaf: false,\n\n\t\tplace_cursor: true,\n\n\t\t// indent tags\n\t\tindent: true,\n\n\t\t// how many inline elements should be to force line break \n\t\t// (set to 0 to disable)\n\t\tinline_break: 3,\n\n\t\t// use self-closing style for writing empty elements, e.g. <br /> or <br>\n\t\tself_closing_tag: 'xhtml',\n\n\t\t// Profile-level output filters, re-defines syntax filters \n\t\tfilters: '',\n\n\t\t// Additional filters applied to abbreviation.\n\t\t// Unlike \"filters\", this preference doesn't override default filters\n\t\t// but add the instead every time given profile is chosen\n\t\textraFilters: ''\n\t};\n\n\t/**\n  * @constructor\n  * @type OutputProfile\n  * @param {Object} options\n  */\n\tfunction OutputProfile(options) {\n\t\t_.extend(this, defaultProfile, options);\n\t}\n\n\tOutputProfile.prototype = {\n\t\t/**\n   * Transforms tag name case depending on current profile settings\n   * @param {String} name String to transform\n   * @returns {String}\n   */\n\t\ttagName: function tagName(name) {\n\t\t\treturn stringCase(name, this.tag_case);\n\t\t},\n\n\t\t/**\n   * Transforms attribute name case depending on current profile settings \n   * @param {String} name String to transform\n   * @returns {String}\n   */\n\t\tattributeName: function attributeName(name) {\n\t\t\treturn stringCase(name, this.attr_case);\n\t\t},\n\n\t\t/**\n   * Returns quote character for current profile\n   * @returns {String}\n   */\n\t\tattributeQuote: function attributeQuote() {\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\n\t\t},\n\n\t\t/**\n   * Returns self-closing tag symbol for current profile\n   * @param {String} param\n   * @returns {String}\n   */\n\t\tselfClosing: function selfClosing(param) {\n\t\t\tif (this.self_closing_tag == 'xhtml') return ' /';\n\n\t\t\tif (this.self_closing_tag === true) return '/';\n\n\t\t\treturn '';\n\t\t},\n\n\t\t/**\n   * Returns cursor token based on current profile settings\n   * @returns {String}\n   */\n\t\tcursor: function cursor() {\n\t\t\treturn this.place_cursor ? require('utils').getCaretPlaceholder() : '';\n\t\t}\n\t};\n\n\t/**\n  * Helper function that converts string case depending on \n  * <code>caseValue</code> \n  * @param {String} str String to transform\n  * @param {String} caseValue Case value: can be <i>lower</i>, \n  * <i>upper</i> and <i>leave</i>\n  * @returns {String}\n  */\n\tfunction stringCase(str, caseValue) {\n\t\tswitch (String(caseValue || '').toLowerCase()) {\n\t\t\tcase 'lower':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'upper':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\n\t\treturn str;\n\t}\n\n\t/**\n  * Creates new output profile\n  * @param {String} name Profile name\n  * @param {Object} options Profile options\n  */\n\tfunction createProfile(name, options) {\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\n\t}\n\n\tfunction createDefaultProfiles() {\n\t\tcreateProfile('xhtml');\n\t\tcreateProfile('html', { self_closing_tag: false });\n\t\tcreateProfile('xml', { self_closing_tag: true, tag_nl: true });\n\t\tcreateProfile('plain', { tag_nl: false, indent: false, place_cursor: false });\n\t\tcreateProfile('line', { tag_nl: false, indent: false, extraFilters: 's' });\n\t}\n\n\tcreateDefaultProfiles();\n\n\treturn {\n\t\t/**\n   * Creates new output profile and adds it into internal dictionary\n   * @param {String} name Profile name\n   * @param {Object} options Profile options\n   * @memberOf emmet.profile\n   * @returns {Object} New profile\n   */\n\t\tcreate: function create(name, options) {\n\t\t\tif (arguments.length == 2) return createProfile(name, options);else\n\t\t\t\t// create profile object only\n\t\t\t\treturn new OutputProfile(_.defaults(name || {}, defaultProfile));\n\t\t},\n\n\t\t/**\n   * Returns profile by its name. If profile wasn't found, returns\n   * 'plain' profile\n   * @param {String} name Profile name. Might be profile itself\n   * @param {String} syntax. Optional. Current editor syntax. If defined,\n   * profile is searched in resources first, then in predefined profiles\n   * @returns {Object}\n   */\n\t\tget: function get(name, syntax) {\n\t\t\tif (!name && syntax) {\n\t\t\t\t// search in user resources first\n\t\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\t\tif (profile) {\n\t\t\t\t\tname = profile;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!name) {\n\t\t\t\treturn profiles.plain;\n\t\t\t}\n\n\t\t\tif (name instanceof OutputProfile) {\n\t\t\t\treturn name;\n\t\t\t}\n\n\t\t\tif (_.isString(name) && name.toLowerCase() in profiles) {\n\t\t\t\treturn profiles[name.toLowerCase()];\n\t\t\t}\n\n\t\t\treturn this.create(name);\n\t\t},\n\n\t\t/**\n   * Deletes profile with specified name\n   * @param {String} name Profile name\n   */\n\t\tremove: function remove(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\tif (name in profiles) delete profiles[name];\n\t\t},\n\n\t\t/**\n   * Resets all user-defined profiles\n   */\n\t\treset: function reset() {\n\t\t\tprofiles = {};\n\t\t\tcreateDefaultProfiles();\n\t\t},\n\n\t\t/**\n   * Helper function that converts string case depending on \n   * <code>caseValue</code> \n   * @param {String} str String to transform\n   * @param {String} caseValue Case value: can be <i>lower</i>, \n   * <i>upper</i> and <i>leave</i>\n   * @returns {String}\n   */\n\t\tstringCase: stringCase\n\t};\n}); /**\n    * Utility module used to prepare text for pasting into back-end editor\n    * @param {Function} require\n    * @param {Underscore} _\n    * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n    */\nemmet.define('editorUtils', function (require, _) {\n\treturn {\n\t\t/**\n   * Check if cursor is placed inside XHTML tag\n   * @param {String} html Contents of the document\n   * @param {Number} caretPos Current caret position inside tag\n   * @return {Boolean}\n   */\n\t\tisInsideTag: function isInsideTag(html, caretPos) {\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\n\n\t\t\t// search left to find opening brace\n\t\t\tvar pos = caretPos;\n\t\t\twhile (pos > -1) {\n\t\t\t\tif (html.charAt(pos) == '<') break;\n\t\t\t\tpos--;\n\t\t\t}\n\n\t\t\tif (pos != -1) {\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length) return true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n   * Sanitizes incoming editor data and provides default values for\n   * output-specific info\n   * @param {IEmmetEditor} editor\n   * @param {String} syntax\n   * @param {String} profile\n   */\n\t\toutputInfo: function outputInfo(editor, syntax, profile) {\n\t\t\t// most of this code makes sense for Java/Rhino environment\n\t\t\t// because string that comes from Java are not actually JS string\n\t\t\t// but Java String object so the have to be explicitly converted\n\t\t\t// to native string\n\t\t\tprofile = profile || editor.getProfileName();\n\t\t\treturn {\n\t\t\t\t/** @memberOf outputInfo */\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\n\t\t\t\tprofile: profile || null,\n\t\t\t\tcontent: String(editor.getContent())\n\t\t\t};\n\t\t},\n\n\t\t/**\n   * Unindent content, thus preparing text for tag wrapping\n   * @param {IEmmetEditor} editor Editor instance\n   * @param {String} text\n   * @return {String}\n   */\n\t\tunindent: function unindent(editor, text) {\n\t\t\treturn require('utils').unindentString(text, this.getCurrentLinePadding(editor));\n\t\t},\n\n\t\t/**\n   * Returns padding of current editor's line\n   * @param {IEmmetEditor} Editor instance\n   * @return {String}\n   */\n\t\tgetCurrentLinePadding: function getCurrentLinePadding(editor) {\n\t\t\treturn require('utils').getLinePadding(editor.getCurrentLine());\n\t\t}\n\t};\n});\n/**\n * Utility methods for Emmet actions\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('actionUtils', function (require, _) {\n\treturn {\n\t\tmimeTypes: {\n\t\t\t'gif': 'image/gif',\n\t\t\t'png': 'image/png',\n\t\t\t'jpg': 'image/jpeg',\n\t\t\t'jpeg': 'image/jpeg',\n\t\t\t'svg': 'image/svg+xml',\n\t\t\t'html': 'text/html',\n\t\t\t'htm': 'text/html'\n\t\t},\n\n\t\t/**\n   * Extracts abbreviations from text stream, starting from the end\n   * @param {String} str\n   * @return {String} Abbreviation or empty string\n   * @memberOf emmet.actionUtils\n   */\n\t\textractAbbreviation: function extractAbbreviation(str) {\n\t\t\tvar curOffset = str.length;\n\t\t\tvar startIndex = -1;\n\t\t\tvar groupCount = 0;\n\t\t\tvar braceCount = 0;\n\t\t\tvar textCount = 0;\n\n\t\t\tvar utils = require('utils');\n\t\t\tvar parser = require('abbreviationParser');\n\n\t\t\twhile (true) {\n\t\t\t\tcurOffset--;\n\t\t\t\tif (curOffset < 0) {\n\t\t\t\t\t// moved to the beginning of the line\n\t\t\t\t\tstartIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar ch = str.charAt(curOffset);\n\n\t\t\t\tif (ch == ']') {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == '[') {\n\t\t\t\t\tif (!braceCount) {\n\t\t\t\t\t\t// unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbraceCount--;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\ttextCount++;\n\t\t\t\t} else if (ch == '{') {\n\t\t\t\t\tif (!textCount) {\n\t\t\t\t\t\t// unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttextCount--;\n\t\t\t\t} else if (ch == ')') {\n\t\t\t\t\tgroupCount++;\n\t\t\t\t} else if (ch == '(') {\n\t\t\t\t\tif (!groupCount) {\n\t\t\t\t\t\t// unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgroupCount--;\n\t\t\t\t} else {\n\t\t\t\t\tif (braceCount || textCount)\n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\t\t\t\tcontinue;else if (!parser.isAllowedChar(ch) || ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1))) {\n\t\t\t\t\t\t// found stop symbol\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount)\n\t\t\t\t// found something, remove some invalid symbols from the \n\t\t\t\t// beginning and return abbreviation\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');else return '';\n\t\t},\n\n\t\t/**\n   * Gets image size from image byte stream.\n   * @author http://romeda.org/rePublish/\n   * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\n   * @return {Object} Object with <code>width</code> and <code>height</code> properties\n   */\n\t\tgetImageSize: function getImageSize(stream) {\n\t\t\tvar pngMagicNum = \"211PNG\\r\\n032\\n\",\n\t\t\t    jpgMagicNum = \"377330\",\n\t\t\t    gifMagicNum = \"GIF8\",\n\t\t\t    nextByte = function nextByte() {\n\t\t\t\treturn stream.charCodeAt(pos++);\n\t\t\t};\n\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\n\t\t\t\t// PNG. Easy peasy.\n\t\t\t\tvar pos = stream.indexOf('IHDR') + 4;\n\n\t\t\t\treturn { width: nextByte() << 24 | nextByte() << 16 | nextByte() << 8 | nextByte(),\n\t\t\t\t\theight: nextByte() << 24 | nextByte() << 16 | nextByte() << 8 | nextByte() };\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\n\t\t\t\tpos = 6;\n\n\t\t\t\treturn {\n\t\t\t\t\twidth: nextByte() | nextByte() << 8,\n\t\t\t\t\theight: nextByte() | nextByte() << 8\n\t\t\t\t};\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\n\t\t\t\tpos = 2;\n\n\t\t\t\tvar l = stream.length;\n\t\t\t\twhile (pos < l) {\n\t\t\t\t\tif (nextByte() != 0xFF) return;\n\n\t\t\t\t\tvar marker = nextByte();\n\t\t\t\t\tif (marker == 0xDA) break;\n\n\t\t\t\t\tvar size = nextByte() << 8 | nextByte();\n\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\treturn { height: nextByte() << 8 | nextByte(),\n\t\t\t\t\t\t\twidth: nextByte() << 8 | nextByte() };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos += size - 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Captures context XHTML element from editor under current caret position.\n   * This node can be used as a helper for abbreviation extraction\n   * @param {IEmmetEditor} editor\n   * @returns {Object}\n   */\n\t\tcaptureContext: function captureContext(editor) {\n\t\t\tvar allowedSyntaxes = { 'html': 1, 'xml': 1, 'xsl': 1 };\n\t\t\tvar syntax = String(editor.getSyntax());\n\t\t\tif (syntax in allowedSyntaxes) {\n\t\t\t\tvar content = String(editor.getContent());\n\t\t\t\tvar tag = require('htmlMatcher').find(content, editor.getCaretPos());\n\n\t\t\t\tif (tag && tag.type == 'tag') {\n\t\t\t\t\tvar startTag = tag.open;\n\t\t\t\t\tvar contextNode = {\n\t\t\t\t\t\tname: startTag.name,\n\t\t\t\t\t\tattributes: []\n\t\t\t\t\t};\n\n\t\t\t\t\t// parse attributes\n\t\t\t\t\tvar tagTree = require('xmlEditTree').parse(startTag.range.substring(content));\n\t\t\t\t\tif (tagTree) {\n\t\t\t\t\t\tcontextNode.attributes = _.map(tagTree.getAll(), function (item) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname: item.name(),\n\t\t\t\t\t\t\t\tvalue: item.value()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn contextNode;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n   * Find expression bounds in current editor at caret position. \n   * On each character a <code>fn</code> function will be called and must \n   * return <code>true</code> if current character meets requirements, \n   * <code>false</code> otherwise\n   * @param {IEmmetEditor} editor\n   * @param {Function} fn Function to test each character of expression\n   * @return {Range}\n   */\n\t\tfindExpressionBounds: function findExpressionBounds(editor, fn) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar il = content.length;\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\n\t\t\tvar exprEnd = exprStart + 1;\n\n\t\t\t// start by searching left\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) {\n\t\t\t\texprStart--;\n\t\t\t} // then search right\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) {\n\t\t\t\texprEnd++;\n\t\t\t}if (exprEnd > exprStart) {\n\t\t\t\treturn require('range').create([++exprStart, exprEnd]);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * @param {IEmmetEditor} editor\n   * @param {Object} data\n   * @returns {Boolean}\n   */\n\t\tcompoundUpdate: function compoundUpdate(editor, data) {\n\t\t\tif (data) {\n\t\t\t\tvar sel = editor.getSelectionRange();\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n   * Common syntax detection method for editors that doesnt provide any\n   * info about current syntax scope. \n   * @param {IEmmetEditor} editor Current editor\n   * @param {String} hint Any syntax hint that editor can provide \n   * for syntax detection. Default is 'html'\n   * @returns {String} \n   */\n\t\tdetectSyntax: function detectSyntax(editor, hint) {\n\t\t\tvar syntax = hint || 'html';\n\n\t\t\tif (!require('resources').hasSyntax(syntax)) {\n\t\t\t\tsyntax = 'html';\n\t\t\t}\n\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\n\t\t\t\tsyntax = 'css';\n\t\t\t}\n\n\t\t\treturn syntax;\n\t\t},\n\n\t\t/**\n   * Common method for detecting output profile\n   * @param {IEmmetEditor} editor\n   * @returns {String}\n   */\n\t\tdetectProfile: function detectProfile(editor) {\n\t\t\tvar syntax = editor.getSyntax();\n\n\t\t\t// get profile from syntax definition\n\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\tif (profile) {\n\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\tswitch (syntax) {\n\t\t\t\tcase 'xml':\n\t\t\t\tcase 'xsl':\n\t\t\t\t\treturn 'xml';\n\t\t\t\tcase 'css':\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\n\t\t\t\t\t\treturn 'line';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tvar profile = require('resources').getVariable('profile');\n\t\t\t\t\tif (!profile) {\n\t\t\t\t\t\t// no forced profile, guess from content\n\t\t\t\t\t\t// html or xhtml?\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml' : 'html';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\treturn 'xhtml';\n\t\t},\n\n\t\t/**\n   * Tries to detect if current document is XHTML one.\n   * @param {IEmmetEditor} editor\n   * @returns {Boolean}\n   */\n\t\tisXHTML: function isXHTML(editor) {\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\n\t\t},\n\n\t\t/**\n   * Check if current caret position is inside &lt;style&gt; tag\n   * @param {IEmmetEditor} editor\n   * @returns\n   */\n\t\tisStyle: function isStyle(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(content, caretPos);\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' && tag.innerRange.cmp(caretPos, 'lte', 'gte');\n\t\t},\n\n\t\t/**\n   * Check if current caret position is inside \"style\" attribute of HTML\n   * element\n   * @param {IEmmetEditor} editor\n   * @returns {Boolean}\n   */\n\t\tisInlineCSS: function isInlineCSS(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tree = require('xmlEditTree').parseFromPosition(content, caretPos, true);\n\t\t\tif (tree) {\n\t\t\t\tvar attr = tree.itemFromPosition(caretPos, true);\n\t\t\t\treturn attr && attr.name().toLowerCase() == 'style' && attr.valueRange(true).cmp(caretPos, 'lte', 'gte');\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t};\n}); /**\n    * Utility functions to work with <code>AbbreviationNode</code> as HTML element\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('abbreviationUtils', function (require, _) {\n\tvar _ref;\n\n\treturn _ref = {\n\t\t/**\n   * Check if passed abbreviation node has matched snippet resource\n   * @param {AbbreviationNode} node\n   * @returns {Boolean}\n   * @memberOf abbreviationUtils\n   */\n\t\tisSnippet: function isSnippet(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\n\t\t/**\n   * Test if passed node is unary (no closing tag)\n   * @param {AbbreviationNode} node\n   * @return {Boolean}\n   */\n\t\tisUnary: function isUnary(node) {\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar r = node.matchedResource();\n\t\t\treturn r && r.is_empty;\n\t\t},\n\n\t\t/**\n   * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\n   * @param {AbbreviationNode} node\n   * @return {Boolean}\n   */\n\t\tisInline: function isInline(node) {\n\t\t\treturn node.isTextNode() || !node.name() || require('tagName').isInlineLevel(node.name());\n\t\t},\n\n\t\t/**\n   * Test if passed node is block-level\n   * @param {AbbreviationNode} node\n   * @return {Boolean}\n   */\n\t\tisBlock: function isBlock(node) {\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\n\t\t}\n\n\t}, _defineProperty(_ref, 'isSnippet', function isSnippet(node) {\n\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t}), _defineProperty(_ref, 'hasTagsInContent', function hasTagsInContent(node) {\n\t\treturn require('utils').matchesTag(node.content);\n\t}), _defineProperty(_ref, 'hasBlockChildren', function hasBlockChildren(node) {\n\t\treturn this.hasTagsInContent(node) && this.isBlock(node) || _.any(node.children, function (child) {\n\t\t\treturn this.isBlock(child);\n\t\t}, this);\n\t}), _defineProperty(_ref, 'insertChildContent', function insertChildContent(text, childContent, options) {\n\t\toptions = _.extend({\n\t\t\tkeepVariable: true,\n\t\t\tappendIfNoChild: true\n\t\t}, options || {});\n\n\t\tvar childVariableReplaced = false;\n\t\tvar utils = require('utils');\n\t\ttext = utils.replaceVariables(text, function (variable, name, data) {\n\t\t\tvar output = variable;\n\t\t\tif (name == 'child') {\n\t\t\t\t// add correct indentation\n\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\n\t\t\t\tchildVariableReplaced = true;\n\t\t\t\tif (options.keepVariable) output += variable;\n\t\t\t}\n\n\t\t\treturn output;\n\t\t});\n\n\t\tif (!childVariableReplaced && options.appendIfNoChild) {\n\t\t\ttext += childContent;\n\t\t}\n\n\t\treturn text;\n\t}), _ref;\n}); /**\n    * @author Sergey Chikuyonok (serge.che@gmail.com)\n    * @link http://chikuyonok.ru\n    */\nemmet.define('base64', function (require, _) {\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n\treturn {\n\t\t/**\n   * Encodes data using base64 algorithm\n   * @author Tyler Akins (http://rumkin.com)\n   * @param {String} input\n   * @returns {String}\n   * @memberOf emmet.base64\n   */\n\t\tencode: function encode(input) {\n\t\t\tvar output = [];\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\n\t\t\tvar i = 0,\n\t\t\t    il = input.length,\n\t\t\t    b64 = chars;\n\n\t\t\twhile (i < il) {\n\n\t\t\t\tcdp1 = input.charCodeAt(i++);\n\t\t\t\tcdp2 = input.charCodeAt(i++);\n\t\t\t\tcdp3 = input.charCodeAt(i++);\n\n\t\t\t\tchr1 = cdp1 & 0xff;\n\t\t\t\tchr2 = cdp2 & 0xff;\n\t\t\t\tchr3 = cdp3 & 0xff;\n\n\t\t\t\tenc1 = chr1 >> 2;\n\t\t\t\tenc2 = (chr1 & 3) << 4 | chr2 >> 4;\n\t\t\t\tenc3 = (chr2 & 15) << 2 | chr3 >> 6;\n\t\t\t\tenc4 = chr3 & 63;\n\n\t\t\t\tif (isNaN(cdp2)) {\n\t\t\t\t\tenc3 = enc4 = 64;\n\t\t\t\t} else if (isNaN(cdp3)) {\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\n\t\t\t}\n\n\t\t\treturn output.join('');\n\t\t},\n\n\t\t/**\n   * Decodes string using MIME base64 algorithm\n   * \n   * @author Tyler Akins (http://rumkin.com)\n   * @param {String} data\n   * @return {String}\n   */\n\t\tdecode: function decode(data) {\n\t\t\tvar o1,\n\t\t\t    o2,\n\t\t\t    o3,\n\t\t\t    h1,\n\t\t\t    h2,\n\t\t\t    h3,\n\t\t\t    h4,\n\t\t\t    bits,\n\t\t\t    i = 0,\n\t\t\t    ac = 0,\n\t\t\t    tmpArr = [];\n\t\t\tvar b64 = chars,\n\t\t\t    il = data.length;\n\n\t\t\tif (!data) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tdata += '';\n\n\t\t\tdo {\n\t\t\t\t// unpack four hexets into three octets using index points in b64\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\n\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n\t\t\t\to1 = bits >> 16 & 0xff;\n\t\t\t\to2 = bits >> 8 & 0xff;\n\t\t\t\to3 = bits & 0xff;\n\n\t\t\t\tif (h3 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\n\t\t\t\t} else if (h4 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\n\t\t\t\t} else {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\n\t\t\t\t}\n\t\t\t} while (i < il);\n\n\t\t\treturn tmpArr.join('');\n\t\t}\n\t};\n}); /**\n    * HTML matcher: takes string and searches for HTML tag pairs for given position \n    * \n    * Unlike classic matchers, it parses content from the specified \n    * position, not from the start, so it may work even outside HTML documents\n    * (for example, inside strings of programming languages like JavaScript, Python \n    * etc.)\n    * @constructor\n    * @memberOf __htmlMatcherDefine\n    */\nemmet.define('htmlMatcher', function (require, _) {\n\t// Regular Expressions for parsing tags and attributes\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\n\n\tfunction openTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\tselfClose: !!match[3],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'open'\n\t\t};\n\t}\n\n\tfunction closeTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'close'\n\t\t};\n\t}\n\n\tfunction comment(i, match) {\n\t\treturn {\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, _.isNumber(match) ? match - i : match[0]),\n\t\t\ttype: 'comment'\n\t\t};\n\t}\n\n\t/**\n  * Creates new tag matcher session\n  * @param {String} text\n  */\n\tfunction createMatcher(_text) {\n\t\tvar memo = {},\n\t\t    m;\n\t\treturn {\n\t\t\t/**\n    * Test if given position matches opening tag\n    * @param {Number} i\n    * @returns {Object} Matched tag object\n    */\n\t\t\topen: function open(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'open' ? m : null;\n\t\t\t},\n\n\t\t\t/**\n    * Test if given position matches closing tag\n    * @param {Number} i\n    * @returns {Object} Matched tag object\n    */\n\t\t\tclose: function close(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'close' ? m : null;\n\t\t\t},\n\n\t\t\t/**\n    * Matches either opening or closing tag for given position\n    * @param i\n    * @returns\n    */\n\t\t\tmatches: function matches(i) {\n\t\t\t\tvar key = 'p' + i;\n\n\t\t\t\tif (!(key in memo)) {\n\t\t\t\t\tif (_text.charAt(i) == '<') {\n\t\t\t\t\t\tvar substr = _text.slice(i);\n\t\t\t\t\t\tif (m = substr.match(reOpenTag)) {\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\n\t\t\t\t\t\t} else if (m = substr.match(reCloseTag)) {\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// remember that given position contains no valid tag\n\t\t\t\t\t\t\tmemo[key] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn memo[key];\n\t\t\t},\n\n\t\t\t/**\n    * Returns original text\n    * @returns {String}\n    */\n\t\t\ttext: function text() {\n\t\t\t\treturn _text;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction matches(text, pos, pattern) {\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\n\t}\n\n\t/**\n  * Search for closing pair of opening tag\n  * @param {Object} open Open tag instance\n  * @param {Object} matcher Matcher instance\n  */\n\tfunction findClosingPair(open, matcher) {\n\t\tvar stack = [],\n\t\t    tag = null;\n\t\tvar text = matcher.text();\n\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\n\t\t\tif (matches(text, pos, '<!--')) {\n\t\t\t\t// skip to end of comment\n\t\t\t\tfor (var j = pos; j < len; j++) {\n\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\tpos = j + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tag = matcher.matches(pos)) {\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\n\t\t\t\t\tstack.push(tag.name);\n\t\t\t\t} else if (tag.type == 'close') {\n\t\t\t\t\tif (!stack.length) {\n\t\t\t\t\t\t// found valid pair?\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check if current closing tag matches previously opened one\n\t\t\t\t\tif (_.last(stack) == tag.name) {\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\twhile (stack.length && !found) {\n\t\t\t\t\t\t\tvar last = stack.pop();\n\t\t\t\t\t\t\tif (last == tag.name) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!stack.length && !found) {\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\t/**\n   * Main function: search for tag pair in <code>text</code> for given \n   * position\n   * @memberOf htmlMatcher\n   * @param {String} text \n   * @param {Number} pos\n   * @returns {Object}\n   */\n\t\tfind: function find(text, pos) {\n\t\t\tvar range = require('range');\n\t\t\tvar matcher = createMatcher(text);\n\t\t\tvar open = null,\n\t\t\t    close = null;\n\n\t\t\tfor (var i = pos; i >= 0; i--) {\n\t\t\t\tif (open = matcher.open(i)) {\n\t\t\t\t\t// found opening tag\n\t\t\t\t\tif (open.selfClose) {\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\n\t\t\t\t\t\t\t// inside self-closing tag, found match\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// outside self-closing tag, continue\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tclose = findClosingPair(open, matcher);\n\t\t\t\t\tif (close) {\n\t\t\t\t\t\t// found closing tag.\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\n\t\t\t\t\t\tif (r.contains(pos)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (open.range.contains(pos)) {\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\topen = null;\n\t\t\t\t} else if (matches(text, i, '-->')) {\n\t\t\t\t\t// skip back to comment start\n\t\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\t// found another comment end, do nothing\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (matches(text, i, '<!--')) {\n\t\t\t\t\t// we're inside comment, match it\n\t\t\t\t\tvar j = i + 4,\n\t\t\t\t\t    jl = text.length;\n\t\t\t\t\tfor (; j < jl; j++) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\tj += 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\topen = comment(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (open) {\n\t\t\t\tvar outerRange = null;\n\t\t\t\tvar innerRange = null;\n\n\t\t\t\tif (close) {\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\n\t\t\t\t} else {\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\n\t\t\t\t}\n\n\t\t\t\tif (open.type == 'comment') {\n\t\t\t\t\t// adjust positions of inner range for comment\n\t\t\t\t\tvar _c = outerRange.substring(text);\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\topen: open,\n\t\t\t\t\tclose: close,\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\n\t\t\t\t\tinnerRange: innerRange,\n\t\t\t\t\tinnerContent: function innerContent() {\n\t\t\t\t\t\treturn this.innerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\touterRange: outerRange,\n\t\t\t\t\touterContent: function outerContent() {\n\t\t\t\t\t\treturn this.outerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\n\t\t\t\t\tcontent: function content() {\n\t\t\t\t\t\treturn this.range.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\tsource: text\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * The same as <code>find()</code> method, but restricts matched result \n   * to <code>tag</code> type\n   * @param {String} text \n   * @param {Number} pos\n   * @returns {Object}\n   */\n\t\ttag: function tag(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n}); /**\n    * Utility module for handling tabstops tokens generated by Emmet's \n    * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\n    * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \n    * occurrences, replace them with tokens suitable for your editor of choice and \n    * return object with processed text and list of found tabstops and their ranges.\n    * For sake of portability (Objective-C/Java) the tabstops list is a plain \n    * sorted array with plain objects.\n    * \n    * Placeholders with the same are meant to be <i>linked</i> in your editor.\n    * @param {Function} require\n    * @param {Underscore} _  \n    */\nemmet.define('tabStops', function (require, _) {\n\t/**\n  * Global placeholder value, automatically incremented by \n  * <code>variablesResolver()</code> function\n  */\n\tvar startPlaceholderNum = 100;\n\n\tvar tabstopIndex = 0;\n\n\tvar defaultOptions = {\n\t\treplaceCarets: false,\n\t\tescape: function escape(ch) {\n\t\t\treturn '\\\\' + ch;\n\t\t},\n\t\ttabstop: function tabstop(data) {\n\t\t\treturn data.token;\n\t\t},\n\t\tvariable: function variable(data) {\n\t\t\treturn data.token;\n\t\t}\n\t};\n\n\t// XXX register output processor that will upgrade tabstops of parsed node\n\t// in order to prevent tabstop index conflicts\n\trequire('abbreviationParser').addOutputProcessor(function (text, node, type) {\n\t\tvar maxNum = 0;\n\t\tvar tabstops = require('tabStops');\n\t\tvar utils = require('utils');\n\n\t\tvar tsOptions = {\n\t\t\ttabstop: function tabstop(data) {\n\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\tif (group == 0) return '${0}';\n\n\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\tif (data.placeholder) {\n\t\t\t\t\t// respect nested placeholders\n\t\t\t\t\tvar ix = group + tabstopIndex;\n\t\t\t\t\tvar placeholder = tabstops.processText(data.placeholder, tsOptions);\n\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// upgrade tabstops\n\t\ttext = tabstops.processText(text, tsOptions);\n\n\t\t// resolve variables\n\t\ttext = utils.replaceVariables(text, tabstops.variablesResolver(node));\n\n\t\ttabstopIndex += maxNum + 1;\n\t\treturn text;\n\t});\n\n\treturn {\n\t\t/**\n   * Main function that looks for a tabstops in provided <code>text</code>\n   * and returns a processed version of <code>text</code> with expanded \n   * placeholders and list of tabstops found.\n   * @param {String} text Text to process\n   * @param {Object} options List of processor options:<br>\n   * \n   * <b>replaceCarets</b> : <code>Boolean</code>  replace all default\n   * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\n   * \n   * <b>escape</b> : <code>Function</code>  function that handle escaped\n   * characters (mostly '$'). By default, it returns the character itself \n   * to be displayed as is in output, but sometimes you will use \n   * <code>extract</code> method as intermediate solution for further \n   * processing and want to keep character escaped. Thus, you should override\n   * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\n   * \n   * <b>tabstop</b> : <code>Function</code>  a tabstop handler. Receives \n   * a single argument  an object describing token: its position, number \n   * group, placeholder and token itself. Should return a replacement \n   * string that will appear in final output\n   * \n   * <b>variable</b> : <code>Function</code>  variable handler. Receives \n   * a single argument  an object describing token: its position, name \n   * and original token itself. Should return a replacement \n   * string that will appear in final output\n   * \n   * @returns {Object} Object with processed <code>text</code> property\n   * and array of <code>tabstops</code> found\n   * @memberOf tabStops\n   */\n\t\textract: function extract(text, options) {\n\t\t\t// prepare defaults\n\t\t\tvar utils = require('utils');\n\t\t\tvar placeholders = { carets: '' };\n\t\t\tvar marks = [];\n\n\t\t\toptions = _.extend({}, defaultOptions, options, {\n\t\t\t\ttabstop: function tabstop(data) {\n\t\t\t\t\tvar token = data.token;\n\t\t\t\t\tvar ret = '';\n\t\t\t\t\tif (data.placeholder == 'cursor') {\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: 'carets',\n\t\t\t\t\t\t\tvalue: ''\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unify placeholder value for single group\n\t\t\t\t\t\tif ('placeholder' in data) placeholders[data.group] = data.placeholder;\n\n\t\t\t\t\t\tif (data.group in placeholders) ret = placeholders[data.group];\n\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: data.group,\n\t\t\t\t\t\t\tvalue: ret\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn token;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (options.replaceCarets) {\n\t\t\t\ttext = text.replace(new RegExp(utils.escapeForRegexp(utils.getCaretPlaceholder()), 'g'), '${0:cursor}');\n\t\t\t}\n\n\t\t\t// locate tabstops and unify group's placeholders\n\t\t\ttext = this.processText(text, options);\n\n\t\t\t// now, replace all tabstops with placeholders\n\t\t\tvar buf = utils.stringBuilder(),\n\t\t\t    lastIx = 0;\n\t\t\tvar tabStops = _.map(marks, function (mark) {\n\t\t\t\tbuf.append(text.substring(lastIx, mark.start));\n\n\t\t\t\tvar pos = buf.length;\n\t\t\t\tvar ph = placeholders[mark.group] || '';\n\n\t\t\t\tbuf.append(ph);\n\t\t\t\tlastIx = mark.end;\n\n\t\t\t\treturn {\n\t\t\t\t\tgroup: mark.group,\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tend: pos + ph.length\n\t\t\t\t};\n\t\t\t});\n\n\t\t\tbuf.append(text.substring(lastIx));\n\n\t\t\treturn {\n\t\t\t\ttext: buf.toString(),\n\t\t\t\ttabstops: _.sortBy(tabStops, 'start')\n\t\t\t};\n\t\t},\n\n\t\t/**\n   * Text processing routine. Locates escaped characters and tabstops and\n   * replaces them with values returned by handlers defined in \n   * <code>options</code>\n   * @param {String} text\n   * @param {Object} options See <code>extract</code> method options \n   * description\n   * @returns {String}\n   */\n\t\tprocessText: function processText(text, options) {\n\t\t\toptions = _.extend({}, defaultOptions, options);\n\n\t\t\tvar buf = require('utils').stringBuilder();\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(text);\n\t\t\tvar ch, m, a;\n\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\n\t\t\t\t\t// handle escaped character\n\t\t\t\t\tbuf.append(options.escape(stream.next()));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ta = ch;\n\n\t\t\t\tif (ch == '$') {\n\t\t\t\t\t// looks like a tabstop\n\t\t\t\t\tstream.start = stream.pos - 1;\n\n\t\t\t\t\tif (m = stream.match(/^[0-9]+/)) {\n\t\t\t\t\t\t// it's $N\n\t\t\t\t\t\ta = options.tabstop({\n\t\t\t\t\t\t\tstart: buf.length,\n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/)) {\n\t\t\t\t\t\t// ${variable}\n\t\t\t\t\t\ta = options.variable({\n\t\t\t\t\t\t\tstart: buf.length,\n\t\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false)) {\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\n\t\t\t\t\t\t// parse placeholder, including nested ones\n\t\t\t\t\t\tstream.skipToPair('{', '}');\n\n\t\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t\tstart: buf.length,\n\t\t\t\t\t\t\tgroup: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\n\n\t\t\t\t\t\tif (placeholder) {\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ta = options.tabstop(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbuf.append(a);\n\t\t\t}\n\n\t\t\treturn buf.toString();\n\t\t},\n\n\t\t/**\n   * Upgrades tabstops in output node in order to prevent naming conflicts\n   * @param {AbbreviationNode} node\n   * @param {Number} offset Tab index offset\n   * @returns {Number} Maximum tabstop index in element\n   */\n\t\tupgrade: function upgrade(node, offset) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar options = {\n\t\t\t\ttabstop: function tabstop(data) {\n\t\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\n\t\t\t\t\tif (data.placeholder) return '${' + (group + offset) + ':' + data.placeholder + '}';else return '${' + (group + offset) + '}';\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t_.each(['start', 'end', 'content'], function (p) {\n\t\t\t\tnode[p] = this.processText(node[p], options);\n\t\t\t}, this);\n\n\t\t\treturn maxNum;\n\t\t},\n\n\t\t/**\n   * Helper function that produces a callback function for \n   * <code>replaceVariables()</code> method from {@link utils}\n   * module. This callback will replace variable definitions (like \n   * ${var_name}) with their value defined in <i>resource</i> module,\n   * or outputs tabstop with variable name otherwise.\n   * @param {AbbreviationNode} node Context node\n   * @returns {Function}\n   */\n\t\tvariablesResolver: function variablesResolver(node) {\n\t\t\tvar placeholderMemo = {};\n\t\t\tvar res = require('resources');\n\t\t\treturn function (str, varName) {\n\t\t\t\t// do not mark `child` variable as placeholder  its a reserved\n\t\t\t\t// variable name\n\t\t\t\tif (varName == 'child') return str;\n\n\t\t\t\tif (varName == 'cursor') return require('utils').getCaretPlaceholder();\n\n\t\t\t\tvar attr = node.attribute(varName);\n\t\t\t\tif (!_.isUndefined(attr) && attr !== str) {\n\t\t\t\t\treturn attr;\n\t\t\t\t}\n\n\t\t\t\tvar varValue = res.getVariable(varName);\n\t\t\t\tif (varValue) return varValue;\n\n\t\t\t\t// output as placeholder\n\t\t\t\tif (!placeholderMemo[varName]) placeholderMemo[varName] = startPlaceholderNum++;\n\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\n\t\t\t};\n\t\t},\n\n\t\t/**\n   * Resets global tabstop index. When parsed tree is converted to output\n   * string (<code>AbbreviationNode.toString()</code>), all tabstops \n   * defined in snippets and elements are upgraded in order to prevent\n   * naming conflicts of nested. For example, <code>${1}</code> of a node\n   * should not be linked with the same placehilder of the child node.\n   * By default, <code>AbbreviationNode.toString()</code> automatically\n   * upgrades tabstops of the same index for each node and writes maximum\n   * tabstop index into the <code>tabstopIndex</code> variable. To keep\n   * this variable at reasonable value, it is recommended to call \n   * <code>resetTabstopIndex()</code> method each time you expand variable \n   * @returns\n   */\n\t\tresetTabstopIndex: function resetTabstopIndex() {\n\t\t\ttabstopIndex = 0;\n\t\t\tstartPlaceholderNum = 100;\n\t\t}\n\t};\n}); /**\n    * Common module's preferences storage. This module \n    * provides general storage for all module preferences, their description and\n    * default values.<br><br>\n    * \n    * This module can also be used to list all available properties to create \n    * UI for updating properties\n    * \n    * @memberOf __preferencesDefine\n    * @constructor\n    * @param {Function} require\n    * @param {Underscore} _ \n    */\nemmet.define('preferences', function (require, _) {\n\tvar preferences = {};\n\tvar defaults = {};\n\tvar _dbgDefaults = null;\n\tvar _dbgPreferences = null;\n\n\tfunction toBoolean(val) {\n\t\tif (_.isString(val)) {\n\t\t\tval = val.toLowerCase();\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\n\t\t}\n\n\t\treturn !!val;\n\t}\n\n\tfunction isValueObj(obj) {\n\t\treturn _.isObject(obj) && 'value' in obj && _.keys(obj).length < 3;\n\t}\n\n\treturn {\n\t\t/**\n   * Creates new preference item with default value\n   * @param {String} name Preference name. You can also pass object\n   * with many options\n   * @param {Object} value Preference default value\n   * @param {String} description Item textual description\n   * @memberOf preferences\n   */\n\t\tdefine: function define(name, value, description) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tdescription: description\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t_.each(prefs, function (v, k) {\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : { value: v };\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Updates preference item value. Preference value should be defined\n   * first with <code>define</code> method.\n   * @param {String} name Preference name. You can also pass object\n   * with many options\n   * @param {Object} value Preference default value\n   * @memberOf preferences\n   */\n\t\tset: function set(name, value) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = value;\n\t\t\t}\n\n\t\t\t_.each(prefs, function (v, k) {\n\t\t\t\tif (!(k in defaults)) {\n\t\t\t\t\tthrow 'Property \"' + k + '\" is not defined. You should define it first with `define` method of current module';\n\t\t\t\t}\n\n\t\t\t\t// do not set value if it equals to default value\n\t\t\t\tif (v !== defaults[k].value) {\n\t\t\t\t\t// make sure we have value of correct type\n\t\t\t\t\tswitch (_typeof(defaults[k].value)) {\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tv = toBoolean(v);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// convert to string\n\t\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\t\tv += '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpreferences[k] = v;\n\t\t\t\t} else if (k in preferences) {\n\t\t\t\t\tdelete preferences[k];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Returns preference value\n   * @param {String} name\n   * @returns {String} Returns <code>undefined</code> if preference is \n   * not defined\n   */\n\t\tget: function get(name) {\n\t\t\tif (name in preferences) return preferences[name];\n\n\t\t\tif (name in defaults) return defaults[name].value;\n\n\t\t\treturn void 0;\n\t\t},\n\n\t\t/**\n   * Returns comma-separated preference value as array of values\n   * @param {String} name\n   * @returns {Array} Returns <code>undefined</code> if preference is \n   * not defined, <code>null</code> if string cannot be converted to array\n   */\n\t\tgetArray: function getArray(name) {\n\t\t\tvar val = this.get(name);\n\t\t\tif (_.isUndefined(val) || val === null || val === '') {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tval = _.map(val.split(','), require('utils').trim);\n\t\t\tif (!val.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn val;\n\t\t},\n\n\t\t/**\n   * Returns comma and colon-separated preference value as dictionary\n   * @param {String} name\n   * @returns {Object}\n   */\n\t\tgetDict: function getDict(name) {\n\t\t\tvar result = {};\n\t\t\t_.each(this.getArray(name), function (val) {\n\t\t\t\tvar parts = val.split(':');\n\t\t\t\tresult[parts[0]] = parts[1];\n\t\t\t});\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n   * Returns description of preference item\n   * @param {String} name Preference name\n   * @returns {Object}\n   */\n\t\tdescription: function description(name) {\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\n\t\t},\n\n\t\t/**\n   * Completely removes specified preference(s)\n   * @param {String} name Preference name (or array of names)\n   */\n\t\tremove: function remove(name) {\n\t\t\tif (!_.isArray(name)) name = [name];\n\n\t\t\t_.each(name, function (key) {\n\t\t\t\tif (key in preferences) delete preferences[key];\n\n\t\t\t\tif (key in defaults) delete defaults[key];\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Returns sorted list of all available properties\n   * @returns {Array}\n   */\n\t\tlist: function list() {\n\t\t\treturn _.map(_.keys(defaults).sort(), function (key) {\n\t\t\t\treturn {\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: this.get(key),\n\t\t\t\t\ttype: _typeof(defaults[key].value),\n\t\t\t\t\tdescription: defaults[key].description\n\t\t\t\t};\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n   * Loads user-defined preferences from JSON\n   * @param {Object} json\n   * @returns\n   */\n\t\tload: function load(json) {\n\t\t\t_.each(json, function (value, key) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n   * Returns hash of user-modified preferences\n   * @returns {Object}\n   */\n\t\texportModified: function exportModified() {\n\t\t\treturn _.clone(preferences);\n\t\t},\n\n\t\t/**\n   * Reset to defaults\n   * @returns\n   */\n\t\treset: function reset() {\n\t\t\tpreferences = {};\n\t\t},\n\n\t\t/**\n   * For unit testing: use empty storage\n   */\n\t\t_startTest: function _startTest() {\n\t\t\t_dbgDefaults = defaults;\n\t\t\t_dbgPreferences = preferences;\n\t\t\tdefaults = {};\n\t\t\tpreferences = {};\n\t\t},\n\n\t\t/**\n   * For unit testing: restore original storage\n   */\n\t\t_stopTest: function _stopTest() {\n\t\t\tdefaults = _dbgDefaults;\n\t\t\tpreferences = _dbgPreferences;\n\t\t}\n\t};\n}); /**\n    * Module for handling filters\n    * @param {Function} require\n    * @param {Underscore} _\n    * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n    */\nemmet.define('filters', function (require, _) {\n\t/** List of registered filters */\n\tvar registeredFilters = {};\n\n\t/** Filters that will be applied for unknown syntax */\n\tvar basicFilters = 'html';\n\n\tfunction list(filters) {\n\t\tif (!filters) return [];\n\n\t\tif (_.isString(filters)) return filters.split(/[\\|,]/g);\n\n\t\treturn filters;\n\t}\n\n\treturn {\n\t\t/**\n   * Register new filter\n   * @param {String} name Filter name\n   * @param {Function} fn Filter function\n   */\n\t\tadd: function add(name, fn) {\n\t\t\tregisteredFilters[name] = fn;\n\t\t},\n\n\t\t/**\n   * Apply filters for final output tree\n   * @param {AbbreviationNode} tree Output tree\n   * @param {Array} filters List of filters to apply. Might be a \n   * <code>String</code>\n   * @param {Object} profile Output profile, defined in <i>profile</i> \n   * module. Filters defined it profile are not used, <code>profile</code>\n   * is passed to filter function\n   * @memberOf emmet.filters\n   * @returns {AbbreviationNode}\n   */\n\t\tapply: function apply(tree, filters, profile) {\n\t\t\tvar utils = require('utils');\n\t\t\tprofile = require('profile').get(profile);\n\n\t\t\t_.each(list(filters), function (filter) {\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\n\t\t\t\tif (name && name in registeredFilters) {\n\t\t\t\t\ttree = registeredFilters[name](tree, profile);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn tree;\n\t\t},\n\n\t\t/**\n   * Composes list of filters that should be applied to a tree, based on \n   * passed data\n   * @param {String} syntax Syntax name ('html', 'css', etc.)\n   * @param {Object} profile Output profile\n   * @param {String} additionalFilters List or pipe-separated\n   * string of additional filters to apply\n   * @returns {Array}\n   */\n\t\tcomposeList: function composeList(syntax, profile, additionalFilters) {\n\t\t\tprofile = require('profile').get(profile);\n\t\t\tvar filters = list(profile.filters || require('resources').findItem(syntax, 'filters') || basicFilters);\n\n\t\t\tif (profile.extraFilters) {\n\t\t\t\tfilters = filters.concat(list(profile.extraFilters));\n\t\t\t}\n\n\t\t\tif (additionalFilters) {\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\n\t\t\t}\n\n\t\t\tif (!filters || !filters.length) {\n\t\t\t\t// looks like unknown syntax, apply basic filters\n\t\t\t\tfilters = list(basicFilters);\n\t\t\t}\n\n\t\t\treturn filters;\n\t\t},\n\n\t\t/**\n   * Extracts filter list from abbreviation\n   * @param {String} abbr\n   * @returns {Array} Array with cleaned abbreviation and list of \n   * extracted filters\n   */\n\t\textractFromAbbreviation: function extractFromAbbreviation(abbr) {\n\t\t\tvar filters = '';\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function (str, p1) {\n\t\t\t\tfilters = p1;\n\t\t\t\treturn '';\n\t\t\t});\n\n\t\t\treturn [abbr, list(filters)];\n\t\t}\n\t};\n}); /**\n    * Module that contains factories for element types used by Emmet\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('elements', function (require, _) {\n\tvar factories = {};\n\tvar reAttrs = /([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\2/g;\n\n\tvar result = {\n\t\t/**\n   * Create new element factory\n   * @param {String} name Element identifier\n   * @param {Function} factory Function that produces element of specified \n   * type. The object generated by this factory is automatically \n   * augmented with <code>type</code> property pointing to element\n   * <code>name</code>\n   * @memberOf elements\n   */\n\t\tadd: function add(name, factory) {\n\t\t\tvar that = this;\n\t\t\tfactories[name] = function () {\n\t\t\t\tvar elem = factory.apply(that, arguments);\n\t\t\t\tif (elem) elem.type = name;\n\n\t\t\t\treturn elem;\n\t\t\t};\n\t\t},\n\n\t\t/**\n   * Returns factory for specified name\n   * @param {String} name\n   * @returns {Function}\n   */\n\t\tget: function get(name) {\n\t\t\treturn factories[name];\n\t\t},\n\n\t\t/**\n   * Creates new element with specified type\n   * @param {String} name\n   * @returns {Object}\n   */\n\t\tcreate: function create(name) {\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\tvar factory = this.get(name);\n\t\t\treturn factory ? factory.apply(this, args) : null;\n\t\t},\n\n\t\t/**\n   * Check if passed element is of specified type\n   * @param {Object} elem\n   * @param {String} type\n   * @returns {Boolean}\n   */\n\t\tis: function is(elem, type) {\n\t\t\treturn elem && elem.type === type;\n\t\t}\n\t};\n\n\t// register resource references\n\tfunction commonFactory(value) {\n\t\treturn { data: value };\n\t}\n\n\t/**\n  * Element factory\n  * @param {String} elementName Name of output element\n  * @param {String} attrs Attributes definition. You may also pass\n  * <code>Array</code> where each contains object with <code>name</code> \n  * and <code>value</code> properties, or <code>Object</code>\n  * @param {Boolean} isEmpty Is expanded element should be empty\n  */\n\tresult.add('element', function (elementName, attrs, isEmpty) {\n\t\tvar ret = {\n\t\t\t/** @memberOf __emmetDataElement */\n\t\t\tname: elementName,\n\t\t\tis_empty: !!isEmpty\n\t\t};\n\n\t\tif (attrs) {\n\t\t\tret.attributes = [];\n\t\t\tif (_.isArray(attrs)) {\n\t\t\t\tret.attributes = attrs;\n\t\t\t} else if (_.isString(attrs)) {\n\t\t\t\tvar m;\n\t\t\t\twhile (m = reAttrs.exec(attrs)) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\tvalue: m[3]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_.each(attrs, function (value, name) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t});\n\n\tresult.add('snippet', commonFactory);\n\tresult.add('reference', commonFactory);\n\tresult.add('empty', function () {\n\t\treturn {};\n\t});\n\n\treturn result;\n}); /**\n    * Abstract implementation of edit tree interface.\n    * Edit tree is a named container of editable name-value child elements, \n    * parsed from <code>source</code>. This container provides convenient methods\n    * for editing/adding/removing child elements. All these update actions are\n    * instantly reflected in the <code>source</code> code with respect of formatting.\n    * <br><br>\n    * For example, developer can create an edit tree from CSS rule and add or \n    * remove properties from itall changes will be immediately reflected in the \n    * original source.\n    * <br><br>\n    * All classes defined in this module should be extended the same way as in\n    * Backbone framework: using <code>extend</code> method to create new class and \n    * <code>initialize</code> method to define custom class constructor.\n    * \n    * @example\n    * <pre><code>\n    * var MyClass = require('editTree').EditElement.extend({\n    * \tinitialize: function() {\n    * \t\t// constructor code here\n    * \t}\n    * });\n    * \n    * var elem = new MyClass(); \n    * </code></pre>\n    * \n    * \n    * @param {Function} require\n    * @param {Underscore} _\n    * @constructor\n    * @memberOf __editTreeDefine\n    */\nemmet.define('editTree', function (require, _, core) {\n\tvar _range = require('range').create;\n\n\t/**\n  * Named container of edited source\n  * @type EditContainer\n  * @param {String} source\n  * @param {Object} options\n  */\n\tfunction EditContainer(source, options) {\n\t\tthis.options = _.extend({ offset: 0 }, options);\n\t\t/**\n   * Source code of edited structure. All changes in the structure are \n   * immediately reflected into this property\n   */\n\t\tthis.source = source;\n\n\t\t/** \n   * List of all editable children\n   * @private \n   */\n\t\tthis._children = [];\n\n\t\t/**\n   * Hash of all positions of container\n   * @private\n   */\n\t\tthis._positions = {\n\t\t\tname: 0\n\t\t};\n\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\n\t/**\n  * The self-propagating extend function for classes.\n  * @type Function\n  */\n\tEditContainer.extend = core.extend;\n\n\tEditContainer.prototype = {\n\t\t/**\n   * Child class constructor\n   */\n\t\tinitialize: function initialize() {},\n\n\t\t/**\n   * Replace substring of tag's source\n   * @param {String} value\n   * @param {Number} start\n   * @param {Number} end\n   * @private\n   */\n\t\t_updateSource: function _updateSource(value, start, end) {\n\t\t\t// create modification range\n\t\t\tvar r = _range(start, _.isUndefined(end) ? 0 : end - start);\n\t\t\tvar delta = value.length - r.length();\n\n\t\t\tvar update = function update(obj) {\n\t\t\t\t_.each(obj, function (v, k) {\n\t\t\t\t\tif (v >= r.end) obj[k] += delta;\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// update affected positions of current container\n\t\t\tupdate(this._positions);\n\n\t\t\t// update affected positions of children\n\t\t\t_.each(this.list(), function (item) {\n\t\t\t\tupdate(item._positions);\n\t\t\t});\n\n\t\t\tthis.source = require('utils').replaceSubstring(this.source, value, r);\n\t\t},\n\n\t\t/**\n   * Adds new attribute \n   * @param {String} name Property name\n   * @param {String} value Property value\n   * @param {Number} pos Position at which to insert new property. By \n   * default the property is inserted at the end of rule \n   * @returns {EditElement} Newly created element\n   */\n\t\tadd: function add(name, value, pos) {\n\t\t\t// this is abstract implementation\n\t\t\tvar item = new EditElement(name, value);\n\t\t\tthis._children.push(item);\n\t\t\treturn item;\n\t\t},\n\n\t\t/**\n   * Returns attribute object\n   * @param {String} name Attribute name or its index\n   * @returns {EditElement}\n   */\n\t\tget: function get(name) {\n\t\t\tif (_.isNumber(name)) return this.list()[name];\n\n\t\t\tif (_.isString(name)) return _.find(this.list(), function (prop) {\n\t\t\t\treturn prop.name() === name;\n\t\t\t});\n\n\t\t\treturn name;\n\t\t},\n\n\t\t/**\n   * Returns all children by name or indexes\n   * @param {Object} name Element name(s) or indexes (<code>String</code>,\n   * <code>Array</code>, <code>Number</code>)\n   * @returns {Array}\n   */\n\t\tgetAll: function getAll(name) {\n\t\t\tif (!_.isArray(name)) name = [name];\n\n\t\t\t// split names and indexes\n\t\t\tvar names = [],\n\t\t\t    indexes = [];\n\t\t\t_.each(name, function (item) {\n\t\t\t\tif (_.isString(item)) names.push(item);else if (_.isNumber(item)) indexes.push(item);\n\t\t\t});\n\n\t\t\treturn _.filter(this.list(), function (attribute, i) {\n\t\t\t\treturn _.include(indexes, i) || _.include(names, attribute.name());\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Returns or updates element value. If such element doesn't exists,\n   * it will be created automatically and added at the end of child list.\n   * @param {String} name Element name or its index\n   * @param {String} value New element value\n   * @returns {String}\n   */\n\t\tvalue: function value(name, _value, pos) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element) return element.value(_value);\n\n\t\t\tif (!_.isUndefined(_value)) {\n\t\t\t\t// no such element  create it\n\t\t\t\treturn this.add(name, _value, pos);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Returns all values of child elements found by <code>getAll()</code>\n   * method\n   * @param {Object} name Element name(s) or indexes (<code>String</code>,\n   * <code>Array</code>, <code>Number</code>)\n   * @returns {Array}\n   */\n\t\tvalues: function values(name) {\n\t\t\treturn _.map(this.getAll(name), function (element) {\n\t\t\t\treturn element.value();\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Remove child element\n   * @param {String} name Property name or its index\n   */\n\t\tremove: function remove(name) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element) {\n\t\t\t\tthis._updateSource('', element.fullRange());\n\t\t\t\tthis._children = _.without(this._children, element);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Returns list of all editable child elements\n   * @returns {Array}\n   */\n\t\tlist: function list() {\n\t\t\treturn this._children;\n\t\t},\n\n\t\t/**\n   * Returns index of editble child in list\n   * @param {Object} item\n   * @returns {Number}\n   */\n\t\tindexOf: function indexOf(item) {\n\t\t\treturn _.indexOf(this.list(), this.get(item));\n\t\t},\n\n\t\t/**\n   * Sets or gets container name\n   * @param {String} val New name. If not passed, current \n   * name is returned\n   * @return {String}\n   */\n\t\tname: function name(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\n\t\t\t\tthis._name = val;\n\t\t\t}\n\n\t\t\treturn this._name;\n\t\t},\n\n\t\t/**\n   * Returns name range object\n   * @param {Boolean} isAbsolute Return absolute range (with respect of \n   * rule offset)\n   * @returns {Range}\n   */\n\t\tnameRange: function nameRange(isAbsolute) {\n\t\t\treturn _range(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\n\t\t},\n\n\t\t/**\n   * Returns range of current source\n   * @param {Boolean} isAbsolute\n   */\n\t\trange: function range(isAbsolute) {\n\t\t\treturn _range(isAbsolute ? this.options.offset : 0, this.toString());\n\t\t},\n\n\t\t/**\n   * Returns element that belongs to specified position\n   * @param {Number} pos\n   * @param {Boolean} isAbsolute\n   * @returns {EditElement}\n   */\n\t\titemFromPosition: function itemFromPosition(pos, isAbsolute) {\n\t\t\treturn _.find(this.list(), function (elem) {\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Returns source code of current container \n   * @returns {String}\n   */\n\t\ttoString: function toString() {\n\t\t\treturn this.source;\n\t\t}\n\t};\n\n\t/**\n  * @param {EditContainer} parent\n  * @param {Object} nameToken\n  * @param {Object} valueToken\n  */\n\tfunction EditElement(parent, nameToken, valueToken) {\n\t\t/** @type EditContainer */\n\t\tthis.parent = parent;\n\n\t\tthis._name = nameToken.value;\n\t\tthis._value = valueToken ? valueToken.value : '';\n\n\t\tthis._positions = {\n\t\t\tname: nameToken.start,\n\t\t\tvalue: valueToken ? valueToken.start : -1\n\t\t};\n\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\n\t/**\n  * The self-propagating extend function for classes.\n  * @type Function\n  */\n\tEditElement.extend = core.extend;\n\n\tEditElement.prototype = {\n\t\t/**\n   * Child class constructor\n   */\n\t\tinitialize: function initialize() {},\n\n\t\t/**\n   * Make position absolute\n   * @private\n   * @param {Number} num\n   * @param {Boolean} isAbsolute\n   * @returns {Boolean}\n   */\n\t\t_pos: function _pos(num, isAbsolute) {\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\n\t\t},\n\n\t\t/**\n   * Sets of gets element value\n   * @param {String} val New element value. If not passed, current \n   * value is returned\n   * @returns {String}\n   */\n\t\tvalue: function value(val) {\n\t\t\tif (!_.isUndefined(val) && this._value !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\n\t\t\t\tthis._value = val;\n\t\t\t}\n\n\t\t\treturn this._value;\n\t\t},\n\n\t\t/**\n   * Sets of gets element name\n   * @param {String} val New element name. If not passed, current \n   * name is returned\n   * @returns {String}\n   */\n\t\tname: function name(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\n\t\t\t\tthis._name = val;\n\t\t\t}\n\n\t\t\treturn this._name;\n\t\t},\n\n\t\t/**\n   * Returns position of element name token\n   * @param {Boolean} isAbsolute Return absolute position\n   * @returns {Number}\n   */\n\t\tnamePosition: function namePosition(isAbsolute) {\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\n\t\t},\n\n\t\t/**\n   * Returns position of element value token\n   * @param {Boolean} isAbsolute Return absolute position\n   * @returns {Number}\n   */\n\t\tvaluePosition: function valuePosition(isAbsolute) {\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\n\t\t},\n\n\t\t/**\n   * Returns element name\n   * @param {Boolean} isAbsolute Return absolute range \n   * @returns {Range}\n   */\n\t\trange: function range(isAbsolute) {\n\t\t\treturn _range(this.namePosition(isAbsolute), this.toString());\n\t\t},\n\n\t\t/**\n   * Returns full element range, including possible indentation\n   * @param {Boolean} isAbsolute Return absolute range\n   * @returns {Range}\n   */\n\t\tfullRange: function fullRange(isAbsolute) {\n\t\t\treturn this.range(isAbsolute);\n\t\t},\n\n\t\t/**\n   * Returns element name range\n   * @param {Boolean} isAbsolute Return absolute range\n   * @returns {Range}\n   */\n\t\tnameRange: function nameRange(isAbsolute) {\n\t\t\treturn _range(this.namePosition(isAbsolute), this.name());\n\t\t},\n\n\t\t/**\n   * Returns element value range\n   * @param {Boolean} isAbsolute Return absolute range\n   * @returns {Range}\n   */\n\t\tvalueRange: function valueRange(isAbsolute) {\n\t\t\treturn _range(this.valuePosition(isAbsolute), this.value());\n\t\t},\n\n\t\t/**\n   * Returns current element string representation\n   * @returns {String}\n   */\n\t\ttoString: function toString() {\n\t\t\treturn this.name() + this.value();\n\t\t},\n\n\t\tvalueOf: function valueOf() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\n\treturn {\n\t\tEditContainer: EditContainer,\n\t\tEditElement: EditElement,\n\n\t\t/**\n   * Creates token that can be fed to <code>EditElement</code>\n   * @param {Number} start\n   * @param {String} value\n   * @param {String} type\n   * @returns\n   */\n\t\tcreateToken: function createToken(start, value, type) {\n\t\t\tvar obj = {\n\t\t\t\tstart: start || 0,\n\t\t\t\tvalue: value || '',\n\t\t\t\ttype: type\n\t\t\t};\n\n\t\t\tobj.end = obj.start + obj.value.length;\n\t\t\treturn obj;\n\t\t}\n\t};\n}); /**\n    * CSS EditTree is a module that can parse a CSS rule into a tree with \n    * convenient methods for adding, modifying and removing CSS properties. These \n    * changes can be written back to string with respect of code formatting.\n    * \n    * @memberOf __cssEditTreeDefine\n    * @constructor\n    * @param {Function} require\n    * @param {Underscore} _ \n    */\nemmet.define('cssEditTree', function (require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: '\\n\\t',\n\t\tstyleSeparator: ': ',\n\t\toffset: 0\n\t};\n\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\n\tvar WHITESPACE_REMOVE_FROM_END = 2;\n\n\t/**\n  * Returns range object\n  * @param {Number} start\n  * @param {Number} len \n  * @returns {Range}\n  */\n\tfunction range(start, len) {\n\t\treturn require('range').create(start, len);\n\t}\n\n\t/**\n  * Removes whitespace tokens from the array ends\n  * @param {Array} tokens\n  * @param {Number} mask Mask indicating from which end whitespace should be \n  * removed \n  * @returns {Array}\n  */\n\tfunction trimWhitespaceTokens(tokens, mask) {\n\t\tmask = mask || WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END;\n\t\tvar whitespace = ['white', 'line'];\n\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) == WHITESPACE_REMOVE_FROM_END) while (tokens.length && _.include(whitespace, _.last(tokens).type)) {\n\t\t\ttokens.pop();\n\t\t}\n\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) == WHITESPACE_REMOVE_FROM_START) while (tokens.length && _.include(whitespace, tokens[0].type)) {\n\t\t\ttokens.shift();\n\t\t}\n\n\t\treturn tokens;\n\t}\n\n\t/**\n  * Helper function that searches for selector range for <code>CSSEditRule</code>\n  * @param {TokenIterator} it\n  * @returns {Range}\n  */\n\tfunction findSelectorRange(it) {\n\t\tvar tokens = [],\n\t\t    token;\n\t\tvar start = it.position(),\n\t\t    end;\n\n\t\twhile (token = it.next()) {\n\t\t\tif (token.type == '{') break;\n\t\t\ttokens.push(token);\n\t\t}\n\n\t\ttrimWhitespaceTokens(tokens);\n\n\t\tif (tokens.length) {\n\t\t\tstart = tokens[0].start;\n\t\t\tend = _.last(tokens).end;\n\t\t} else {\n\t\t\tend = start;\n\t\t}\n\n\t\treturn range(start, end - start);\n\t}\n\n\t/**\n  * Helper function that searches for CSS property value range next to\n  * iterator's current position  \n  * @param {TokenIterator} it\n  * @returns {Range}\n  */\n\tfunction findValueRange(it) {\n\t\t// find value start position\n\t\tvar skipTokens = ['white', 'line', ':'];\n\t\tvar tokens = [],\n\t\t    token,\n\t\t    start,\n\t\t    end;\n\n\t\tit.nextUntil(function (tok) {\n\t\t\treturn !_.include(skipTokens, this.itemNext().type);\n\t\t});\n\n\t\tstart = it.current().end;\n\t\t// consume value\n\t\twhile (token = it.next()) {\n\t\t\tif (token.type == '}' || token.type == ';') {\n\t\t\t\t// found value end\n\t\t\t\ttrimWhitespaceTokens(tokens, WHITESPACE_REMOVE_FROM_START | (token.type == '}' ? WHITESPACE_REMOVE_FROM_END : 0));\n\n\t\t\t\tif (tokens.length) {\n\t\t\t\t\tstart = tokens[0].start;\n\t\t\t\t\tend = _.last(tokens).end;\n\t\t\t\t} else {\n\t\t\t\t\tend = start;\n\t\t\t\t}\n\n\t\t\t\treturn range(start, end - start);\n\t\t\t}\n\n\t\t\ttokens.push(token);\n\t\t}\n\n\t\t// reached the end of tokens list\n\t\tif (tokens.length) {\n\t\t\treturn range(tokens[0].start, _.last(tokens).end - tokens[0].start);\n\t\t}\n\t}\n\n\t/**\n  * Finds parts of complex CSS value\n  * @param {String} str\n  * @returns {Array} Returns list of <code>Range</code>'s\n  */\n\tfunction findParts(str) {\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(str);\n\t\tvar ch;\n\t\tvar result = [];\n\t\tvar sep = /[\\s\\u00a0,]/;\n\n\t\tvar add = function add() {\n\t\t\tstream.next();\n\t\t\tresult.push(range(stream.start, stream.current()));\n\t\t\tstream.start = stream.pos;\n\t\t};\n\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch == '\"' || ch == \"'\") {\n\t\t\t\tstream.next();\n\t\t\t\tif (!stream.skipTo(ch)) break;\n\t\t\t\tadd();\n\t\t\t} else if (ch == '(') {\n\t\t\t\t// function found, may have nested function\n\t\t\t\tstream.backUp(1);\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\n\t\t\t\tstream.backUp(1);\n\t\t\t\tadd();\n\t\t\t} else {\n\t\t\t\tif (sep.test(ch)) {\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\n\t\t\t\t\tstream.eatWhile(sep);\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tadd();\n\n\t\treturn _.chain(result).filter(function (item) {\n\t\t\treturn !!item.length();\n\t\t}).uniq(false, function (item) {\n\t\t\treturn item.toString();\n\t\t}).value();\n\t}\n\n\t/**\n  * A bit hacky way to identify invalid CSS property definition: when user\n  * starts writing new abbreviation in CSS rule, he actually creates invalid\n  * CSS property definition and this method tries to identify such abbreviation\n  * and prevent it from being added to CSS edit tree \n  * @param {TokenIterator} it\n  */\n\tfunction isValidIdentifier(it) {\n\t\t//\t\treturn true;\n\t\tvar tokens = it.tokens;\n\t\tfor (var i = it._i + 1, il = tokens.length; i < il; i++) {\n\t\t\tif (tokens[i].type == ':') return true;\n\n\t\t\tif (tokens[i].type == 'identifier' || tokens[i].type == 'line') return false;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n  * @class\n  * @extends EditContainer\n  */\n\tvar CSSEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function initialize(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tvar editTree = require('editTree');\n\n\t\t\t/** @type TokenIterator */\n\t\t\tvar it = require('tokenIterator').create(require('cssParser').parse(source));\n\n\t\t\tvar selectorRange = findSelectorRange(it);\n\t\t\tthis._positions.name = selectorRange.start;\n\t\t\tthis._name = selectorRange.substring(source);\n\n\t\t\tif (!it.current() || it.current().type != '{') throw 'Invalid CSS rule';\n\n\t\t\tthis._positions.contentStart = it.position() + 1;\n\n\t\t\t// consume properties\n\t\t\tvar propertyRange, valueRange, token;\n\t\t\twhile (token = it.next()) {\n\t\t\t\tif (token.type == 'identifier' && isValidIdentifier(it)) {\n\t\t\t\t\tpropertyRange = range(token);\n\t\t\t\t\tvalueRange = findValueRange(it);\n\t\t\t\t\tvar end = it.current() && it.current().type == ';' ? range(it.current()) : range(valueRange.end, 0);\n\t\t\t\t\tthis._children.push(new CSSEditElement(this, editTree.createToken(propertyRange.start, propertyRange.substring(source)), editTree.createToken(valueRange.start, valueRange.substring(source)), editTree.createToken(end.start, end.substring(source))));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._saveStyle();\n\t\t},\n\n\t\t/**\n   * Remembers all styles of properties\n   * @private\n   */\n\t\t_saveStyle: function _saveStyle() {\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar source = this.source;\n\t\t\tvar utils = require('utils');\n\n\t\t\t_.each(this.list(), /** @param {CSSEditProperty} p */function (p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t// a small hack here:\n\t\t\t\t// Sometimes users add empty lines before properties to logically\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\n\t\t\t\t// characters between rules may lead to undesired behavior,\n\t\t\t\t// especially when current rule is duplicated or used as a donor\n\t\t\t\t// to create new rule.\n\t\t\t\t// To solve this issue, well take only last newline indentation\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tp.styleBefore = '\\n' + _.last(lines);\n\t\t\t\t}\n\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\n\n\t\t\t\t// graceful and naive comments removal \n\t\t\t\tp.styleBefore = _.last(p.styleBefore.split('*/'));\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\n\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Adds new CSS property \n   * @param {String} name Property name\n   * @param {String} value Property value\n   * @param {Number} pos Position at which to insert new property. By \n   * default the property is inserted at the end of rule \n   * @returns {CSSEditProperty}\n   */\n\t\tadd: function add(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator');\n\t\t\tvar editTree = require('editTree');\n\n\t\t\tif (_.isUndefined(pos)) pos = list.length;\n\n\t\t\t/** @type CSSEditProperty */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\t// make sure that donor has terminating semicolon\n\t\t\t\tdonor.end(';');\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator');\n\t\t\t}\n\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\n\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken, editTree.createToken(valueToken.end, ';'));\n\n\t\t\t_.extend(property, styles);\n\n\t\t\t// write new property into the source\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\n\n\t\t\t// insert new property\n\t\t\tthis._children.splice(pos, 0, property);\n\t\t\treturn property;\n\t\t}\n\t});\n\n\t/**\n  * @class\n  * @type CSSEditElement\n  * @constructor\n  */\n\tvar CSSEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function initialize(rule, name, value, end) {\n\t\t\tthis.styleBefore = rule.options.styleBefore;\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\n\n\t\t\tthis._end = end.value;\n\t\t\tthis._positions.end = end.start;\n\t\t},\n\n\t\t/**\n   * Returns ranges of complex value parts\n   * @returns {Array} Returns <code>null</code> if value is not complex\n   */\n\t\tvalueParts: function valueParts(isAbsolute) {\n\t\t\tvar parts = findParts(this.value());\n\t\t\tif (isAbsolute) {\n\t\t\t\tvar offset = this.valuePosition(true);\n\t\t\t\t_.each(parts, function (p) {\n\t\t\t\t\tp.shift(offset);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn parts;\n\t\t},\n\n\t\t/**\n   * Sets of gets property end value (basically, it's a semicolon)\n   * @param {String} val New end value. If not passed, current \n   * value is returned\n   */\n\t\tend: function end(val) {\n\t\t\tif (!_.isUndefined(val) && this._end !== val) {\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\n\t\t\t\tthis._end = val;\n\t\t\t}\n\n\t\t\treturn this._end;\n\t\t},\n\n\t\t/**\n   * Returns full rule range, with indentation\n   * @param {Boolean} isAbsolute Return absolute range (with respect of\n   * rule offset)\n   * @returns {Range}\n   */\n\t\tfullRange: function fullRange(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\n\t\t/**\n   * Returns item string representation\n   * @returns {String}\n   */\n\t\ttoString: function toString() {\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\n\t\t}\n\t});\n\n\treturn {\n\t\t/**\n   * Parses CSS rule into editable tree\n   * @param {String} source\n   * @param {Object} options\n   * @memberOf emmet.cssEditTree\n   * @returns {EditContainer}\n   */\n\t\tparse: function parse(source, options) {\n\t\t\treturn new CSSEditContainer(source, options);\n\t\t},\n\n\t\t/**\n   * Extract and parse CSS rule from specified position in <code>content</code> \n   * @param {String} content CSS source code\n   * @param {Number} pos Character position where to start source code extraction\n   * @returns {EditContainer}\n   */\n\t\tparseFromPosition: function parseFromPosition(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractRule(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\n\t\t\t\treturn null;\n\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Extracts single CSS selector definition from source code\n   * @param {String} content CSS source code\n   * @param {Number} pos Character position where to start source code extraction\n   * @returns {Range}\n   */\n\t\textractRule: function extractRule(content, pos, isBackward) {\n\t\t\tvar result = '';\n\t\t\tvar len = content.length;\n\t\t\tvar offset = pos;\n\t\t\tvar stopChars = '{}/\\\\<>\\n\\r';\n\t\t\tvar bracePos = -1,\n\t\t\t    ch;\n\n\t\t\t// search left until we find rule edge\n\t\t\twhile (offset >= 0) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (ch == '}' && !isBackward) {\n\t\t\t\t\toffset++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\toffset--;\n\t\t\t}\n\n\t\t\t// search right for full rule set\n\t\t\twhile (offset < len) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\tif (bracePos != -1) result = content.substring(bracePos, offset + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\toffset++;\n\t\t\t}\n\n\t\t\tif (result) {\n\t\t\t\t// find CSS selector\n\t\t\t\toffset = bracePos - 1;\n\t\t\t\tvar selector = '';\n\t\t\t\twhile (offset >= 0) {\n\t\t\t\t\tch = content.charAt(offset);\n\t\t\t\t\tif (stopChars.indexOf(ch) != -1) break;\n\t\t\t\t\toffset--;\n\t\t\t\t}\n\n\t\t\t\t// also trim whitespace\n\t\t\t\tselector = content.substring(offset + 1, bracePos).replace(/^[\\s\\n\\r]+/m, '');\n\t\t\t\treturn require('range').create(bracePos - selector.length, result.length + selector.length);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t},\n\n\t\t/**\n  \t * Removes vendor prefix from CSS property\n  \t * @param {String} name CSS property\n  \t * @return {String}\n  \t */\n\t\tbaseName: function baseName(name) {\n\t\t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\n\t\t},\n\n\t\t/**\n   * Finds parts of complex CSS value\n   * @param {String} str\n   * @returns {Array}\n   */\n\t\tfindParts: findParts\n\t};\n}); /**\n    * XML EditTree is a module that can parse an XML/HTML element into a tree with \n    * convenient methods for adding, modifying and removing attributes. These \n    * changes can be written back to string with respect of code formatting.\n    * \n    * @memberOf __xmlEditTreeDefine\n    * @constructor\n    * @param {Function} require\n    * @param {Underscore} _ \n    */\nemmet.define('xmlEditTree', function (require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: ' ',\n\t\tstyleSeparator: '=',\n\t\tstyleQuote: '\"',\n\t\toffset: 0\n\t};\n\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\n\n\tvar XMLEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function initialize(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tthis._positions.name = 1;\n\n\t\t\tvar attrToken = null;\n\t\t\tvar tokens = require('xmlParser').parse(source);\n\t\t\tvar range = require('range');\n\n\t\t\t_.each(tokens, function (token) {\n\t\t\t\ttoken.value = range.create(token).substring(source);\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'tag':\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'attribute':\n\t\t\t\t\t\t// add empty attribute\n\t\t\t\t\t\tif (attrToken) {\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tattrToken = token;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\n\t\t\t\t\t\tattrToken = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\tif (attrToken) {\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t}\n\n\t\t\tthis._saveStyle();\n\t\t},\n\n\t\t/**\n   * Remembers all styles of properties\n   * @private\n   */\n\t\t_saveStyle: function _saveStyle() {\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar source = this.source;\n\n\t\t\t_.each(this.list(), /** @param {EditElement} p */function (p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\n\t\t\t\tif (p.valuePosition() !== -1) {\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\n\t\t\t\t}\n\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Adds new attribute \n   * @param {String} name Property name\n   * @param {String} value Property value\n   * @param {Number} pos Position at which to insert new property. By \n   * default the property is inserted at the end of rule \n   */\n\t\tadd: function add(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar editTree = require('editTree');\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\n\n\t\t\tif (_.isUndefined(pos)) pos = list.length;\n\n\t\t\t/** @type XMLEditAttribute */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t}\n\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\n\n\t\t\tvar attribute = new XMLEditElement(this, editTree.createToken(start + styles.styleBefore.length, name), editTree.createToken(start + styles.styleBefore.length + name.length + styles.styleSeparator.length, value));\n\n\t\t\t_.extend(attribute, styles);\n\n\t\t\t// write new attribute into the source\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\n\n\t\t\t// insert new attribute\n\t\t\tthis._children.splice(pos, 0, attribute);\n\t\t\treturn attribute;\n\t\t}\n\t});\n\n\tvar XMLEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function initialize(parent, nameToken, valueToken) {\n\t\t\tthis.styleBefore = parent.options.styleBefore;\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\n\n\t\t\tvar value = '',\n\t\t\t    quote = parent.options.styleQuote;\n\t\t\tif (valueToken) {\n\t\t\t\tvalue = valueToken.value;\n\t\t\t\tquote = value.charAt(0);\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\tvalue = value.substring(1);\n\t\t\t\t} else {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.styleQuote = quote;\n\n\t\t\tthis._value = value;\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\n\t\t},\n\n\t\t/**\n   * Returns full rule range, with indentation\n   * @param {Boolean} isAbsolute Return absolute range (with respect of\n   * rule offset)\n   * @returns {Range}\n   */\n\t\tfullRange: function fullRange(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\n\t\ttoString: function toString() {\n\t\t\treturn this.name() + this.styleSeparator + this.styleQuote + this.value() + this.styleQuote;\n\t\t}\n\t});\n\n\treturn {\n\t\t/**\n   * Parses HTML element into editable tree\n   * @param {String} source\n   * @param {Object} options\n   * @memberOf emmet.htmlEditTree\n   * @returns {EditContainer}\n   */\n\t\tparse: function parse(source, options) {\n\t\t\treturn new XMLEditContainer(source, options);\n\t\t},\n\n\t\t/**\n   * Extract and parse HTML from specified position in <code>content</code> \n   * @param {String} content CSS source code\n   * @param {Number} pos Character position where to start source code extraction\n   * @returns {XMLEditElement}\n   */\n\t\tparseFromPosition: function parseFromPosition(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\n\t\t\t\treturn null;\n\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Extracts nearest HTML tag range from <code>content</code>, starting at \n   * <code>pos</code> position\n   * @param {String} content\n   * @param {Number} pos\n   * @param {Boolean} isBackward\n   * @returns {Range}\n   */\n\t\textractTag: function extractTag(content, pos, isBackward) {\n\t\t\tvar len = content.length,\n\t\t\t    i;\n\t\t\tvar range = require('range');\n\n\t\t\t// max extraction length. I don't think there may be tags larger \n\t\t\t// than 2000 characters length\n\t\t\tvar maxLen = Math.min(2000, len);\n\n\t\t\t/** @type Range */\n\t\t\tvar r = null;\n\n\t\t\tvar match = function match(pos) {\n\t\t\t\tvar m;\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag))) return range.create(pos, m[0]);\n\t\t\t};\n\n\t\t\t// lookup backward, in case we are inside tag already\n\t\t\tfor (i = pos; i >= 0; i--) {\n\t\t\t\tif (r = match(i)) break;\n\t\t\t}\n\n\t\t\tif (r && (r.inside(pos) || isBackward)) return r;\n\n\t\t\tif (!r && isBackward) return null;\n\n\t\t\t// search forward\n\t\t\tfor (i = pos; i < len; i++) {\n\t\t\t\tif (r = match(i)) return r;\n\t\t\t}\n\t\t}\n\t};\n}); /**\n    * 'Expand abbreviation' editor action: extracts abbreviation from current caret \n    * position and replaces it with formatted output. \n    * <br><br>\n    * This behavior can be overridden with custom handlers which can perform \n    * different actions when 'Expand Abbreviation' action is called.\n    * For example, a CSS gradient handler that produces vendor-prefixed gradient\n    * definitions registers its own expand abbreviation handler.  \n    *  \n    * @constructor\n    * @memberOf __expandAbbreviationActionDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('expandAbbreviation', function (require, _) {\n\t/**\n  * @type HandlerList List of registered handlers\n  */\n\tvar handlers = require('handlerList').create();\n\n\t/** Back-reference to module */\n\tvar module = null;\n\n\tvar actions = require('actions');\n\t/**\n  * 'Expand abbreviation' editor action \n  * @param {IEmmetEditor} editor Editor instance\n  * @param {String} syntax Syntax type (html, css, etc.)\n  * @param {String} profile Output profile name (html, xml, xhtml)\n  * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n  * successfully\n  */\n\tactions.add('expand_abbreviation', function (editor, syntax, profile) {\n\t\tvar args = _.toArray(arguments);\n\n\t\t// normalize incoming arguments\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\targs[1] = info.syntax;\n\t\targs[2] = info.profile;\n\n\t\treturn handlers.exec(false, args);\n\t});\n\n\t/**\n  * A special version of <code>expandAbbreviation</code> function: if it can't\n  * find abbreviation, it will place Tab character at caret position\n  * @param {IEmmetEditor} editor Editor instance\n  * @param {String} syntax Syntax type (html, css, etc.)\n  * @param {String} profile Output profile name (html, xml, xhtml)\n  */\n\tactions.add('expand_abbreviation_with_tab', function (editor, syntax, profile) {\n\t\tvar sel = editor.getSelection();\n\t\tvar indent = require('resources').getVariable('indentation');\n\t\tif (sel) {\n\t\t\t// indent selection\n\t\t\tvar utils = require('utils');\n\t\t\tvar selRange = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = utils.padString(sel, indent);\n\n\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\n\t\t\tvar replaceRange = require('range').create(editor.getCaretPos(), selRange.length());\n\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\n\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!actions.run('expand_abbreviation', editor, syntax, profile)) {\n\t\t\teditor.replaceContent(indent, editor.getCaretPos());\n\t\t}\n\n\t\treturn true;\n\t}, { hidden: true });\n\n\t// XXX setup default handler\n\t/**\n  * Extracts abbreviation from current caret \n  * position and replaces it with formatted output \n  * @param {IEmmetEditor} editor Editor instance\n  * @param {String} syntax Syntax type (html, css, etc.)\n  * @param {String} profile Output profile name (html, xml, xhtml)\n  * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n  * successfully\n  */\n\thandlers.add(function (editor, syntax, profile) {\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = module.findAbbreviation(editor);\n\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile, require('actionUtils').captureContext(editor));\n\t\t\tif (content) {\n\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}, { order: -1 });\n\n\treturn module = {\n\t\t/**\n   * Adds custom expand abbreviation handler. The passed function should \n   * return <code>true</code> if it was performed successfully, \n   * <code>false</code> otherwise.\n   * \n   * Added handlers will be called when 'Expand Abbreviation' is called\n   * in order they were added\n   * @memberOf expandAbbreviation\n   * @param {Function} fn\n   * @param {Object} options\n   */\n\t\taddHandler: function addHandler(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\n\t\t/**\n   * Removes registered handler\n   * @returns\n   */\n\t\tremoveHandler: function removeHandler(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t},\n\n\t\t/**\n   * Search for abbreviation in editor from current caret position\n   * @param {IEmmetEditor} editor Editor instance\n   * @return {String}\n   */\n\t\tfindAbbreviation: function findAbbreviation(editor) {\n\t\t\t/** @type Range */\n\t\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = String(editor.getContent());\n\t\t\tif (range.length()) {\n\t\t\t\t// abbreviation is selected by user\n\t\t\t\treturn range.substring(content);\n\t\t\t}\n\n\t\t\t// search for new abbreviation from current caret position\n\t\t\tvar curLine = editor.getCurrentLineRange();\n\t\t\treturn require('actionUtils').extractAbbreviation(content.substring(curLine.start, range.start));\n\t\t}\n\t};\n}); /**\n    * Action that wraps content with abbreviation. For convenience, action is \n    * defined as reusable module\n    * @constructor\n    * @memberOf __wrapWithAbbreviationDefine\n    */\nemmet.define('wrapWithAbbreviation', function (require, _) {\n\t/** Back-references to current module */\n\tvar module = null;\n\n\t/**\n  * Wraps content with abbreviation\n  * @param {IEmmetEditor} Editor instance\n  * @param {String} abbr Abbreviation to wrap with\n  * @param {String} syntax Syntax type (html, css, etc.)\n  * @param {String} profile Output profile name (html, xml, xhtml)\n  */\n\trequire('actions').add('wrap_with_abbreviation', function (editor, abbr, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.editorUtils */\n\t\tvar editorUtils = require('editorUtils');\n\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\n\n\t\tif (!abbr) return null;\n\n\t\tabbr = String(abbr);\n\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\n\t\tif (!range.length()) {\n\t\t\t// no selection, find tag pair\n\t\t\tvar match = require('htmlMatcher').tag(info.content, range.start);\n\t\t\tif (!match) {\n\t\t\t\t// nothing to wrap\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\trange = utils.narrowToNonSpace(info.content, match.range);\n\t\t}\n\n\t\tvar newContent = utils.escapeText(range.substring(info.content));\n\t\tvar result = module.wrap(abbr, editorUtils.unindent(editor, newContent), info.syntax, info.profile, require('actionUtils').captureContext(editor));\n\n\t\tif (result) {\n\t\t\teditor.replaceContent(result, range.start, range.end);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n\n\treturn module = {\n\t\t/**\n   * Wraps passed text with abbreviation. Text will be placed inside last\n   * expanded element\n   * @memberOf wrapWithAbbreviation\n   * @param {String} abbr Abbreviation\n   * @param {String} text Text to wrap\n   * @param {String} syntax Document type (html, xml, etc.). Default is 'html'\n   * @param {String} profile Output profile's name. Default is 'plain'\n   * @param {Object} contextNode Context node inside which abbreviation\n   * is wrapped. It will be used as a reference for node name resolvers\n   * @return {String}\n   */\n\t\twrap: function wrap(abbr, text, syntax, profile, contextNode) {\n\t\t\t/** @type emmet.filters */\n\t\t\tvar filters = require('filters');\n\t\t\t/** @type emmet.utils */\n\t\t\tvar utils = require('utils');\n\n\t\t\tsyntax = syntax || emmet.defaultSyntax();\n\t\t\tprofile = require('profile').get(profile, syntax);\n\n\t\t\trequire('tabStops').resetTabstopIndex();\n\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar parsedTree = require('abbreviationParser').parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tpastedContent: text,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\tif (parsedTree) {\n\t\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\t\tfilters.apply(parsedTree, filtersList, profile);\n\t\t\t\treturn utils.replaceVariables(parsedTree.toString());\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t};\n}); /**\n    * Toggles HTML and CSS comments depending on current caret context. Unlike\n    * the same action in most editors, this action toggles comment on currently\n    * matched itemHTML tag or CSS selectorwhen nothing is selected.\n    * \n    * @param {Function} require\n    * @param {Underscore} _\n    * @memberOf __toggleCommentAction\n    * @constructor\n    */\nemmet.exec(function (require, _) {\n\t/**\n  * Toggle HTML comment on current selection or tag\n  * @param {IEmmetEditor} editor\n  * @return {Boolean} Returns <code>true</code> if comment was toggled\n  */\n\tfunction toggleHTMLComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\n\t\tif (!range.length()) {\n\t\t\t// no selection, find matching tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) {\n\t\t\t\t// found pair\n\t\t\t\trange = tag.outerRange;\n\t\t\t}\n\t\t}\n\n\t\treturn genericCommentToggle(editor, '<!--', '-->', range);\n\t}\n\n\t/**\n  * Simple CSS commenting\n  * @param {IEmmetEditor} editor\n  * @return {Boolean} Returns <code>true</code> if comment was toggled\n  */\n\tfunction toggleCSSComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\n\t\tif (!range.length()) {\n\t\t\t// no selection, try to get current rule\n\t\t\t/** @type CSSRule */\n\t\t\tvar rule = require('cssEditTree').parseFromPosition(info.content, editor.getCaretPos());\n\t\t\tif (rule) {\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\n\t\t\t\trange = property ? property.range(true) : require('range').create(rule.nameRange(true).start, rule.source);\n\t\t\t}\n\t\t}\n\n\t\tif (!range.length()) {\n\t\t\t// still no selection, get current line\n\t\t\trange = require('range').create(editor.getCurrentLineRange());\n\t\t\trequire('utils').narrowToNonSpace(info.content, range);\n\t\t}\n\n\t\treturn genericCommentToggle(editor, '/*', '*/', range);\n\t}\n\n\t/**\n  * Returns CSS property from <code>rule</code> that matches passed position\n  * @param {EditContainer} rule\n  * @param {Number} absPos\n  * @returns {EditElement}\n  */\n\tfunction cssItemFromPosition(rule, absPos) {\n\t\t// do not use default EditContainer.itemFromPosition() here, because\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\n\t\tvar relPos = absPos - (rule.options.offset || 0);\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\n\t\treturn _.find(rule.list(), function (item) {\n\t\t\tif (item.range().end === relPos) {\n\t\t\t\t// at the end of property, but outside of it\n\t\t\t\t// if theres a space character at current position,\n\t\t\t\t// use current property\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\n\t\t\t}\n\n\t\t\treturn item.range().inside(relPos);\n\t\t});\n\t}\n\n\t/**\n  * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\n  * @param {String} text Where to search\n  * @param {Number} from Search start index\n  * @param {String} start_token Comment start string\n  * @param {String} end_token Comment end string\n  * @return {Range} Returns null if comment wasn't found\n  */\n\tfunction searchComment(text, from, startToken, endToken) {\n\t\tvar commentStart = -1;\n\t\tvar commentEnd = -1;\n\n\t\tvar hasMatch = function hasMatch(str, start) {\n\t\t\treturn text.substr(start, str.length) == str;\n\t\t};\n\n\t\t// search for comment start\n\t\twhile (from--) {\n\t\t\tif (hasMatch(startToken, from)) {\n\t\t\t\tcommentStart = from;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (commentStart != -1) {\n\t\t\t// search for comment end\n\t\t\tfrom = commentStart;\n\t\t\tvar contentLen = text.length;\n\t\t\twhile (contentLen >= from++) {\n\t\t\t\tif (hasMatch(endToken, from)) {\n\t\t\t\t\tcommentEnd = from + endToken.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn commentStart != -1 && commentEnd != -1 ? require('range').create(commentStart, commentEnd - commentStart) : null;\n\t}\n\n\t/**\n  * Generic comment toggling routine\n  * @param {IEmmetEditor} editor\n  * @param {String} commentStart Comment start token\n  * @param {String} commentEnd Comment end token\n  * @param {Range} range Selection range\n  * @return {Boolean}\n  */\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar content = editorUtils.outputInfo(editor).content;\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar newContent = null;\n\n\t\tvar utils = require('utils');\n\n\t\t/**\n   * Remove comment markers from string\n   * @param {Sting} str\n   * @return {String}\n   */\n\t\tfunction removeComment(str) {\n\t\t\treturn str.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function (str) {\n\t\t\t\tcaretPos -= str.length;\n\t\t\t\treturn '';\n\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\n\t\t}\n\n\t\t// first, we need to make sure that this substring is not inside \n\t\t// comment\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\n\t\tif (commentRange && commentRange.overlap(range)) {\n\t\t\t// we're inside comment, remove it\n\t\t\trange = commentRange;\n\t\t\tnewContent = removeComment(range.substring(content));\n\t\t} else {\n\t\t\t// should add comment\n\t\t\t// make sure that there's no comment inside selection\n\t\t\tnewContent = commentStart + ' ' + range.substring(content).replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') + ' ' + commentEnd;\n\n\t\t\t// adjust caret position\n\t\t\tcaretPos += commentStart.length + 1;\n\t\t}\n\n\t\t// replace editor content\n\t\tif (newContent !== null) {\n\t\t\tnewContent = utils.escapeText(newContent);\n\t\t\teditor.setCaretPos(range.start);\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\n\t\t\teditor.setCaretPos(caretPos);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n  * Toggle comment on current editor's selection or HTML tag/CSS rule\n  * @param {IEmmetEditor} editor\n  */\n\trequire('actions').add('toggle_comment', function (editor) {\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tif (info.syntax == 'css') {\n\t\t\t// in case our editor is good enough and can recognize syntax from \n\t\t\t// current token, we have to make sure that cursor is not inside\n\t\t\t// 'style' attribute of html element\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && tag.open.range.inside(caretPos)) {\n\t\t\t\tinfo.syntax = 'html';\n\t\t\t}\n\t\t}\n\n\t\tif (info.syntax == 'css') return toggleCSSComment(editor);\n\n\t\treturn toggleHTMLComment(editor);\n\t});\n}); /**\n    * Move between next/prev edit points. 'Edit points' are places between tags \n    * and quotes of empty attributes in html\n    * @constructor\n    * \n    * @memberOf __editPointActionDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\t/**\n  * Search for new caret insertion point\n  * @param {IEmmetEditor} editor Editor instance\n  * @param {Number} inc Search increment: -1  search left, 1  search right\n  * @param {Number} offset Initial offset relative to current caret position\n  * @return {Number} Returns -1 if insertion point wasn't found\n  */\n\tfunction findNewEditPoint(editor, inc, offset) {\n\t\tinc = inc || 1;\n\t\toffset = offset || 0;\n\n\t\tvar curPoint = editor.getCaretPos() + offset;\n\t\tvar content = String(editor.getContent());\n\t\tvar maxLen = content.length;\n\t\tvar nextPoint = -1;\n\t\tvar reEmptyLine = /^\\s+$/;\n\n\t\tfunction getLine(ix) {\n\t\t\tvar start = ix;\n\t\t\twhile (start >= 0) {\n\t\t\t\tvar c = content.charAt(start);\n\t\t\t\tif (c == '\\n' || c == '\\r') break;\n\t\t\t\tstart--;\n\t\t\t}\n\n\t\t\treturn content.substring(start, ix);\n\t\t}\n\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\n\t\t\tcurPoint += inc;\n\t\t\tvar curChar = content.charAt(curPoint);\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\n\n\t\t\tswitch (curChar) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\n\t\t\t\t\t\t// empty attribute\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tif (nextChar == '<') {\n\t\t\t\t\t\t// between tags\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\tcase '\\r':\n\t\t\t\t\t// empty line\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\n\t\t\t\t\t\tnextPoint = curPoint;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (nextPoint != -1) break;\n\t\t}\n\n\t\treturn nextPoint;\n\t}\n\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\n\t/**\n  * Move caret to previous edit point\n  * @param {IEmmetEditor} editor Editor instance\n  */\n\tactions.add('prev_edit_point', function (editor) {\n\t\tvar curPos = editor.getCaretPos();\n\t\tvar newPoint = findNewEditPoint(editor, -1);\n\n\t\tif (newPoint == curPos)\n\t\t\t// we're still in the same point, try searching from the other place\n\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\n\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}, { label: 'Previous Edit Point' });\n\n\t/**\n  * Move caret to next edit point\n  * @param {IEmmetEditor} editor Editor instance\n  */\n\tactions.add('next_edit_point', function (editor) {\n\t\tvar newPoint = findNewEditPoint(editor, 1);\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n}); /**\n    * Actions that use stream parsers and tokenizers for traversing:\n    * -- Search for next/previous items in HTML\n    * -- Search for next/previous items in CSS\n    * @constructor\n    * @memberOf __selectItemActionDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\n\t/**\n  * Generic function for searching for items to select\n  * @param {IEmmetEditor} editor\n  * @param {Boolean} isBackward Search backward (search forward otherwise)\n  * @param {Function} extractFn Function that extracts item content\n  * @param {Function} rangeFn Function that search for next token range\n  */\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\n\t\tvar range = require('range');\n\t\tvar content = require('editorUtils').outputInfo(editor).content;\n\n\t\tvar contentLength = content.length;\n\t\tvar itemRange, rng;\n\t\t/** @type Range */\n\t\tvar prevRange = range.create(-1, 0);\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\n\t\tvar searchPos = sel.start,\n\t\t    loop = 100000; // endless loop protection\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\n\t\t\tif (itemRange = extractFn(content, searchPos, isBackward)) {\n\t\t\t\tif (prevRange.equal(itemRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tprevRange = itemRange.clone();\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\n\n\t\t\t\tif (rng) {\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsearchPos += isBackward ? -1 : 1;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t// XXX HTML section\n\n\t/**\n  * Find next HTML item\n  * @param {IEmmetEditor} editor\n  */\n\tfunction findNextHTMLItem(editor) {\n\t\tvar isFirst = true;\n\t\treturn findItem(editor, false, function (content, searchPos) {\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\n\t\t\t} else {\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\n\t\t\t}\n\t\t}, function (tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\n\t\t});\n\t}\n\n\t/**\n  * Find previous HTML item\n  * @param {IEmmetEditor} editor\n  */\n\tfunction findPrevHTMLItem(editor) {\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\n\t\t});\n\t}\n\n\t/**\n  * Creates possible selection ranges for HTML tag\n  * @param {String} source Original HTML source for tokens\n  * @param {Array} tokens List of HTML tokens\n  * @returns {Array}\n  */\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\n\t\toffset = offset || 0;\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\tvar attrStart = -1,\n\t\t    attrName = '',\n\t\t    attrValue = '',\n\t\t    attrValueRange,\n\t\t    tagName;\n\t\t_.each(tokens, function (tok) {\n\t\t\tswitch (tok.type) {\n\t\t\t\tcase 'tag':\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\n\t\t\t\t\t\t// add tag name\n\t\t\t\t\t\tresult.push(range.create({\n\t\t\t\t\t\t\tstart: tok.start + 1,\n\t\t\t\t\t\t\tend: tok.end\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'attribute':\n\t\t\t\t\tattrStart = tok.start;\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'string':\n\t\t\t\t\t// attribute value\n\t\t\t\t\t// push full attribute first\n\t\t\t\t\tresult.push(range.create(attrStart, tok.end - attrStart));\n\n\t\t\t\t\tattrValueRange = range.create(tok);\n\t\t\t\t\tattrValue = attrValueRange.substring(source);\n\n\t\t\t\t\t// is this a quoted attribute?\n\t\t\t\t\tif (isQuote(attrValue.charAt(0))) attrValueRange.start++;\n\n\t\t\t\t\tif (isQuote(attrValue.charAt(attrValue.length - 1))) attrValueRange.end--;\n\n\t\t\t\t\tresult.push(attrValueRange);\n\n\t\t\t\t\tif (attrName == 'class') {\n\t\t\t\t\t\tresult = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t// offset ranges\n\t\t_.each(result, function (r) {\n\t\t\tr.shift(offset);\n\t\t});\n\n\t\treturn _.chain(result).filter(function (item) {\n\t\t\t// remove empty\n\t\t\treturn !!item.length();\n\t\t}).uniq(false, function (item) {\n\t\t\t// remove duplicates\n\t\t\treturn item.toString();\n\t\t}).value();\n\t}\n\n\t/**\n  * Returns ranges of class names in \"class\" attribute value\n  * @param {String} className\n  * @returns {Array}\n  */\n\tfunction classNameRanges(className, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(className);\n\t\tvar range = require('range');\n\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\n\t\t\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start - 1));\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\n\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start));\n\t\treturn result;\n\t}\n\n\t/**\n  * Returns best HTML tag range match for current selection\n  * @param {String} tag Tag declaration\n  * @param {Number} offset Tag's position index inside content\n  * @param {Range} selRange Selection range\n  * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n  */\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\n\t\tvar ranges = makePossibleRangesHTML(tag, require('xmlParser').parse(tag), offset);\n\n\t\tif (isBackward) ranges.reverse();\n\n\t\t// try to find selected range\n\t\tvar curRange = _.find(ranges, function (r) {\n\t\t\treturn r.equal(selRange);\n\t\t});\n\n\t\tif (curRange) {\n\t\t\tvar ix = _.indexOf(ranges, curRange);\n\t\t\tif (ix < ranges.length - 1) return ranges[ix + 1];\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// no selected range, find nearest one\n\t\tif (isBackward)\n\t\t\t// search backward\n\t\t\treturn _.find(ranges, function (r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t});\n\n\t\t// search forward\n\t\t// to deal with overlapping ranges (like full attribute definition\n\t\t// and attribute value) let's find range under caret first\n\t\tif (!curRange) {\n\t\t\tvar matchedRanges = _.filter(ranges, function (r) {\n\t\t\t\treturn r.inside(selRange.end);\n\t\t\t});\n\n\t\t\tif (matchedRanges.length > 1) return matchedRanges[1];\n\t\t}\n\n\t\treturn _.find(ranges, function (r) {\n\t\t\treturn r.end > selRange.end;\n\t\t});\n\t}\n\n\t/**\n  * Search for opening tag in content, starting at specified position\n  * @param {String} html Where to search tag\n  * @param {Number} pos Character index where to start searching\n  * @return {Range} Returns range if valid opening tag was found,\n  * <code>null</code> otherwise\n  */\n\tfunction findOpeningTagFromPosition(html, pos) {\n\t\tvar tag;\n\t\twhile (pos >= 0) {\n\t\t\tif (tag = getOpeningTagFromPosition(html, pos)) return tag;\n\t\t\tpos--;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n  * @param {String} html Where to search tag\n  * @param {Number} pos Character index where to start searching\n  * @return {Range} Returns range if valid opening tag was found,\n  * <code>null</code> otherwise\n  */\n\tfunction getOpeningTagFromPosition(html, pos) {\n\t\tvar m;\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\n\t\t\treturn require('range').create(pos, m[0]);\n\t\t}\n\t}\n\n\tfunction isQuote(ch) {\n\t\treturn ch == '\"' || ch == \"'\";\n\t}\n\n\t/**\n  * Makes all possible selection ranges for specified CSS property\n  * @param {CSSProperty} property\n  * @returns {Array}\n  */\n\tfunction makePossibleRangesCSS(property) {\n\t\t// find all possible ranges, sorted by position and size\n\t\tvar valueRange = property.valueRange(true);\n\t\tvar result = [property.range(true), valueRange];\n\t\tvar stringStream = require('stringStream');\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar range = require('range');\n\n\t\t// locate parts of complex values.\n\t\t// some examples:\n\t\t//  1px solid red: 3 parts\n\t\t//  arial, sans-serif: enumeration, 2 parts\n\t\t//  url(image.png): function value part\n\t\tvar value = property.value();\n\t\t_.each(property.valueParts(), function (r) {\n\t\t\t// add absolute range\n\t\t\tvar clone = r.clone();\n\t\t\tresult.push(clone.shift(valueRange.start));\n\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(r.substring(value));\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\n\t\t\t\t// we have a function, find values in it.\n\t\t\t\t// but first add function contents\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tstream.skipToPair('(', ')');\n\t\t\t\tvar fnBody = stream.current();\n\t\t\t\tresult.push(range.create(clone.start + stream.start, fnBody));\n\n\t\t\t\t// find parts\n\t\t\t\t_.each(cssEditTree.findParts(fnBody), function (part) {\n\t\t\t\t\tresult.push(range.create(clone.start + stream.start + part.start, part.substring(fnBody)));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// optimize result: remove empty ranges and duplicates\n\t\treturn _.chain(result).filter(function (item) {\n\t\t\treturn !!item.length();\n\t\t}).uniq(false, function (item) {\n\t\t\treturn item.toString();\n\t\t}).value();\n\t}\n\n\t/**\n  * Tries to find matched CSS property and nearest range for selection\n  * @param {CSSRule} rule\n  * @param {Range} selRange\n  * @param {Boolean} isBackward\n  * @returns {Range}\n  */\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\n\t\t/** @type CSSProperty */\n\t\tvar property = null;\n\t\tvar possibleRanges,\n\t\t    curRange = null,\n\t\t    ix;\n\t\tvar list = rule.list();\n\t\tvar searchFn, nearestItemFn;\n\n\t\tif (isBackward) {\n\t\t\tlist.reverse();\n\t\t\tsearchFn = function searchFn(p) {\n\t\t\t\treturn p.range(true).start <= selRange.start;\n\t\t\t};\n\t\t\tnearestItemFn = function nearestItemFn(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t};\n\t\t} else {\n\t\t\tsearchFn = function searchFn(p) {\n\t\t\t\treturn p.range(true).end >= selRange.end;\n\t\t\t};\n\t\t\tnearestItemFn = function nearestItemFn(r) {\n\t\t\t\treturn r.end > selRange.start;\n\t\t\t};\n\t\t}\n\n\t\t// search for nearest to selection CSS property\n\t\twhile (property = _.find(list, searchFn)) {\n\t\t\tpossibleRanges = makePossibleRangesCSS(property);\n\t\t\tif (isBackward) possibleRanges.reverse();\n\n\t\t\t// check if any possible range is already selected\n\t\t\tcurRange = _.find(possibleRanges, function (r) {\n\t\t\t\treturn r.equal(selRange);\n\t\t\t});\n\n\t\t\tif (!curRange) {\n\t\t\t\t// no selection, select nearest item\n\t\t\t\tvar matchedRanges = _.filter(possibleRanges, function (r) {\n\t\t\t\t\treturn r.inside(selRange.end);\n\t\t\t\t});\n\n\t\t\t\tif (matchedRanges.length > 1) {\n\t\t\t\t\tcurRange = matchedRanges[1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (curRange = _.find(possibleRanges, nearestItemFn)) break;\n\t\t\t} else {\n\t\t\t\tix = _.indexOf(possibleRanges, curRange);\n\t\t\t\tif (ix != possibleRanges.length - 1) {\n\t\t\t\t\tcurRange = possibleRanges[ix + 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurRange = null;\n\t\t\tselRange.start = selRange.end = isBackward ? property.range(true).start - 1 : property.range(true).end + 1;\n\t\t}\n\n\t\treturn curRange;\n\t}\n\n\tfunction findNextCSSItem(editor) {\n\t\treturn findItem(editor, false, require('cssEditTree').extractRule, getRangeForNextItemInCSS);\n\t}\n\n\tfunction findPrevCSSItem(editor) {\n\t\treturn findItem(editor, true, require('cssEditTree').extractRule, getRangeForPrevItemInCSS);\n\t}\n\n\t/**\n  * Returns range for item to be selected in CSS after current caret \n  * (selection) position\n  * @param {String} rule CSS rule declaration\n  * @param {Number} offset Rule's position index inside content\n  * @param {Range} selRange Selection range\n  * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n  */\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\n\t\t// check if selector is matched\n\t\tvar range = tree.nameRange(true);\n\t\tif (selRange.end < range.end) {\n\t\t\treturn range;\n\t\t}\n\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\n\t}\n\n\t/**\n  * Returns range for item to be selected in CSS before current caret \n  * (selection) position\n  * @param {String} rule CSS rule declaration\n  * @param {Number} offset Rule's position index inside content\n  * @param {Range} selRange Selection range\n  * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\n  */\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\n\t\tvar curRange = matchedRangeForCSSProperty(tree, selRange, true);\n\n\t\tif (!curRange) {\n\t\t\t// no matched property, try to match selector\n\t\t\tvar range = tree.nameRange(true);\n\t\t\tif (selRange.start > range.start) {\n\t\t\t\treturn range;\n\t\t\t}\n\t\t}\n\n\t\treturn curRange;\n\t}\n\n\t// XXX register actions\n\tvar actions = require('actions');\n\tactions.add('select_next_item', function (editor) {\n\t\tif (editor.getSyntax() == 'css') return findNextCSSItem(editor);else return findNextHTMLItem(editor);\n\t});\n\n\tactions.add('select_previous_item', function (editor) {\n\t\tif (editor.getSyntax() == 'css') return findPrevCSSItem(editor);else return findPrevHTMLItem(editor);\n\t});\n}); /**\n    * HTML pair matching (balancing) actions\n    * @constructor\n    * @memberOf __matchPairActionDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\tvar matcher = require('htmlMatcher');\n\tvar lastMatch = null;\n\n\t/**\n  * Find and select HTML tag pair\n  * @param {IEmmetEditor} editor Editor instance\n  * @param {String} direction Direction of pair matching: 'in' or 'out'. \n  * Default is 'out'\n  */\n\tfunction matchPair(editor, direction) {\n\t\tdirection = String((direction || 'out').toLowerCase());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\n\t\tvar range = require('range');\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\tvar content = info.content;\n\n\t\t// validate previous match\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\tlastMatch = null;\n\t\t}\n\n\t\tif (lastMatch && sel.length()) {\n\t\t\tif (direction == 'in') {\n\t\t\t\t// user has previously selected tag and wants to move inward\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\n\t\t\t\t\t// unary tag was selected, can't move inward\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar narrowed = require('utils').narrowToNonSpace(content, lastMatch.innerRange);\n\t\t\t\t\t\tlastMatch = matcher.find(content, narrowed.start + 1);\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!lastMatch.innerRange.equal(lastMatch.outerRange) && lastMatch.range.equal(lastMatch.innerRange) && sel.equal(lastMatch.range)) {\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t} else {\n\t\t\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t}\n\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\n\t\t\treturn true;\n\t\t}\n\n\t\tlastMatch = null;\n\t\treturn false;\n\t}\n\n\tactions.add('match_pair', matchPair, { hidden: true });\n\tactions.add('match_pair_inward', function (editor) {\n\t\treturn matchPair(editor, 'in');\n\t}, { label: 'HTML/Match Pair Tag (inward)' });\n\n\tactions.add('match_pair_outward', function (editor) {\n\t\treturn matchPair(editor, 'out');\n\t}, { label: 'HTML/Match Pair Tag (outward)' });\n\n\t/**\n  * Moves caret to matching opening or closing tag\n  * @param {IEmmetEditor} editor\n  */\n\tactions.add('matching_pair', function (editor) {\n\t\tvar content = String(editor.getContent());\n\t\tvar caretPos = editor.getCaretPos();\n\n\t\tif (content.charAt(caretPos) == '<')\n\t\t\t// looks like caret is outside of tag pair  \n\t\t\tcaretPos++;\n\n\t\tvar tag = matcher.tag(content, caretPos);\n\t\tif (tag && tag.close) {\n\t\t\t// exclude unary tags\n\t\t\tif (tag.open.range.inside(caretPos)) {\n\t\t\t\teditor.setCaretPos(tag.close.range.start);\n\t\t\t} else {\n\t\t\t\teditor.setCaretPos(tag.open.range.start);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}, { label: 'HTML/Go To Matching Tag Pair' });\n}); /**\n    * Gracefully removes tag under cursor\n    * \n    * @param {Function} require\n    * @param {Underscore} _ \n    */\nemmet.exec(function (require, _) {\n\trequire('actions').add('remove_tag', function (editor) {\n\t\tvar utils = require('utils');\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\n\t\t// search for tag\n\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\tif (!tag.close) {\n\t\t\t\t// simply remove unary tag\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\n\t\t\t} else {\n\t\t\t\t// remove tag and its newlines\n\t\t\t\t/** @type Range */\n\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\n\t\t\t\t/** @type Range */\n\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\n\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\n\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\n\n\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}, { label: 'HTML/Remove Tag' });\n});\n/**\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\n * &lt;div&gt;&lt;/div&gt;  &lt;div /&gt; : join<br>\n * &lt;div /&gt;  &lt;div&gt;&lt;/div&gt; : split\n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __splitJoinTagAction\n * @constructor\n */\nemmet.exec(function (require, _) {\n\t/**\n  * @param {IEmmetEditor} editor\n  * @param {Object} profile\n  * @param {Object} tag\n  */\n\tfunction joinTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\n\t\t// empty closing slash is a nonsense for this action\n\t\tvar slash = profile.selfClosing() || ' /';\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\n\n\t\tvar caretPos = editor.getCaretPos();\n\n\t\t// update caret position\n\t\tif (content.length + tag.outerRange.start < caretPos) {\n\t\t\tcaretPos = content.length + tag.outerRange.start;\n\t\t}\n\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\n\tfunction splitTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\n\t\tvar nl = utils.getNewline();\n\t\tvar pad = require('resources').getVariable('indentation');\n\t\tvar caretPos = editor.getCaretPos();\n\n\t\t// define tag content depending on profile\n\t\tvar tagContent = profile.tag_nl === true ? nl + pad + nl : '';\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\n\t\tcaretPos = tag.outerRange.start + content.length;\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\n\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\n\trequire('actions').add('split_join_tag', function (editor, profileName) {\n\t\tvar matcher = require('htmlMatcher');\n\n\t\tvar info = require('editorUtils').outputInfo(editor, null, profileName);\n\t\tvar profile = require('profile').get(info.profile);\n\n\t\t// find tag at current position\n\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\treturn tag.close ? joinTag(editor, profile, tag) : splitTag(editor, profile, tag);\n\t\t}\n\n\t\treturn false;\n\t}, { label: 'HTML/Split\\\\Join Tag Declaration' });\n}); /**\n    * Reflect CSS value: takes rule's value under caret and pastes it for the same \n    * rules with vendor prefixes\n    * @constructor\n    * @memberOf __reflectCSSActionDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('reflectCSSValue', function (require, _) {\n\t/**\n  * @type HandlerList List of registered handlers\n  */\n\tvar handlers = require('handlerList').create();\n\n\trequire('actions').add('reflect_css_value', function (editor) {\n\t\tif (editor.getSyntax() != 'css') return false;\n\n\t\treturn require('actionUtils').compoundUpdate(editor, doCSSReflection(editor));\n\t}, { label: 'CSS/Reflect Value' });\n\n\tfunction doCSSReflection(editor) {\n\t\t/** @type emmet.cssEditTree */\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar outputInfo = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\n\t\tif (!cssRule) return;\n\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\n\t\t// no property under cursor, nothing to reflect\n\t\tif (!property) return;\n\n\t\tvar oldRule = cssRule.source;\n\t\tvar offset = cssRule.options.offset;\n\t\tvar caretDelta = caretPos - offset - property.range().start;\n\n\t\thandlers.exec(false, [property]);\n\n\t\tif (oldRule !== cssRule.source) {\n\t\t\treturn {\n\t\t\t\tdata: cssRule.source,\n\t\t\t\tstart: offset,\n\t\t\t\tend: offset + oldRule.length,\n\t\t\t\tcaret: offset + property.range().start + caretDelta\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n  * Returns regexp that should match reflected CSS property names\n  * @param {String} name Current CSS property name\n  * @return {RegExp}\n  */\n\tfunction getReflectedCSSName(name) {\n\t\tname = require('cssEditTree').baseName(name);\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?',\n\t\t    m;\n\n\t\tif (name == 'opacity' || name == 'filter') {\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\n\t\t} else if (m = name.match(/^border-radius-(top|bottom)(left|right)/)) {\n\t\t\t// Mozilla-style border radius\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\n\t\t} else if (m = name.match(/^border-(top|bottom)-(left|right)-radius/)) {\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\n\t\t}\n\n\t\treturn new RegExp(vendorPrefix + name + '$');\n\t}\n\n\t/**\n  * Reflects value from <code>donor</code> into <code>receiver</code>\n  * @param {CSSProperty} donor Donor CSS property from which value should\n  * be reflected\n  * @param {CSSProperty} receiver Property that should receive reflected \n  * value from donor\n  */\n\tfunction reflectValue(donor, receiver) {\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), receiver.name(), receiver.value());\n\n\t\treceiver.value(value);\n\t}\n\n\t/**\n  * Returns value that should be reflected for <code>refName</code> CSS property\n  * from <code>curName</code> property. This function is used for special cases,\n  * when the same result must be achieved with different properties for different\n  * browsers. For example: opcity:0.5;  filter:alpha(opacity=50);<br><br>\n  * \n  * This function does value conversion between different CSS properties\n  * \n  * @param {String} curName Current CSS property name\n  * @param {String} curValue Current CSS property value\n  * @param {String} refName Receiver CSS property's name \n  * @param {String} refValue Receiver CSS property's value\n  * @return {String} New value for receiver property\n  */\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar utils = require('utils');\n\t\tcurName = cssEditTree.baseName(curName);\n\t\trefName = cssEditTree.baseName(refName);\n\n\t\tif (curName == 'opacity' && refName == 'filter') {\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1]) / 100) : refValue;\n\t\t}\n\n\t\treturn curValue;\n\t}\n\n\t// XXX add default handler\n\thandlers.add(function (property) {\n\t\tvar reName = getReflectedCSSName(property.name());\n\t\t_.each(property.parent.list(), function (p) {\n\t\t\tif (reName.test(p.name())) {\n\t\t\t\treflectValue(property, p);\n\t\t\t}\n\t\t});\n\t}, { order: -1 });\n\n\treturn {\n\t\t/**\n   * Adds custom reflect handler. The passed function will receive matched\n   * CSS property (as <code>CSSEditElement</code> object) and should\n   * return <code>true</code> if it was performed successfully (handled \n   * reflection), <code>false</code> otherwise.\n   * @param {Function} fn\n   * @param {Object} options\n   */\n\t\taddHandler: function addHandler(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\n\t\t/**\n   * Removes registered handler\n   * @returns\n   */\n\t\tremoveHandler: function removeHandler(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t}\n\t};\n}); /**\n    * Evaluates simple math expression under caret\n    * @param {Function} require\n    * @param {Underscore} _ \n    */\nemmet.exec(function (require, _) {\n\trequire('actions').add('evaluate_math_expression', function (editor) {\n\t\tvar actionUtils = require('actionUtils');\n\t\tvar utils = require('utils');\n\n\t\tvar content = String(editor.getContent());\n\t\tvar chars = '.+-*/\\\\';\n\n\t\t/** @type Range */\n\t\tvar sel = require('range').create(editor.getSelectionRange());\n\t\tif (!sel.length()) {\n\t\t\tsel = actionUtils.findExpressionBounds(editor, function (ch) {\n\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\n\t\t\t});\n\t\t}\n\n\t\tif (sel && sel.length()) {\n\t\t\tvar expr = sel.substring(content);\n\n\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \n\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'Math.round($1/$2)');\n\n\t\t\ttry {\n\t\t\t\tvar result = utils.prettifyNumber(new Function('return ' + expr)());\n\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\n\t\t\t\teditor.setCaretPos(sel.start + result.length);\n\t\t\t\treturn true;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\treturn false;\n\t}, { label: 'Numbers/Evaluate Math Expression' });\n});\n/**\n * Increment/decrement number under cursor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function (require, _) {\n\t/**\n  * Extract number from current caret position of the <code>editor</code> and\n  * increment it by <code>step</code>\n  * @param {IEmmetEditor} editor\n  * @param {Number} step Increment step (may be negative)\n  */\n\tfunction incrementNumber(editor, step) {\n\t\tvar utils = require('utils');\n\t\tvar actionUtils = require('actionUtils');\n\n\t\tvar hasSign = false;\n\t\tvar hasDecimal = false;\n\n\t\tvar r = actionUtils.findExpressionBounds(editor, function (ch, pos, content) {\n\t\t\tif (utils.isNumeric(ch)) return true;\n\t\t\tif (ch == '.') {\n\t\t\t\t// make sure that next character is numeric too\n\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1))) return false;\n\n\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\n\t\t\t}\n\t\t\tif (ch == '-') return hasSign ? false : hasSign = true;\n\n\t\t\treturn false;\n\t\t});\n\n\t\tif (r && r.length()) {\n\t\t\tvar strNum = r.substring(String(editor.getContent()));\n\t\t\tvar num = parseFloat(strNum);\n\t\t\tif (!_.isNaN(num)) {\n\t\t\t\tnum = utils.prettifyNumber(num + step);\n\n\t\t\t\t// do we have zero-padded number?\n\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\n\t\t\t\t\tvar minus = '';\n\t\t\t\t\tif (RegExp.$1) {\n\t\t\t\t\t\tminus = '-';\n\t\t\t\t\t\tnum = num.substring(1);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar parts = num.split('.');\n\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\n\t\t\t\t\tnum = minus + parts.join('.');\n\t\t\t\t}\n\n\t\t\t\teditor.replaceContent(num, r.start, r.end);\n\t\t\t\teditor.createSelection(r.start, r.start + num.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n  * Returns length of integer part of number\n  * @param {String} num\n  */\n\tfunction intLength(num) {\n\t\tnum = num.replace(/^\\-/, '');\n\t\tif (~num.indexOf('.')) {\n\t\t\treturn num.split('.')[0].length;\n\t\t}\n\n\t\treturn num.length;\n\t}\n\n\tvar actions = require('actions');\n\t_.each([1, -1, 10, -10, 0.1, -0.1], function (num) {\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\n\n\t\tactions.add(prefix + '_number_by_' + String(Math.abs(num)).replace('.', '').substring(0, 2), function (editor) {\n\t\t\treturn incrementNumber(editor, num);\n\t\t}, { label: 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num) });\n\t});\n}); /**\n    * Actions to insert line breaks. Some simple editors (like browser's \n    * &lt;textarea&gt;, for example) do not provide such simple things\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\tvar actions = require('actions');\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\n\t// setup default preferences\n\tprefs.define('css.closeBraceIndentation', '\\n', 'Indentation before closing brace of CSS rule. Some users prefere ' + 'indented closing brace of CSS rule for better readability. ' + 'This preferences value will be automatically inserted before ' + 'closing brace when user adds newline in newly created CSS rule ' + '(e.g. when Insert formatted linebreak action will be performed ' + 'in CSS file). If youre such user, you may want to write put a value ' + 'like <code>\\\\n\\\\t</code> in this preference.');\n\n\t/**\n  * Inserts newline character with proper indentation in specific positions only.\n  * @param {IEmmetEditor} editor\n  * @return {Boolean} Returns <code>true</code> if line break was inserted \n  */\n\tactions.add('insert_formatted_line_break_only', function (editor) {\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.resources */\n\t\tvar res = require('resources');\n\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar nl = utils.getNewline();\n\n\t\tif (_.include(['html', 'xml', 'xsl'], info.syntax)) {\n\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t// let's see if we're breaking newly created tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && !tag.innerRange.length()) {\n\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (info.syntax == 'css') {\n\t\t\t/** @type String */\n\t\t\tvar content = info.content;\n\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\n\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\n\t\t\t\tvar pad = res.getVariable('indentation');\n\n\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\t// do we really need special formatting here?\n\t\t\t\t\t// check if this is really a newly created rule,\n\t\t\t\t\t// look ahead for a closing brace\n\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\n\t\t\t\t\t\tch = content.charAt(i);\n\t\t\t\t\t\tif (ch == '{') {\n\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ch == '}') {\n\t\t\t\t\t\t\t// not a new rule, just add indentation\n\t\t\t\t\t\t\tappend = '';\n\t\t\t\t\t\t\thasCloseBrace = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\tappend += '}';\n\t\t\t\t}\n\n\t\t\t\t// defining rule set\n\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\n\t\t\t\teditor.replaceContent(insValue, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}, { hidden: true });\n\n\t/**\n  * Inserts newline character with proper indentation. This action is used in\n  * editors that doesn't have indentation control (like textarea element) to \n  * provide proper indentation\n  * @param {IEmmetEditor} editor Editor instance\n  */\n\tactions.add('insert_formatted_line_break', function (editor) {\n\t\tif (!actions.run('insert_formatted_line_break_only', editor)) {\n\t\t\tvar utils = require('utils');\n\n\t\t\tvar curPadding = require('editorUtils').getCurrentLinePadding(editor);\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar len = content.length;\n\t\t\tvar nl = utils.getNewline();\n\n\t\t\t// check out next line padding\n\t\t\tvar lineRange = editor.getCurrentLineRange();\n\t\t\tvar nextPadding = '';\n\n\t\t\tfor (var i = lineRange.end + 1, ch; i < len; i++) {\n\t\t\t\tch = content.charAt(i);\n\t\t\t\tif (ch == ' ' || ch == '\\t') nextPadding += ch;else break;\n\t\t\t}\n\n\t\t\tif (nextPadding.length > curPadding.length) editor.replaceContent(nl + nextPadding, caretPos, caretPos, true);else editor.replaceContent(nl, caretPos);\n\t\t}\n\n\t\treturn true;\n\t}, { hidden: true });\n}); /**\n    * Merges selected lines or lines between XHTML tag pairs\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\trequire('actions').add('merge_lines', function (editor) {\n\t\tvar matcher = require('htmlMatcher');\n\t\tvar utils = require('utils');\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar info = editorUtils.outputInfo(editor);\n\n\t\t/** @type Range */\n\t\tvar selection = require('range').create(editor.getSelectionRange());\n\t\tif (!selection.length()) {\n\t\t\t// find matching tag\n\t\t\tvar pair = matcher.find(info.content, editor.getCaretPos());\n\t\t\tif (pair) {\n\t\t\t\tselection = pair.outerRange;\n\t\t\t}\n\t\t}\n\n\t\tif (selection.length()) {\n\t\t\t// got range, merge lines\n\t\t\tvar text = selection.substring(info.content);\n\t\t\tvar lines = utils.splitByLines(text);\n\n\t\t\tfor (var i = 1; i < lines.length; i++) {\n\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\n\t\t\t}\n\n\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\n\t\t\tvar textLen = text.length;\n\t\t\ttext = utils.escapeText(text);\n\t\t\teditor.replaceContent(text, selection.start, selection.end);\n\t\t\teditor.createSelection(selection.start, selection.start + textLen);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t});\n}); /**\n    * Encodes/decodes image under cursor to/from base64\n    * @param {IEmmetEditor} editor\n    * @since 0.65\n    * \n    * @memberOf __base64ActionDefine\n    * @constructor\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\trequire('actions').add('encode_decode_data_url', function (editor) {\n\t\tvar data = String(editor.getSelection());\n\t\tvar caretPos = editor.getCaretPos();\n\n\t\tif (!data) {\n\t\t\t// no selection, try to find image bounds from current caret position\n\t\t\tvar text = String(editor.getContent()),\n\t\t\t    m;\n\t\t\twhile (caretPos-- >= 0) {\n\t\t\t\tif (startsWith('src=', text, caretPos)) {\n\t\t\t\t\t// found <img src=\"\">\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (startsWith('url(', text, caretPos)) {\n\t\t\t\t\t// found CSS url() pattern\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (data) {\n\t\t\tif (startsWith('data:', data)) return decodeFromBase64(editor, data, caretPos);else return encodeToBase64(editor, data, caretPos);\n\t\t}\n\n\t\treturn false;\n\t}, { label: 'Encode\\\\Decode data:URL image' });\n\n\t/**\n  * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\n  * position. If <code>pos</code> is omitted, search from beginning of text \n  * @param {String} token Token to test\n  * @param {String} text Where to search\n  * @param {Number} pos Position where to start search\n  * @return {Boolean}\n  * @since 0.65\n  */\n\tfunction startsWith(token, text, pos) {\n\t\tpos = pos || 0;\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\n\t}\n\n\t/**\n  * Encodes image to base64\n  * \n  * @param {IEmmetEditor} editor\n  * @param {String} imgPath Path to image\n  * @param {Number} pos Caret position where image is located in the editor\n  * @return {Boolean}\n  */\n\tfunction encodeToBase64(editor, imgPath, pos) {\n\t\tvar file = require('file');\n\t\tvar actionUtils = require('actionUtils');\n\n\t\tvar editorFile = editor.getFilePath();\n\t\tvar defaultMimeType = 'application/octet-stream';\n\n\t\tif (editorFile === null) {\n\t\t\tthrow \"You should save your file before using this action\";\n\t\t}\n\n\t\t// locate real image path\n\t\tvar realImgPath = file.locateFile(editorFile, imgPath);\n\t\tif (realImgPath === null) {\n\t\t\tthrow \"Can't find \" + imgPath + ' file';\n\t\t}\n\n\t\tfile.read(realImgPath, function (err, content) {\n\t\t\tif (err) {\n\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\n\t\t\t}\n\n\t\t\tvar b64 = require('base64').encode(String(content));\n\t\t\tif (!b64) {\n\t\t\t\tthrow \"Can't encode file content to base64\";\n\t\t\t}\n\n\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) + ';base64,' + b64;\n\n\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t/**\n  * Decodes base64 string back to file.\n  * @param {IEmmetEditor} editor\n  * @param {String} data Base64-encoded file content\n  * @param {Number} pos Caret position where image is located in the editor\n  */\n\tfunction decodeFromBase64(editor, data, pos) {\n\t\t// ask user to enter path to file\n\t\tvar filePath = String(editor.prompt('Enter path to file (absolute or relative)'));\n\t\tif (!filePath) return false;\n\n\t\tvar file = require('file');\n\t\tvar absPath = file.createPath(editor.getFilePath(), filePath);\n\t\tif (!absPath) {\n\t\t\tthrow \"Can't save file\";\n\t\t}\n\n\t\tfile.save(absPath, require('base64').decode(data.replace(/^data\\:.+?;.+?,/, '')));\n\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\n\t\treturn true;\n\t}\n});\n/**\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\n * CSS rule\n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __updateImageSizeAction\n */\nemmet.exec(function (require, _) {\n\t/**\n  * Updates image size of &lt;img src=\"\"&gt; tag\n  * @param {IEmmetEditor} editor\n  */\n\tfunction updateImageSizeHTML(editor) {\n\t\tvar offset = editor.getCaretPos();\n\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar xmlElem = require('xmlEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function (size) {\n\t\t\t\tif (size) {\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\n\t\t\t\t\txmlElem.value('width', size.width);\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\n\n\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\tdata: xmlElem.toString(),\n\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n  * Updates image size of CSS property\n  * @param {IEmmetEditor} editor\n  */\n\tfunction updateImageSizeCSS(editor) {\n\t\tvar offset = editor.getCaretPos();\n\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (cssRule) {\n\t\t\t// check if there is property with image under caret\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true),\n\t\t\t    m;\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\n\t\t\t\tgetImageSizeForSource(editor, m[2], function (size) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\n\n\t\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\t\tdata: cssRule.toString(),\n\t\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Returns image dimensions for source\n  * @param {IEmmetEditor} editor\n  * @param {String} src Image source (path or data:url)\n  */\n\tfunction getImageSizeForSource(editor, src, callback) {\n\t\tvar fileContent;\n\t\tvar au = require('actionUtils');\n\t\tif (src) {\n\t\t\t// check if it is data:url\n\t\t\tif (/^data:/.test(src)) {\n\t\t\t\tfileContent = require('base64').decode(src.replace(/^data\\:.+?;.+?,/, ''));\n\t\t\t\treturn callback(au.getImageSize(fileContent));\n\t\t\t}\n\n\t\t\tvar file = require('file');\n\t\t\tvar absPath = file.locateFile(editor.getFilePath(), src);\n\t\t\tif (absPath === null) {\n\t\t\t\tthrow \"Can't find \" + src + ' file';\n\t\t\t}\n\n\t\t\tfile.read(absPath, function (err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\n\t\t\t\t}\n\n\t\t\t\tcontent = String(content);\n\t\t\t\tcallback(au.getImageSize(content));\n\t\t\t});\n\t\t}\n\t}\n\n\trequire('actions').add('update_image_size', function (editor) {\n\t\t// this action will definitely wont work in SASS dialect,\n\t\t// but may work in SCSS or LESS\n\t\tif (_.include(['css', 'less', 'scss'], String(editor.getSyntax()))) {\n\t\t\tupdateImageSizeCSS(editor);\n\t\t} else {\n\t\t\tupdateImageSizeHTML(editor);\n\t\t}\n\n\t\treturn true;\n\t});\n}); /**\n    * Resolver for fast CSS typing. Handles abbreviations with the following \n    * notation:<br>\n    * \n    * <code>(-vendor prefix)?property(value)*(!)?</code>\n    * \n    * <br><br>\n    * <b>Abbreviation handling</b><br>\n    * \n    * By default, Emmet searches for matching snippet definition for provided abbreviation.\n    * If snippet wasn't found, Emmet automatically generates element with \n    * abbreviation's name. For example, <code>foo</code> abbreviation will generate\n    * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\n    * <br><br>\n    * This module will capture all expanded properties and upgrade them with values, \n    * vendor prefixes and !important declarations. All unmatched abbreviations will \n    * be automatically transformed into <code>property-name: ${1}</code> snippets. \n    * \n    * <b>Vendor prefixes<b><br>\n    * \n    * If CSS-property is preceded with dash, resolver should output property with\n    * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \n    * abbreviation generates <code>border-radius: ${value};</code> snippet,\n    * the <code>-brad</code> abbreviation should generate:\n    * <pre><code>\n    * -webkit-border-radius: ${value};\n    * -moz-border-radius: ${value};\n    * border-radius: ${value};\n    * </code></pre>\n    * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \n    * supports unprefixed property.<br><br>\n    * \n    * Users can also provide an explicit list of one-character prefixes for any\n    * CSS property. For example, <code>-wm-float</code> will produce\n    * \n    * <pre><code>\n    * -webkit-float: ${1};\n    * -moz-float: ${1};\n    * float: ${1};\n    * </code></pre>\n    * \n    * Although this example looks pointless, users can use this feature to write\n    * cutting-edge properties implemented by browser vendors recently.  \n    * \n    * @constructor\n    * @memberOf __cssResolverDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('cssResolver', function (require, _) {\n\t/** Back-reference to module */\n\tvar module = null;\n\n\tvar prefixObj = {\n\t\t/** Real vendor prefix name */\n\t\tprefix: 'emmet',\n\n\t\t/** \n   * Indicates this prefix is obsolete and should't be used when user \n   * wants to generate all-prefixed properties\n   */\n\t\tobsolete: false,\n\n\t\t/**\n   * Returns prefixed CSS property name\n   * @param {String} name Unprefixed CSS property\n   */\n\t\ttransformName: function transformName(name) {\n\t\t\treturn '-' + this.prefix + '-' + name;\n\t\t},\n\n\t\t/**\n   * List of unprefixed CSS properties that supported by \n   * current prefix. This list is used to generate all-prefixed property\n   * @returns {Array} \n   */\n\t\tproperties: function properties() {\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\n\t\t},\n\n\t\t/**\n   * Check if given property is supported by current prefix\n   * @param name\n   */\n\t\tsupports: function supports(name) {\n\t\t\treturn _.include(this.properties(), name);\n\t\t}\n\t};\n\n\t/** \n  * List of registered one-character prefixes. Key is a one-character prefix, \n  * value is an <code>prefixObj</code> object\n  */\n\tvar vendorPrefixes = {};\n\n\tvar defaultValue = '${1};';\n\n\t// XXX module preferences\n\tvar prefs = require('preferences');\n\tprefs.define('css.valueSeparator', ': ', 'Defines a symbol that should be placed between CSS property and ' + 'value when expanding CSS abbreviations.');\n\tprefs.define('css.propertyEnd', ';', 'Defines a symbol that should be placed at the end of CSS property  ' + 'when expanding CSS abbreviations.');\n\n\tprefs.define('stylus.valueSeparator', ' ', 'Defines a symbol that should be placed between CSS property and ' + 'value when expanding CSS abbreviations in Stylus dialect.');\n\tprefs.define('stylus.propertyEnd', '', 'Defines a symbol that should be placed at the end of CSS property  ' + 'when expanding CSS abbreviations in Stylus dialect.');\n\n\tprefs.define('sass.propertyEnd', '', 'Defines a symbol that should be placed at the end of CSS property  ' + 'when expanding CSS abbreviations in SASS dialect.');\n\n\tprefs.define('css.autoInsertVendorPrefixes', true, 'Automatically generate vendor-prefixed copies of expanded CSS ' + 'property. By default, Emmet will generate vendor-prefixed ' + 'properties only when you put dash before abbreviation ' + '(e.g. <code>-bxsh</code>). With this option enabled, you dont ' + 'need dashes before abbreviations: Emmet will produce ' + 'vendor-prefixed properties for you.');\n\n\tvar descTemplate = _.template('A comma-separated list of CSS properties that may have ' + '<code><%= vendor %></code> vendor prefix. This list is used to generate ' + 'a list of prefixed properties when expanding <code>-property</code> ' + 'abbreviations. Empty list means that all possible CSS values may ' + 'have <code><%= vendor %></code> prefix.');\n\n\tvar descAddonTemplate = _.template('A comma-separated list of <em>additional</em> CSS properties ' + 'for <code>css.<%= vendor %>Preperties</code> preference. ' + 'You should use this list if you want to add or remove a few CSS ' + 'properties to original set. To add a new property, simply write its name, ' + 'to remove it, precede property with hyphen.<br>' + 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, ' + 'the preference value will look like this: <code>foo, -border-radius</code>.');\n\n\t// properties list is created from cssFeatures.html file\n\tvar props = {\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, word-wrap, wrap-flow, wrap-margin, wrap-through, writing-mode',\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\n\t};\n\n\t_.each(props, function (v, k) {\n\t\tprefs.define('css.' + k + 'Properties', v, descTemplate({ vendor: k }));\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({ vendor: k }));\n\t});\n\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', 'The list of properties whose values must not contain units.');\n\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\n\n\tprefs.define('css.keywords', 'auto, inherit', 'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\n\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', 'A comma-separated list of keyword aliases, used in CSS abbreviation. ' + 'Each alias should be defined as <code>alias:keyword_name</code>.');\n\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', 'A comma-separated list of unit aliases, used in CSS abbreviation. ' + 'Each alias should be defined as <code>alias:unit_value</code>.');\n\n\tprefs.define('css.color.short', true, 'Should color values like <code>#ffffff</code> be shortened to ' + '<code>#fff</code> after abbreviation with color was expanded.');\n\n\tprefs.define('css.color.case', 'keep', 'Letter case of color values generated by abbreviations with color ' + '(like <code>c#0</code>). Possible values are <code>upper</code>, ' + '<code>lower</code> and <code>keep</code>.');\n\n\tprefs.define('css.fuzzySearch', true, 'Enable fuzzy search among CSS snippet names. When enabled, every ' + '<em>unknown</em> snippet will be scored against available snippet ' + 'names (not values or CSS properties!). The match with best score ' + 'will be used to resolve snippet value. For example, with this ' + 'preference enabled, the following abbreviations are equal: ' + '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == ' + '<code>oh</code>');\n\n\tprefs.define('css.fuzzySearchMinScore', 0.3, 'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' + 'achive. Lower values may produce many false-positive matches, ' + 'higher values may reduce possible matches.');\n\n\tprefs.define('css.alignVendor', false, 'If set to <code>true</code>, all generated vendor-prefixed properties ' + 'will be aligned by real property name.');\n\n\tfunction isNumeric(ch) {\n\t\tvar code = ch && ch.charCodeAt(0);\n\t\treturn ch && ch == '.' || code > 47 && code < 58;\n\t}\n\n\t/**\n  * Check if provided snippet contains only one CSS property and value.\n  * @param {String} snippet\n  * @returns {Boolean}\n  */\n\tfunction isSingleProperty(snippet) {\n\t\tvar utils = require('utils');\n\t\tsnippet = utils.trim(snippet);\n\n\t\t// check if it doesn't contain a comment and a newline\n\t\tif (~snippet.indexOf('/*') || /[\\n\\r]/.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// check if it's a valid snippet definition\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tsnippet = require('tabStops').processText(snippet, {\n\t\t\treplaceCarets: true,\n\t\t\ttabstop: function tabstop() {\n\t\t\t\treturn 'value';\n\t\t\t}\n\t\t});\n\n\t\treturn snippet.split(':').length == 2;\n\t}\n\n\t/**\n  * Normalizes abbreviated value to final CSS one\n  * @param {String} value\n  * @returns {String}\n  */\n\tfunction normalizeValue(value) {\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\n\t\t\tvalue = value.replace(/^\\-+/, '');\n\t\t}\n\n\t\tif (value.charAt(0) == '#') {\n\t\t\treturn normalizeHexColor(value);\n\t\t}\n\n\t\treturn getKeyword(value);\n\t}\n\n\tfunction normalizeHexColor(value) {\n\t\tvar hex = value.replace(/^#+/, '') || '0';\n\t\tif (hex.toLowerCase() == 't') {\n\t\t\treturn 'transparent';\n\t\t}\n\n\t\tvar repeat = require('utils').repeatString;\n\t\tvar color = null;\n\t\tswitch (hex.length) {\n\t\t\tcase 1:\n\t\t\t\tcolor = repeat(hex, 6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcolor = repeat(hex, 3);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcolor = hex + hex.substr(0, 2);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcolor = hex + hex.charAt(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcolor = hex.substr(0, 6);\n\t\t}\n\n\t\t// color must be shortened?\n\t\tif (prefs.get('css.color.short')) {\n\t\t\tvar p = color.split('');\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\n\t\t\t\tcolor = p[0] + p[2] + p[4];\n\t\t\t}\n\t\t}\n\n\t\t// should transform case?\n\t\tswitch (prefs.get('css.color.case')) {\n\t\t\tcase 'upper':\n\t\t\t\tcolor = color.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase 'lower':\n\t\t\t\tcolor = color.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn '#' + color;\n\t}\n\n\tfunction getKeyword(name) {\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\n\tfunction getUnit(name) {\n\t\tvar aliases = prefs.getDict('css.unitAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\n\tfunction isValidKeyword(keyword) {\n\t\treturn _.include(prefs.getArray('css.keywords'), getKeyword(keyword));\n\t}\n\n\t/**\n  * Check if passed CSS property support specified vendor prefix \n  * @param {String} property\n  * @param {String} prefix\n  */\n\tfunction hasPrefix(property, prefix) {\n\t\tvar info = vendorPrefixes[prefix];\n\n\t\tif (!info) info = _.find(vendorPrefixes, function (data) {\n\t\t\treturn data.prefix == prefix;\n\t\t});\n\n\t\treturn info && info.supports(property);\n\t}\n\n\t/**\n  * Search for a list of supported prefixes for CSS property. This list\n  * is used to generate all-prefixed snippet\n  * @param {String} property CSS property name\n  * @returns {Array}\n  */\n\tfunction findPrefixes(property, noAutofill) {\n\t\tvar result = [];\n\t\t_.each(vendorPrefixes, function (obj, prefix) {\n\t\t\tif (hasPrefix(property, prefix)) {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t});\n\n\t\tif (!result.length && !noAutofill) {\n\t\t\t// add all non-obsolete prefixes\n\t\t\t_.each(vendorPrefixes, function (obj, prefix) {\n\t\t\t\tif (!obj.obsolete) result.push(prefix);\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction addPrefix(name, obj) {\n\t\tif (_.isString(obj)) obj = { prefix: obj };\n\n\t\tvendorPrefixes[name] = _.extend({}, prefixObj, obj);\n\t}\n\n\tfunction getSyntaxPreference(name, syntax) {\n\t\tif (syntax) {\n\t\t\tvar val = prefs.get(syntax + '.' + name);\n\t\t\tif (!_.isUndefined(val)) return val;\n\t\t}\n\n\t\treturn prefs.get('css.' + name);\n\t}\n\n\t/**\n  * Format CSS property according to current syntax dialect\n  * @param {String} property\n  * @param {String} syntax\n  * @returns {String}\n  */\n\tfunction formatProperty(property, syntax) {\n\t\tvar ix = property.indexOf(':');\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') + getSyntaxPreference('valueSeparator', syntax) + require('utils').trim(property.substring(ix + 1));\n\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\n\t}\n\n\t/**\n  * Transforms snippet value if required. For example, this transformation\n  * may add <i>!important</i> declaration to CSS property\n  * @param {String} snippet\n  * @param {Boolean} isImportant\n  * @returns {String}\n  */\n\tfunction transformSnippet(snippet, isImportant, syntax) {\n\t\tif (!_.isString(snippet)) snippet = snippet.data;\n\n\t\tif (!isSingleProperty(snippet)) return snippet;\n\n\t\tif (isImportant) {\n\t\t\tif (~snippet.indexOf(';')) {\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\n\t\t\t} else {\n\t\t\t\tsnippet += ' !important';\n\t\t\t}\n\t\t}\n\n\t\treturn formatProperty(snippet, syntax);\n\t}\n\n\t/**\n  * Helper function that parses comma-separated list of elements into array\n  * @param {String} list\n  * @returns {Array}\n  */\n\tfunction parseList(list) {\n\t\tvar result = _.map((list || '').split(','), require('utils').trim);\n\t\treturn result.length ? result : null;\n\t}\n\n\tfunction getProperties(key) {\n\t\tvar list = prefs.getArray(key);\n\t\t_.each(prefs.getArray(key + 'Addon'), function (prop) {\n\t\t\tif (prop.charAt(0) == '-') {\n\t\t\t\tlist = _.without(list, prop.substr(1));\n\t\t\t} else {\n\t\t\t\tif (prop.charAt(0) == '+') prop = prop.substr(1);\n\n\t\t\t\tlist.push(prop);\n\t\t\t}\n\t\t});\n\n\t\treturn list;\n\t}\n\n\t// TODO refactor, this looks awkward now\n\taddPrefix('w', {\n\t\tprefix: 'webkit'\n\t});\n\taddPrefix('m', {\n\t\tprefix: 'moz'\n\t});\n\taddPrefix('s', {\n\t\tprefix: 'ms'\n\t});\n\taddPrefix('o', {\n\t\tprefix: 'o'\n\t});\n\n\t// I think nobody uses it\n\t//\taddPrefix('k', {\n\t//\t\tprefix: 'khtml',\n\t//\t\tobsolete: true\n\t//\t});\n\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus'];\n\n\t/**\n  * XXX register resolver\n  * @param {TreeNode} node\n  * @param {String} syntax\n  */\n\trequire('resources').addResolver(function (node, syntax) {\n\t\tif (_.include(cssSyntaxes, syntax) && node.isElement()) {\n\t\t\treturn module.expandToSnippet(node.abbreviation, syntax);\n\t\t}\n\n\t\treturn null;\n\t});\n\n\tvar ea = require('expandAbbreviation');\n\t/**\n  * For CSS-like syntaxes, we need to handle a special use case. Some editors\n  * (like Sublime Text 2) may insert semicolons automatically when user types\n  * abbreviation. After expansion, user receives a double semicolon. This\n  * handler automatically removes semicolon from generated content in such cases.\n  * @param {IEmmetEditor} editor\n  * @param {String} syntax\n  * @param {String} profile\n  */\n\tea.addHandler(function (editor, syntax, profile) {\n\t\tif (!_.include(cssSyntaxes, syntax)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = ea.findAbbreviation(editor);\n\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile);\n\t\t\tif (content) {\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\n\t\t\t\tvar replaceTo = caretPos;\n\t\t\t\tif (editor.getContent().charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\n\t\t\t\t\treplaceTo++;\n\t\t\t\t}\n\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t});\n\n\treturn module = {\n\t\t/**\n   * Adds vendor prefix\n   * @param {String} name One-character prefix name\n   * @param {Object} obj Object describing vendor prefix\n   * @memberOf cssResolver\n   */\n\t\taddPrefix: addPrefix,\n\n\t\t/**\n   * Check if passed CSS property supports specified vendor prefix\n   * @param {String} property\n   * @param {String} prefix\n   */\n\t\tsupportsPrefix: hasPrefix,\n\n\t\t/**\n   * Returns prefixed version of passed CSS property, only if this\n   * property supports such prefix\n   * @param {String} property\n   * @param {String} prefix\n   * @returns\n   */\n\t\tprefixed: function prefixed(property, prefix) {\n\t\t\treturn hasPrefix(property, prefix) ? '-' + prefix + '-' + property : property;\n\t\t},\n\n\t\t/**\n   * Returns list of all registered vendor prefixes\n   * @returns {Array}\n   */\n\t\tlistPrefixes: function listPrefixes() {\n\t\t\treturn _.map(vendorPrefixes, function (obj) {\n\t\t\t\treturn obj.prefix;\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Returns object describing vendor prefix\n   * @param {String} name\n   * @returns {Object}\n   */\n\t\tgetPrefix: function getPrefix(name) {\n\t\t\treturn vendorPrefixes[name];\n\t\t},\n\n\t\t/**\n   * Removes prefix object\n   * @param {String} name\n   */\n\t\tremovePrefix: function removePrefix(name) {\n\t\t\tif (name in vendorPrefixes) delete vendorPrefixes[name];\n\t\t},\n\n\t\t/**\n   * Extract vendor prefixes from abbreviation\n   * @param {String} abbr\n   * @returns {Object} Object containing array of prefixes and clean \n   * abbreviation name\n   */\n\t\textractPrefixes: function extractPrefixes(abbr) {\n\t\t\tif (abbr.charAt(0) != '-') {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tprefixes: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\n\t\t\t// or just dash, meaning that user wants to produce all possible\n\t\t\t// prefixed properties\n\t\t\tvar i = 1,\n\t\t\t    il = abbr.length,\n\t\t\t    ch;\n\t\t\tvar prefixes = [];\n\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (ch == '-') {\n\t\t\t\t\t// end-sequence character found, stop searching\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (ch in vendorPrefixes) {\n\t\t\t\t\tprefixes.push(ch);\n\t\t\t\t} else {\n\t\t\t\t\t// no prefix found, meaning user want to produce all\n\t\t\t\t\t// vendor-prefixed properties\n\t\t\t\t\tprefixes.length = 0;\n\t\t\t\t\ti = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// reached end of abbreviation and no property name left\n\t\t\tif (i == il - 1) {\n\t\t\t\ti = 1;\n\t\t\t\tprefixes.length = 1;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(i),\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\n\t\t\t};\n\t\t},\n\n\t\t/**\n   * Search for value substring in abbreviation\n   * @param {String} abbr\n   * @returns {String} Value substring\n   */\n\t\tfindValuesInAbbreviation: function findValuesInAbbreviation(abbr, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\n\t\t\tvar i = 0,\n\t\t\t    il = abbr.length,\n\t\t\t    value = '',\n\t\t\t    ch;\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (isNumeric(ch) || ch == '#' || ch == '-' && isNumeric(abbr.charAt(i + 1))) {\n\t\t\t\t\tvalue = abbr.substring(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// try to find keywords in abbreviation\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\n\t\t\tvar res = require('resources');\n\t\t\tvar keywords = [];\n\t\t\t// try to extract some commonly-used properties\n\t\t\twhile (~property.indexOf('-') && !res.findSnippet(syntax, property)) {\n\t\t\t\tvar parts = property.split('-');\n\t\t\t\tvar lastPart = parts.pop();\n\t\t\t\tif (!isValidKeyword(lastPart)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tkeywords.unshift(lastPart);\n\t\t\t\tproperty = parts.join('-');\n\t\t\t}\n\n\t\t\treturn keywords.join('-') + value;\n\t\t},\n\n\t\tparseValues: function parseValues(str) {\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(str);\n\t\t\tvar values = [];\n\t\t\tvar ch = null;\n\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '#') {\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+/i, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else if (ch == '-') {\n\t\t\t\t\tif (isValidKeyword(_.last(values)) || stream.start && isNumeric(str.charAt(stream.start - 1))) {\n\t\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\t}\n\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else {\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t}\n\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\n\t\t\treturn _.map(_.compact(values), normalizeValue);\n\t\t},\n\n\t\t/**\n   * Extracts values from abbreviation\n   * @param {String} abbr\n   * @returns {Object} Object containing array of values and clean \n   * abbreviation name\n   */\n\t\textractValues: function extractValues(abbr) {\n\t\t\t// search for value start\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\n\t\t\tif (!abbrValues) {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tvalues: null\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\n\t\t\t\tvalues: this.parseValues(abbrValues)\n\t\t\t};\n\t\t},\n\n\t\t/**\n   * Normalizes value, defined in abbreviation.\n   * @param {String} value\n   * @param {String} property\n   * @returns {String}\n   */\n\t\tnormalizeValue: function normalizeValue(value, property) {\n\t\t\tproperty = (property || '').toLowerCase();\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function (str, val, unit) {\n\t\t\t\tif (!unit && (val == '0' || _.include(unitlessProps, property))) return val;\n\n\t\t\t\tif (!unit) return val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\n\n\t\t\t\treturn val + getUnit(unit);\n\t\t\t});\n\t\t},\n\n\t\t/**\n   * Expands abbreviation into a snippet\n   * @param {String} abbr Abbreviation name to expand\n   * @param {String} value Abbreviation value\n   * @param {String} syntax Currect syntax or dialect. Default is 'css'\n   * @returns {Object} Array of CSS properties and values or predefined\n   * snippet (string or element)\n   */\n\t\texpand: function expand(abbr, value, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\tvar resources = require('resources');\n\t\t\tvar autoInsertPrefixes = prefs.get('css.autoInsertVendorPrefixes');\n\n\t\t\t// check if snippet should be transformed to !important\n\t\t\tvar isImportant;\n\t\t\tif (isImportant = /^(.+)\\!$/.test(abbr)) {\n\t\t\t\tabbr = RegExp.$1;\n\t\t\t}\n\n\t\t\t// check if we have abbreviated resource\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\n\t\t\tif (snippet && !autoInsertPrefixes) {\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\n\t\t\t}\n\n\t\t\t// no abbreviated resource, parse abbreviation\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\n\t\t\tvar abbrData = _.extend(prefixData, valuesData);\n\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\n\t\t\t} else {\n\t\t\t\tabbrData.values = null;\n\t\t\t}\n\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\t\t// lets try fuzzy search\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t\t}\n\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\n\t\t\t} else if (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\n\t\t\tif (!isSingleProperty(snippet)) {\n\t\t\t\treturn snippet;\n\t\t\t}\n\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\n\t\t\tvar result = [];\n\t\t\tif (!value && abbrData.values) {\n\t\t\t\tvalue = _.map(abbrData.values, function (val) {\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\n\t\t\t\t}, this).join(' ') + ';';\n\t\t\t}\n\n\t\t\tsnippetObj.value = value || snippetObj.value;\n\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || !abbrData.prefixes && autoInsertPrefixes ? findPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all') : abbrData.prefixes;\n\n\t\t\tvar names = [],\n\t\t\t    propName;\n\t\t\t_.each(prefixes, function (p) {\n\t\t\t\tif (p in vendorPrefixes) {\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\n\t\t\t\t\tnames.push(propName);\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value, isImportant, syntax));\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// put the original property\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\n\t\t\tnames.push(snippetObj.name);\n\n\t\t\tif (prefs.get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(names);\n\t\t\t\tresult = _.map(result, function (prop, i) {\n\t\t\t\t\treturn pads[i] + prop;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n   * Same as <code>expand</code> method but transforms output into \n   * Emmet snippet\n   * @param {String} abbr\n   * @param {String} syntax\n   * @returns {String}\n   */\n\t\texpandToSnippet: function expandToSnippet(abbr, syntax) {\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\n\t\t\tif (_.isArray(snippet)) {\n\t\t\t\treturn snippet.join('\\n');\n\t\t\t}\n\n\t\t\tif (!_.isString(snippet)) return snippet.data;\n\n\t\t\treturn String(snippet);\n\t\t},\n\n\t\t/**\n   * Split snippet into a CSS property-value pair\n   * @param {String} snippet\n   */\n\t\tsplitSnippet: function splitSnippet(snippet) {\n\t\t\tvar utils = require('utils');\n\t\t\tsnippet = utils.trim(snippet);\n\t\t\tif (snippet.indexOf(':') == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tname: snippet,\n\t\t\t\t\tvalue: defaultValue\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar pair = snippet.split(':');\n\n\t\t\treturn {\n\t\t\t\tname: utils.trim(pair.shift()),\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\n\t\t\t\t// where possible\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\n\t\t\t};\n\t\t},\n\n\t\tgetSyntaxPreference: getSyntaxPreference,\n\t\ttransformSnippet: transformSnippet\n\t};\n});\n/**\n * 'Expand Abbreviation' handler that parses gradient definition from under \n * cursor and updates CSS rule with vendor-prefixed values.\n * \n * @memberOf __cssGradientHandlerDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssGradient', function (require, _) {\n\tvar defaultLinearDirections = ['top', 'to bottom', '0deg'];\n\t/** Back-reference to current module */\n\tvar module = null;\n\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\n\n\tvar reDeg = /\\d+deg/i;\n\tvar reKeyword = /top|bottom|left|right/i;\n\n\t// XXX define preferences\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o', 'A comma-separated list of vendor-prefixes for which values should ' + 'be generated.');\n\n\tprefs.define('css.gradient.oldWebkit', true, 'Generate gradient definition for old Webkit implementations');\n\n\tprefs.define('css.gradient.omitDefaultDirection', true, 'Do not output default direction definition in generated gradients.');\n\n\tprefs.define('css.gradient.defaultProperty', 'background-image', 'When gradient expanded outside CSS value context, it will produce ' + 'properties with this name.');\n\n\tprefs.define('css.gradient.fallback', false, 'With this option enabled, CSS gradient generator will produce ' + '<code>background-color</code> property with gradient first color ' + 'as fallback for old browsers.');\n\n\tfunction normalizeSpace(str) {\n\t\treturn require('utils').trim(str).replace(/\\s+/g, ' ');\n\t}\n\n\t/**\n  * Parses linear gradient definition\n  * @param {String}\n  */\n\tfunction parseLinearGradient(gradient) {\n\t\tvar direction = defaultLinearDirections[0];\n\n\t\t// extract tokens\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(require('utils').trim(gradient));\n\t\tvar colorStops = [],\n\t\t    ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (stream.peek() == ',') {\n\t\t\t\tcolorStops.push(stream.current());\n\t\t\t\tstream.next();\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t} else if (ch == '(') {\n\t\t\t\t// color definition, like 'rgb(0,0,0)'\n\t\t\t\tstream.skipTo(')');\n\t\t\t}\n\t\t}\n\n\t\t// add last token\n\t\tcolorStops.push(stream.current());\n\t\tcolorStops = _.compact(_.map(colorStops, normalizeSpace));\n\n\t\tif (!colorStops.length) return null;\n\n\t\t// let's see if the first color stop is actually a direction\n\t\tif (reDeg.test(colorStops[0]) || reKeyword.test(colorStops[0])) {\n\t\t\tdirection = colorStops.shift();\n\t\t}\n\n\t\treturn {\n\t\t\ttype: 'linear',\n\t\t\tdirection: direction,\n\t\t\tcolorStops: _.map(colorStops, parseColorStop)\n\t\t};\n\t}\n\n\t/**\n  * Parses color stop definition\n  * @param {String} colorStop\n  * @returns {Object}\n  */\n\tfunction parseColorStop(colorStop) {\n\t\tcolorStop = normalizeSpace(colorStop);\n\n\t\t// find color declaration\n\t\t// first, try complex color declaration, like rgb(0,0,0)\n\t\tvar color = null;\n\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function (str, c) {\n\t\t\tcolor = c;\n\t\t\treturn '';\n\t\t});\n\n\t\tif (!color) {\n\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\n\t\t\tvar parts = colorStop.split(' ');\n\t\t\tcolor = parts[0];\n\t\t\tcolorStop = parts[1] || '';\n\t\t}\n\n\t\tvar result = {\n\t\t\tcolor: color\n\t\t};\n\n\t\tif (colorStop) {\n\t\t\t// there's position in color stop definition\n\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function (str, pos, unit) {\n\t\t\t\tresult.position = pos;\n\t\t\t\tif (~pos.indexOf('.')) {\n\t\t\t\t\tunit = '';\n\t\t\t\t} else if (!unit) {\n\t\t\t\t\tunit = '%';\n\t\t\t\t}\n\n\t\t\t\tif (unit) result.unit = unit;\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n  * Resolves property name (abbreviation): searches for snippet definition in \n  * 'resources' and returns new name of matched property\n  */\n\tfunction resolvePropertyName(name, syntax) {\n\t\tvar res = require('resources');\n\t\tvar prefs = require('preferences');\n\t\tvar snippet = res.findSnippet(syntax, name);\n\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\tsnippet = res.fuzzyFindSnippet(syntax, name, parseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t}\n\n\t\tif (snippet) {\n\t\t\tif (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\n\t\t\treturn require('cssResolver').splitSnippet(snippet).name;\n\t\t}\n\t}\n\n\t/**\n  * Fills-out implied positions in color-stops. This function is useful for\n  * old Webkit gradient definitions\n  */\n\tfunction fillImpliedPositions(colorStops) {\n\t\tvar from = 0;\n\n\t\t_.each(colorStops, function (cs, i) {\n\t\t\t// make sure that first and last positions are defined\n\t\t\tif (!i) return cs.position = cs.position || 0;\n\n\t\t\tif (i == colorStops.length - 1 && !('position' in cs)) cs.position = 1;\n\n\t\t\tif ('position' in cs) {\n\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t_.each(colorStops.slice(from, i), function (cs2, j) {\n\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t});\n\n\t\t\t\tfrom = i;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n  * Returns textual version of direction expressed in degrees\n  * @param {String} direction\n  * @returns {String}\n  */\n\tfunction textualDirection(direction) {\n\t\tvar angle = parseFloat(direction);\n\n\t\tif (!_.isNaN(angle)) {\n\t\t\tswitch (angle % 360) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn 'left';\n\t\t\t\tcase 90:\n\t\t\t\t\treturn 'bottom';\n\t\t\t\tcase 180:\n\t\t\t\t\treturn 'right';\n\t\t\t\tcase 240:\n\t\t\t\t\treturn 'top';\n\t\t\t}\n\t\t}\n\n\t\treturn direction;\n\t}\n\n\t/**\n  * Creates direction definition for old Webkit gradients\n  * @param {String} direction\n  * @returns {String}\n  */\n\tfunction oldWebkitDirection(direction) {\n\t\tdirection = textualDirection(direction);\n\n\t\tif (reDeg.test(direction)) throw \"The direction is an angle that cant be converted.\";\n\n\t\tvar v = function v(pos) {\n\t\t\treturn ~direction.indexOf(pos) ? '100%' : '0';\n\t\t};\n\n\t\treturn v('right') + ' ' + v('bottom') + ', ' + v('left') + ' ' + v('top');\n\t}\n\n\tfunction getPrefixedNames(name) {\n\t\tvar prefixes = prefs.getArray('css.gradient.prefixes');\n\t\tvar names = prefixes ? _.map(prefixes, function (p) {\n\t\t\treturn '-' + p + '-' + name;\n\t\t}) : [];\n\n\t\tnames.push(name);\n\n\t\treturn names;\n\t}\n\n\t/**\n  * Returns list of CSS properties with gradient\n  * @param {Object} gradient\n  * @param {String} propertyName Original CSS property name\n  * @returns {Array}\n  */\n\tfunction getPropertiesForGradient(gradient, propertyName) {\n\t\tvar props = [];\n\t\tvar css = require('cssResolver');\n\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\n\t\t\tprops.push({\n\t\t\t\tname: 'background-color',\n\t\t\t\tvalue: '${1:' + gradient.colorStops[0].color + '}'\n\t\t\t});\n\t\t}\n\n\t\t_.each(prefs.getArray('css.gradient.prefixes'), function (prefix) {\n\t\t\tvar name = css.prefixed(propertyName, prefix);\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\n\t\t\t\ttry {\n\t\t\t\t\tprops.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: module.oldWebkitLinearGradient(gradient)\n\t\t\t\t\t});\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\tprops.push({\n\t\t\t\tname: name,\n\t\t\t\tvalue: module.toString(gradient, prefix)\n\t\t\t});\n\t\t});\n\n\t\treturn props.sort(function (a, b) {\n\t\t\treturn b.name.length - a.name.length;\n\t\t});\n\t}\n\n\t/**\n  * Pastes gradient definition into CSS rule with correct vendor-prefixes\n  * @param {EditElement} property Matched CSS property\n  * @param {Object} gradient Parsed gradient\n  * @param {Range} valueRange If passed, only this range within property \n  * value will be replaced with gradient. Otherwise, full value will be \n  * replaced\n  */\n\tfunction pasteGradient(property, gradient, valueRange) {\n\t\tvar rule = property.parent;\n\t\tvar utils = require('utils');\n\t\tvar alignVendor = require('preferences').get('css.alignVendor');\n\n\t\t// we may have aligned gradient definitions: find the smallest value\n\t\t// separator\n\t\tvar sep = property.styleSeparator;\n\t\tvar before = property.styleBefore;\n\n\t\t// first, remove all properties within CSS rule with the same name and\n\t\t// gradient definition\n\t\t_.each(rule.getAll(getPrefixedNames(property.name())), function (item) {\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\n\t\t\t\t\tsep = item.styleSeparator;\n\t\t\t\t}\n\t\t\t\tif (item.styleBefore.length < before.length) {\n\t\t\t\t\tbefore = item.styleBefore;\n\t\t\t\t}\n\t\t\t\trule.remove(item);\n\t\t\t}\n\t\t});\n\n\t\tif (alignVendor) {\n\t\t\t// update prefix\n\t\t\tif (before != property.styleBefore) {\n\t\t\t\tvar fullRange = property.fullRange();\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\n\t\t\t\tproperty.styleBefore = before;\n\t\t\t}\n\n\t\t\t// update separator value\n\t\t\tif (sep != property.styleSeparator) {\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\n\t\t\t\tproperty.styleSeparator = sep;\n\t\t\t}\n\t\t}\n\n\t\tvar value = property.value();\n\t\tif (!valueRange) valueRange = require('range').create(0, property.value());\n\n\t\tvar val = function val(v) {\n\t\t\treturn utils.replaceSubstring(value, v, valueRange);\n\t\t};\n\n\t\t// put vanilla-clean gradient definition into current rule\n\t\tproperty.value(val(module.toString(gradient)) + '${2}');\n\n\t\t// create list of properties to insert\n\t\tvar propsToInsert = getPropertiesForGradient(gradient, property.name());\n\n\t\t// align prefixed values\n\t\tif (alignVendor) {\n\t\t\tvar values = _.pluck(propsToInsert, 'value');\n\t\t\tvar names = _.pluck(propsToInsert, 'name');\n\t\t\tvalues.push(property.value());\n\t\t\tnames.push(property.name());\n\n\t\t\tvar valuePads = utils.getStringsPads(_.map(values, function (v) {\n\t\t\t\treturn v.substring(0, v.indexOf('('));\n\t\t\t}));\n\n\t\t\tvar namePads = utils.getStringsPads(names);\n\t\t\tproperty.name(_.last(namePads) + property.name());\n\n\t\t\t_.each(propsToInsert, function (prop, i) {\n\t\t\t\tprop.name = namePads[i] + prop.name;\n\t\t\t\tprop.value = valuePads[i] + prop.value;\n\t\t\t});\n\n\t\t\tproperty.value(_.last(valuePads) + property.value());\n\t\t}\n\n\t\t// put vendor-prefixed definitions before current rule\n\t\t_.each(propsToInsert, function (prop) {\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\n\t\t});\n\t}\n\n\t/**\n  * Search for gradient definition inside CSS property value\n  */\n\tfunction findGradient(cssProp) {\n\t\tvar value = cssProp.value();\n\t\tvar gradient = null;\n\t\tvar matchedPart = _.find(cssProp.valueParts(), function (part) {\n\t\t\treturn gradient = module.parse(part.substring(value));\n\t\t});\n\n\t\tif (matchedPart && gradient) {\n\t\t\treturn {\n\t\t\t\tgradient: gradient,\n\t\t\t\tvalueRange: matchedPart\n\t\t\t};\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n  * Tries to expand gradient outside CSS value \n  * @param {IEmmetEditor} editor\n  * @param {String} syntax\n  */\n\tfunction expandGradientOutsideValue(editor, syntax) {\n\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\n\n\t\tif (!propertyName) return false;\n\n\t\t// assuming that gradient definition is written on new line,\n\t\t// do a simplified parsing\n\t\tvar content = String(editor.getContent());\n\t\t/** @type Range */\n\t\tvar lineRange = require('range').create(editor.getCurrentLineRange());\n\n\t\t// get line content and adjust range with padding\n\t\tvar line = lineRange.substring(content).replace(/^\\s+/, function (pad) {\n\t\t\tlineRange.start += pad.length;\n\t\t\treturn '';\n\t\t}).replace(/\\s+$/, function (pad) {\n\t\t\tlineRange.end -= pad.length;\n\t\t\treturn '';\n\t\t});\n\n\t\tvar css = require('cssResolver');\n\t\tvar gradient = module.parse(line);\n\t\tif (gradient) {\n\t\t\tvar props = getPropertiesForGradient(gradient, propertyName);\n\t\t\tprops.push({\n\t\t\t\tname: propertyName,\n\t\t\t\tvalue: module.toString(gradient) + '${2}'\n\t\t\t});\n\n\t\t\tvar sep = css.getSyntaxPreference('valueSeparator', syntax);\n\t\t\tvar end = css.getSyntaxPreference('propertyEnd', syntax);\n\n\t\t\tif (require('preferences').get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(_.map(props, function (prop) {\n\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\n\t\t\t\t}));\n\t\t\t\t_.each(props, function (prop, i) {\n\t\t\t\t\tprop.value = pads[i] + prop.value;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tprops = _.map(props, function (item) {\n\t\t\t\treturn item.name + sep + item.value + end;\n\t\t\t});\n\n\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n  * Search for gradient definition inside CSS value under cursor\n  * @param {String} content\n  * @param {Number} pos\n  * @returns {Object}\n  */\n\tfunction findGradientFromPosition(content, pos) {\n\t\tvar cssProp = null;\n\t\t/** @type EditContainer */\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(content, pos, true);\n\n\t\tif (cssRule) {\n\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\n\t\t\tif (!cssProp) {\n\t\t\t\t// in case user just started writing CSS property\n\t\t\t\t// and didn't include semicolontry another approach\n\t\t\t\tcssProp = _.find(cssRule.list(), function (elem) {\n\t\t\t\t\treturn elem.range(true).end == pos;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\trule: cssRule,\n\t\t\tproperty: cssProp\n\t\t};\n\t}\n\n\t// XXX register expand abbreviation handler\n\t/**\n  * @param {IEmmetEditor} editor\n  * @param {String} syntax\n  * @param {String} profile\n  */\n\trequire('expandAbbreviation').addHandler(function (editor, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tif (!_.include(cssSyntaxes, info.syntax)) return false;\n\n\t\t// let's see if we are expanding gradient definition\n\t\tvar caret = editor.getCaretPos();\n\t\tvar content = info.content;\n\t\tvar css = findGradientFromPosition(content, caret);\n\n\t\tif (css.property) {\n\t\t\t// make sure that caret is inside property value with gradient \n\t\t\t// definition\n\t\t\tvar g = findGradient(css.property);\n\t\t\tif (g) {\n\t\t\t\tvar ruleStart = css.rule.options.offset || 0;\n\t\t\t\tvar ruleEnd = ruleStart + css.rule.toString().length;\n\n\t\t\t\t// Handle special case:\n\t\t\t\t// user wrote gradient definition between existing CSS \n\t\t\t\t// properties and did not finished it with semicolon.\n\t\t\t\t// In this case, we have semicolon right after gradient \n\t\t\t\t// definition and re-parse rule again\n\t\t\t\tif (/[\\n\\r]/.test(css.property.value())) {\n\t\t\t\t\t// insert semicolon at the end of gradient definition\n\t\t\t\t\tvar insertPos = css.property.valueRange(true).start + g.valueRange.end;\n\t\t\t\t\tcontent = require('utils').replaceSubstring(content, ';', insertPos);\n\t\t\t\t\tvar newCss = findGradientFromPosition(content, caret);\n\t\t\t\t\tif (newCss.property) {\n\t\t\t\t\t\tg = findGradient(newCss.property);\n\t\t\t\t\t\tcss = newCss;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// make sure current property has terminating semicolon\n\t\t\t\tcss.property.end(';');\n\n\t\t\t\t// resolve CSS property name\n\t\t\t\tvar resolvedName = resolvePropertyName(css.property.name(), syntax);\n\t\t\t\tif (resolvedName) {\n\t\t\t\t\tcss.property.name(resolvedName);\n\t\t\t\t}\n\n\t\t\t\tpasteGradient(css.property, g.gradient, g.valueRange);\n\t\t\t\teditor.replaceContent(css.rule.toString(), ruleStart, ruleEnd, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn expandGradientOutsideValue(editor, syntax);\n\t});\n\n\t// XXX register \"Reflect CSS Value\" action delegate\n\t/**\n  * @param {EditElement} property\n  */\n\trequire('reflectCSSValue').addHandler(function (property) {\n\t\tvar utils = require('utils');\n\n\t\tvar g = findGradient(property);\n\t\tif (!g) return false;\n\n\t\tvar value = property.value();\n\t\tvar val = function val(v) {\n\t\t\treturn utils.replaceSubstring(value, v, g.valueRange);\n\t\t};\n\n\t\t// reflect value for properties with the same name\n\t\t_.each(property.parent.getAll(getPrefixedNames(property.name())), function (prop) {\n\t\t\tif (prop === property) return;\n\n\t\t\t// check if property value starts with gradient definition\n\t\t\tvar m = prop.value().match(/^\\s*(\\-([a-z]+)\\-)?linear\\-gradient/);\n\t\t\tif (m) {\n\t\t\t\tprop.value(val(module.toString(g.gradient, m[2] || '')));\n\t\t\t} else if (m = prop.value().match(/\\s*\\-webkit\\-gradient/)) {\n\t\t\t\t// old webkit gradient definition\n\t\t\t\tprop.value(val(module.oldWebkitLinearGradient(g.gradient)));\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t});\n\n\treturn module = {\n\t\t/**\n   * Parses gradient definition\n   * @param {String} gradient\n   * @returns {Object}\n   */\n\t\tparse: function parse(gradient) {\n\t\t\tvar result = null;\n\t\t\trequire('utils').trim(gradient).replace(/^([\\w\\-]+)\\((.+?)\\)$/, function (str, type, definition) {\n\t\t\t\t// remove vendor prefix\n\t\t\t\ttype = type.toLowerCase().replace(/^\\-[a-z]+\\-/, '');\n\t\t\t\tif (type == 'linear-gradient' || type == 'lg') {\n\t\t\t\t\tresult = parseLinearGradient(definition);\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\n\t\t\t\treturn str;\n\t\t\t});\n\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n   * Produces linear gradient definition used in early Webkit \n   * implementations\n   * @param {Object} gradient Parsed gradient\n   * @returns {String}\n   */\n\t\toldWebkitLinearGradient: function oldWebkitLinearGradient(gradient) {\n\t\t\tif (_.isString(gradient)) gradient = this.parse(gradient);\n\n\t\t\tif (!gradient) return null;\n\n\t\t\tvar colorStops = _.map(gradient.colorStops, _.clone);\n\n\t\t\t// normalize color-stops position\n\t\t\t_.each(colorStops, function (cs) {\n\t\t\t\tif (!('position' in cs)) // implied position\n\t\t\t\t\treturn;\n\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tfillImpliedPositions(colorStops);\n\n\t\t\t// transform color-stops into string representation\n\t\t\tcolorStops = _.map(colorStops, function (cs, i) {\n\t\t\t\tif (!cs.position && !i) return 'from(' + cs.color + ')';\n\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1) return 'to(' + cs.color + ')';\n\n\t\t\t\treturn 'color-stop(' + cs.position.toFixed(2).replace(/\\.?0+$/, '') + ', ' + cs.color + ')';\n\t\t\t});\n\n\t\t\treturn '-webkit-gradient(linear, ' + oldWebkitDirection(gradient.direction) + ', ' + colorStops.join(', ') + ')';\n\t\t},\n\n\t\t/**\n   * Returns string representation of parsed gradient\n   * @param {Object} gradient Parsed gradient\n   * @param {String} prefix Vendor prefix\n   * @returns {String}\n   */\n\t\ttoString: function toString(gradient, prefix) {\n\t\t\tif (gradient.type == 'linear') {\n\t\t\t\tvar fn = (prefix ? '-' + prefix + '-' : '') + 'linear-gradient';\n\n\t\t\t\t// transform color-stops\n\t\t\t\tvar colorStops = _.map(gradient.colorStops, function (cs) {\n\t\t\t\t\treturn cs.color + ('position' in cs ? ' ' + cs.position + (cs.unit || '') : '');\n\t\t\t\t});\n\n\t\t\t\tif (gradient.direction && (!prefs.get('css.gradient.omitDefaultDirection') || !_.include(defaultLinearDirections, gradient.direction))) {\n\t\t\t\t\tcolorStops.unshift(gradient.direction);\n\t\t\t\t}\n\n\t\t\t\treturn fn + '(' + colorStops.join(', ') + ')';\n\t\t\t}\n\t\t}\n\t};\n}); /**\n    * Module adds support for generators: a regexp-based abbreviation resolver \n    * that can produce custom output.\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\t/** @type HandlerList */\n\tvar generators = require('handlerList').create();\n\tvar resources = require('resources');\n\n\t_.extend(resources, {\n\t\t/**\n   * Add generator. A generator function <code>fn</code> will be called \n   * only if current abbreviation matches <code>regexp</code> regular \n   * expression and this function should return <code>null</code> if\n   * abbreviation cannot be resolved\n   * @param {RegExp} regexp Regular expression for abbreviation element name\n   * @param {Function} fn Resolver function\n   * @param {Object} options Options list as described in \n   * {@link HandlerList#add()} method\n   */\n\t\taddGenerator: function addGenerator(regexp, fn, options) {\n\t\t\tif (_.isString(regexp)) regexp = new RegExp(regexp);\n\n\t\t\tgenerators.add(function (node, syntax) {\n\t\t\t\tvar m;\n\t\t\t\tif (m = regexp.exec(node.name())) {\n\t\t\t\t\treturn fn(m, node, syntax);\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}, options);\n\t\t}\n\t});\n\n\tresources.addResolver(function (node, syntax) {\n\t\treturn generators.exec(null, _.toArray(arguments));\n\t});\n}); /**\n    * Module for resolving tag names: returns best matched tag name for child\n    * element based on passed parent's tag name. Also provides utility function\n    * for element type detection (inline, block-level, empty)\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.define('tagName', function (require, _) {\n\tvar elementTypes = {\n\t\t//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\n\t\tempty: [],\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\n\t};\n\n\tvar elementMap = {\n\t\t'p': 'span',\n\t\t'ul': 'li',\n\t\t'ol': 'li',\n\t\t'table': 'tr',\n\t\t'tr': 'td',\n\t\t'tbody': 'tr',\n\t\t'thead': 'tr',\n\t\t'tfoot': 'tr',\n\t\t'colgroup': 'col',\n\t\t'select': 'option',\n\t\t'optgroup': 'option',\n\t\t'audio': 'source',\n\t\t'video': 'source',\n\t\t'object': 'param',\n\t\t'map': 'area'\n\t};\n\n\treturn {\n\t\t/**\n   * Returns best matched child element name for passed parent's\n   * tag name\n   * @param {String} name\n   * @returns {String}\n   * @memberOf tagName\n   */\n\t\tresolve: function resolve(name) {\n\t\t\tname = (name || '').toLowerCase();\n\n\t\t\tif (name in elementMap) return this.getMapping(name);\n\n\t\t\tif (this.isInlineLevel(name)) return 'span';\n\n\t\t\treturn 'div';\n\t\t},\n\n\t\t/**\n   * Returns mapped child element name for passed parent's name \n   * @param {String} name\n   * @returns {String}\n   */\n\t\tgetMapping: function getMapping(name) {\n\t\t\treturn elementMap[name.toLowerCase()];\n\t\t},\n\n\t\t/**\n   * Check if passed element name belongs to inline-level element\n   * @param {String} name\n   * @returns {Boolean}\n   */\n\t\tisInlineLevel: function isInlineLevel(name) {\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\n\t\t},\n\n\t\t/**\n   * Check if passed element belongs to block-level element.\n   * For better matching of unknown elements (for XML, for example), \n   * you should use <code>!this.isInlineLevel(name)</code>\n   * @returns {Boolean}\n   */\n\t\tisBlockLevel: function isBlockLevel(name) {\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\n\t\t},\n\n\t\t/**\n   * Check if passed element is void (i.e. should not have closing tag).\n   * @returns {Boolean}\n   */\n\t\tisEmptyElement: function isEmptyElement(name) {\n\t\t\treturn this.isTypeOf(name, 'empty');\n\t\t},\n\n\t\t/**\n   * Generic function for testing if element name belongs to specified\n   * elements collection\n   * @param {String} name Element name\n   * @param {String} type Collection name\n   * @returns {Boolean}\n   */\n\t\tisTypeOf: function isTypeOf(name, type) {\n\t\t\treturn _.include(elementTypes[type], name);\n\t\t},\n\n\t\t/**\n   * Adds new parentchild mapping\n   * @param {String} parent\n   * @param {String} child\n   */\n\t\taddMapping: function addMapping(parent, child) {\n\t\t\telementMap[parent] = child;\n\t\t},\n\n\t\t/**\n   * Removes parent-child mapping\n   */\n\t\tremoveMapping: function removeMapping(parent) {\n\t\t\tif (parent in elementMap) delete elementMap[parent];\n\t\t},\n\n\t\t/**\n   * Adds new element into collection\n   * @param {String} name Element name\n   * @param {String} collection Collection name\n   */\n\t\taddElementToCollection: function addElementToCollection(name, collection) {\n\t\t\tif (!elementTypes[collection]) elementTypes[collection] = [];\n\n\t\t\tvar col = this.getCollection(collection);\n\t\t\tif (!_.include(col, name)) col.push(name);\n\t\t},\n\n\t\t/**\n   * Removes element name from specified collection\n   * @param {String} name Element name\n   * @param {String} collection Collection name\n   * @returns\n   */\n\t\tremoveElementFromCollection: function removeElementFromCollection(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = _.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t},\n\n\t\t/**\n   * Returns elements name collection\n   * @param {String} name Collection name\n   * @returns {Array}\n   */\n\t\tgetCollection: function getCollection(name) {\n\t\t\treturn elementTypes[name];\n\t\t}\n\t};\n}); /**\n    * Filter for aiding of writing elements with complex class names as described\n    * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\n    * automatically inherit block and element names from parent elements and insert\n    * them into child element classes\n    * @memberOf __bemFilterDefine\n    * @constructor\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\tvar prefs = require('preferences');\n\tprefs.define('bem.elementSeparator', '__', 'Class names element separator.');\n\tprefs.define('bem.modifierSeparator', '_', 'Class names modifier separator.');\n\tprefs.define('bem.shortElementPrefix', '-', 'Symbol for describing short block-element notation. Class names ' + 'prefixed with this symbol will be treated as element name for parents ' + 'block name. Each symbol instance traverses one level up in parsed ' + 'tree for block name lookup. Empty value will disable short notation.');\n\n\tvar shouldRunHtmlFilter = false;\n\n\tfunction getSeparators() {\n\t\treturn {\n\t\t\telement: prefs.get('bem.elementSeparator'),\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\n\t\t};\n\t}\n\n\t/**\n  * @param {AbbreviationNode} item\n  */\n\tfunction bemParse(item) {\n\t\tif (require('abbreviationUtils').isSnippet(item)) return item;\n\n\t\t// save BEM stuff in cache for faster lookups\n\t\titem.__bem = {\n\t\t\tblock: '',\n\t\t\telement: '',\n\t\t\tmodifier: ''\n\t\t};\n\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\n\n\t\t// guess best match for block name\n\t\tvar reBlockName = /^[a-z]\\-/i;\n\t\titem.__bem.block = _.find(classNames, function (name) {\n\t\t\treturn reBlockName.test(name);\n\t\t});\n\n\t\t// guessing doesn't worked, pick first class name as block name\n\t\tif (!item.__bem.block) {\n\t\t\treBlockName = /^[a-z]/i;\n\t\t\titem.__bem.block = _.find(classNames, function (name) {\n\t\t\t\treturn reBlockName.test(name);\n\t\t\t}) || '';\n\t\t}\n\n\t\tclassNames = _.chain(classNames).map(function (name) {\n\t\t\treturn processClassName(name, item);\n\t\t}).flatten().uniq().value().join(' ');\n\n\t\tif (classNames) item.attribute('class', classNames);\n\n\t\treturn item;\n\t}\n\n\t/**\n  * @param {String} className\n  * @returns {String}\n  */\n\tfunction normalizeClassName(className) {\n\t\tvar utils = require('utils');\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\n\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\n\t\tif (shortSymbol) {\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\n\t\t\tclassName = className.replace(re, function (str, p1) {\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\n\t\t\t});\n\t\t}\n\n\t\treturn utils.trim(className);\n\t}\n\n\t/**\n  * Processes class name\n  * @param {String} name Class name item to process\n  * @param {AbbreviationNode} item Host node for provided class name\n  * @returns Processed class name. May return <code>Array</code> of\n  * class names \n  */\n\tfunction processClassName(name, item) {\n\t\tname = transformClassName(name, item, 'element');\n\t\tname = transformClassName(name, item, 'modifier');\n\n\t\t// expand class name\n\t\t// possible values:\n\t\t// * block__element\n\t\t// * block__element_modifier\n\t\t// * block__element_modifier1_modifier2\n\t\t// * block_modifier\n\t\tvar block = '',\n\t\t    element = '',\n\t\t    modifier = '';\n\t\tvar separators = getSeparators();\n\t\tif (~name.indexOf(separators.element)) {\n\t\t\tvar blockElem = name.split(separators.element);\n\t\t\tvar elemModifiers = blockElem[1].split(separators.modifier);\n\n\t\t\tblock = blockElem[0];\n\t\t\telement = elemModifiers.shift();\n\t\t\tmodifier = elemModifiers.join(separators.modifier);\n\t\t} else if (~name.indexOf(separators.modifier)) {\n\t\t\tvar blockModifiers = name.split(separators.modifier);\n\n\t\t\tblock = blockModifiers.shift();\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\n\t\t}\n\n\t\tif (block || element || modifier) {\n\t\t\tif (!block) {\n\t\t\t\tblock = item.__bem.block;\n\t\t\t}\n\n\t\t\t// inherit parent bem element, if exists\n\t\t\t//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\n\t\t\t//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\n\n\t\t\t// produce multiple classes\n\t\t\tvar prefix = block;\n\t\t\tvar result = [];\n\n\t\t\tif (element) {\n\t\t\t\tprefix += separators.element + element;\n\t\t\t\tresult.push(prefix);\n\t\t\t} else {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\n\t\t\tif (modifier) {\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\n\t\t\t}\n\n\t\t\titem.__bem.block = block;\n\t\t\titem.__bem.element = element;\n\t\t\titem.__bem.modifier = modifier;\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// ...otherwise, return processed or original class name\n\t\treturn name;\n\t}\n\n\t/**\n  * Low-level function to transform user-typed class name into full BEM class\n  * @param {String} name Class name item to process\n  * @param {AbbreviationNode} item Host node for provided class name\n  * @param {String} entityType Type of entity to be tried to transform \n  * ('element' or 'modifier')\n  * @returns {String} Processed class name or original one if it can't be\n  * transformed\n  */\n\tfunction transformClassName(name, item, entityType) {\n\t\tvar separators = getSeparators();\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\n\t\tif (reSep.test(name)) {\n\t\t\tvar depth = 0; // parent lookup depth\n\t\t\tvar cleanName = name.replace(reSep, function (str, p1) {\n\t\t\t\tdepth = str.length / separators[entityType].length;\n\t\t\t\treturn '';\n\t\t\t});\n\n\t\t\t// find donor element\n\t\t\tvar donor = item;\n\t\t\twhile (donor.parent && depth--) {\n\t\t\t\tdonor = donor.parent;\n\t\t\t}\n\n\t\t\tif (!donor || !donor.__bem) donor = item;\n\n\t\t\tif (donor && donor.__bem) {\n\t\t\t\tvar prefix = donor.__bem.block;\n\n\t\t\t\t// decide if we should inherit element name\n\t\t\t\t//\t\t\t\tif (entityType == 'element') {\n\t\t\t\t//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\n\t\t\t\t//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\n\t\t\t\t//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n\t\t\t\t//\t\t\t\t}\n\n\t\t\t\tif (entityType == 'modifier' && donor.__bem.element) prefix += separators.element + donor.__bem.element;\n\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\n\t\t\t}\n\t\t}\n\n\t\treturn name;\n\t}\n\n\t/**\n  * Recursive function for processing tags, which extends class names \n  * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\n  * <br><br>\n  * It does several things:<br>\n  * <ul>\n  * <li>Expands complex class name (according to BEM symbol semantics):\n  * .block__elem_modifier  .block.block__elem.block__elem_modifier\n  * </li>\n  * <li>Inherits block name on child elements: \n  * .b-block > .__el > .__el  .b-block > .b-block__el > .b-block__el__el\n  * </li>\n  * <li>Treats first dash symbol as '__'</li>\n  * <li>Double underscore (or typographic '') is also treated as an element \n  * level lookup, e.g. ____el will search for element definition in parents \n  * parent element:\n  * .b-block > .__el1 > .____el2  .b-block > .b-block__el1 > .b-block__el2\n  * </li>\n  * </ul>\n  * \n  * @param {AbbreviationNode} tree\n  * @param {Object} profile\n  */\n\tfunction process(tree, profile) {\n\t\tif (tree.name) bemParse(tree, profile);\n\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function (item) {\n\t\t\tprocess(item, profile);\n\t\t\tif (!abbrUtils.isSnippet(item) && item.start) shouldRunHtmlFilter = true;\n\t\t});\n\n\t\treturn tree;\n\t};\n\n\trequire('filters').add('bem', function (tree, profile) {\n\t\tshouldRunHtmlFilter = false;\n\t\ttree = process(tree, profile);\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\n\t\t// to update output\n\t\tif (shouldRunHtmlFilter) {\n\t\t\ttree = require('filters').apply(tree, 'html', profile);\n\t\t}\n\n\t\treturn tree;\n\t});\n});\n\n/**\n * Comment important tags (with 'id' and 'class' attributes)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __commentFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function (require, _) {\n\t// define some preferences\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\n\tprefs.define('filter.commentAfter', '\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->', 'A definition of comment that should be placed <i>after</i> matched ' + 'element when <code>comment</code> filter is applied. This definition ' + 'is an ERB-style template passed to <code>_.template()</code> ' + 'function (see Underscore.js docs for details). In template context, ' + 'the following properties and functions are availabe:\\n' + '<ul>' + '<li><code>attr(name, before, after)</code>  a function that outputs' + 'specified attribute value concatenated with <code>before</code> ' + 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' + 'empty string will be returned.</li>' + '<li><code>node</code>  current node (instance of <code>AbbreviationNode</code>)</li>' + '<li><code>name</code>  name of current tag</li>' + '<li><code>padding</code>  current string padding, can be used ' + 'for formatting</li>' + '</ul>');\n\n\tprefs.define('filter.commentBefore', '', 'A definition of comment that should be placed <i>before</i> matched ' + 'element when <code>comment</code> filter is applied. ' + 'For more info, read description of <code>filter.commentAfter</code> ' + 'property');\n\n\tprefs.define('filter.commentTrigger', 'id, class', 'A comma-separated list of attribute names that should exist in abbreviatoin ' + 'where comment should be added. If you wish to add comment for ' + 'every element, set this option to <code>*</code>');\n\n\t/**\n  * Add comments to tag\n  * @param {AbbreviationNode} node\n  */\n\tfunction addComments(node, templateBefore, templateAfter) {\n\t\tvar utils = require('utils');\n\n\t\t// check if comments should be added\n\t\tvar trigger = prefs.get('filter.commentTrigger');\n\t\tif (trigger != '*') {\n\t\t\tvar shouldAdd = _.find(trigger.split(','), function (name) {\n\t\t\t\treturn !!node.attribute(utils.trim(name));\n\t\t\t});\n\t\t\tif (!shouldAdd) return;\n\t\t}\n\n\t\tvar ctx = {\n\t\t\tnode: node,\n\t\t\tname: node.name(),\n\t\t\tpadding: node.parent ? node.parent.padding : '',\n\t\t\tattr: function attr(name, before, after) {\n\t\t\t\tvar attr = node.attribute(name);\n\t\t\t\tif (attr) {\n\t\t\t\t\treturn (before || '') + attr + (after || '');\n\t\t\t\t}\n\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\n\t\tvar nodeBefore = utils.normalizeNewline(templateBefore ? templateBefore(ctx) : '');\n\t\tvar nodeAfter = utils.normalizeNewline(templateAfter ? templateAfter(ctx) : '');\n\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\n\t}\n\n\tfunction process(tree, before, after) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function (item) {\n\t\t\tif (abbrUtils.isBlock(item)) addComments(item, before, after);\n\n\t\t\tprocess(item, before, after);\n\t\t});\n\n\t\treturn tree;\n\t}\n\n\trequire('filters').add('c', function (tree) {\n\t\tvar templateBefore = _.template(prefs.get('filter.commentBefore'));\n\t\tvar templateAfter = _.template(prefs.get('filter.commentAfter'));\n\n\t\treturn process(tree, templateBefore, templateAfter);\n\t});\n});\n/**\n * Filter for escaping unsafe XML characters: <, >, &\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.exec(function (require, _) {\n\tvar charMap = {\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'&': '&amp;'\n\t};\n\n\tfunction escapeChars(str) {\n\t\treturn str.replace(/([<>&])/g, function (str, p1) {\n\t\t\treturn charMap[p1];\n\t\t});\n\t}\n\n\trequire('filters').add('e', function process(tree) {\n\t\t_.each(tree.children, function (item) {\n\t\t\titem.start = escapeChars(item.start);\n\t\t\titem.end = escapeChars(item.end);\n\t\t\titem.content = escapeChars(item.content);\n\t\t\tprocess(item);\n\t\t});\n\n\t\treturn tree;\n\t});\n}); /**\n    * Generic formatting filter: creates proper indentation for each tree node,\n    * placing \"%s\" placeholder where the actual output should be. You can use\n    * this filter to preformat tree and then replace %s placeholder to whatever you\n    * need. This filter should't be called directly from editor as a part \n    * of abbreviation.\n    * @author Sergey Chikuyonok (serge.che@gmail.com)\n    * @link http://chikuyonok.ru\n    * @constructor\n    * @memberOf __formatFilterDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\tvar placeholder = '%s';\n\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('format.noIndentTags', 'html', 'A comma-separated list of tag names that should not get inner indentation.');\n\n\tprefs.define('format.forceIndentationForTags', 'body', 'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\n\n\t/**\n  * Get indentation for given node\n  * @param {AbbreviationNode} node\n  * @returns {String}\n  */\n\tfunction getIndentation(node) {\n\t\tif (_.include(prefs.getArray('format.noIndentTags') || [], node.name())) {\n\t\t\treturn '';\n\t\t}\n\n\t\treturn require('resources').getVariable('indentation');\n\t}\n\n\t/**\n  * Test if passed node has block-level sibling element\n  * @param {AbbreviationNode} item\n  * @return {Boolean}\n  */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && require('abbreviationUtils').hasBlockChildren(item.parent);\n\t}\n\n\t/**\n  * Test if passed item is very first child in parsed tree\n  * @param {AbbreviationNode} item\n  */\n\tfunction isVeryFirstChild(item) {\n\t\treturn item.parent && !item.parent.parent && !item.index();\n\t}\n\n\t/**\n  * Check if a newline should be added before element\n  * @param {AbbreviationNode} node\n  * @param {OutputProfile} profile\n  * @return {Boolean}\n  */\n\tfunction shouldAddLineBreak(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node)) return true;\n\n\t\tif (!node.parent || !profile.inline_break) return false;\n\n\t\t// check if there are required amount of adjacent inline element\n\t\treturn shouldFormatInline(node.parent, profile);\n\t}\n\n\t/**\n  * Need to add newline because <code>item</code> has too many inline children\n  * @param {AbbreviationNode} node\n  * @param {OutputProfile} profile\n  */\n\tfunction shouldBreakChild(node, profile) {\n\t\t// we need to test only one child element, because \n\t\t// hasBlockChildren() method will do the rest\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\n\t}\n\n\tfunction shouldFormatInline(node, profile) {\n\t\tvar nodeCount = 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\treturn !!_.find(node.children, function (child) {\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child)) nodeCount = 0;else if (abbrUtils.isInline(child)) nodeCount++;\n\n\t\t\tif (nodeCount >= profile.inline_break) return true;\n\t\t});\n\t}\n\n\tfunction isRoot(item) {\n\t\treturn !item.parent;\n\t}\n\n\t/**\n  * Processes element with matched resource of type <code>snippet</code>\n  * @param {AbbreviationNode} item\n  * @param {OutputProfile} profile\n  * @param {Number} level Depth level\n  */\n\tfunction processSnippet(item, profile, level) {\n\t\titem.start = item.end = '';\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\n\t\t\t// check if were not inside inline element\n\t\t\tif (isRoot(item.parent) || !require('abbreviationUtils').isInline(item.parent)) {\n\t\t\t\titem.start = require('utils').getNewline() + item.start;\n\t\t\t}\n\t\t}\n\n\t\treturn item;\n\t}\n\n\t/**\n  * Check if we should add line breaks inside inline element\n  * @param {AbbreviationNode} node\n  * @param {OutputProfile} profile\n  * @return {Boolean}\n  */\n\tfunction shouldBreakInsideInline(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar hasBlockElems = _.any(node.children, function (child) {\n\t\t\tif (abbrUtils.isSnippet(child)) return false;\n\n\t\t\treturn !abbrUtils.isInline(child);\n\t\t});\n\n\t\tif (!hasBlockElems) {\n\t\t\treturn shouldFormatInline(node, profile);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n  * Processes element with <code>tag</code> type\n  * @param {AbbreviationNode} item\n  * @param {OutputProfile} profile\n  * @param {Number} level Depth level\n  */\n\tfunction processTag(item, profile, level) {\n\t\titem.start = item.end = placeholder;\n\t\tvar utils = require('utils');\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar nl = utils.getNewline();\n\t\tvar indent = getIndentation(item);\n\n\t\t// formatting output\n\t\tif (profile.tag_nl !== false) {\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\n\t\t\tif (!forceNl) {\n\t\t\t\tforceNl = _.include(prefs.getArray('format.forceIndentationForTags') || [], item.name());\n\t\t\t}\n\n\t\t\t// formatting block-level elements\n\t\t\tif (!item.isTextNode()) {\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\n\t\t\t\t\t// - do not indent the very first element\n\t\t\t\t\t// - do not indent first child of a snippet\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index())) item.start = nl + item.start;\n\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || forceNl && !isUnary) item.end = nl + item.end;\n\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || forceNl && !item.children.length && !isUnary) item.start += nl + indent;\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\n\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\n\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t}\n\n\t\t\t\titem.padding = indent;\n\t\t\t}\n\t\t}\n\n\t\treturn item;\n\t}\n\n\t/**\n  * Processes simplified tree, making it suitable for output as HTML structure\n  * @param {AbbreviationNode} tree\n  * @param {OutputProfile} profile\n  * @param {Number} level Depth level\n  */\n\trequire('filters').add('_format', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\n\t\t_.each(tree.children, function (item) {\n\t\t\tif (abbrUtils.isSnippet(item)) processSnippet(item, profile, level);else processTag(item, profile, level);\n\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\n\t\treturn tree;\n\t});\n}); /**\n    * Filter for producing HAML code from abbreviation.\n    * @author Sergey Chikuyonok (serge.che@gmail.com)\n    * @link http://chikuyonok.ru\n    * @constructor\n    * @memberOf __hamlFilterDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\tvar childToken = '${child}';\n\n\tfunction transformClassName(className) {\n\t\treturn require('utils').trim(className).replace(/\\s+/g, '.');\n\t}\n\n\t/**\n  * Creates HAML attributes string from tag according to profile settings\n  * @param {AbbreviationNode} tag\n  * @param {Object} profile\n  */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\n\t\t_.each(tag.attributeList(), function (a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push(':' + attrName + ' => ' + attrQuote + (a.value || cursor) + attrQuote);\n\t\t\t}\n\t\t});\n\n\t\tif (otherAttrs.length) attrs += '{' + otherAttrs.join(', ') + '}';\n\n\t\treturn attrs;\n\t}\n\n\t/**\n  * Test if passed node has block-level sibling element\n  * @param {AbbreviationNode} item\n  * @return {Boolean}\n  */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && item.parent.hasBlockChildren();\n\t}\n\n\t/**\n  * Processes element with <code>tag</code> type\n  * @param {AbbreviationNode} item\n  * @param {OutputProfile} profile\n  * @param {Number} level Depth level\n  */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's root element\n\t\t\treturn item;\n\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\n\t\tvar start = '';\n\n\t\t// define tag name\n\t\tvar tagName = '%' + profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\n\t\titem.end = '';\n\t\tstart = tagName + attrs + selfClosing + ' ';\n\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\n\t\tif (!item.children.length && !isUnary) item.start += cursor;\n\n\t\treturn item;\n\t}\n\n\t/**\n  * Processes simplified tree, making it suitable for output as HTML structure\n  * @param {AbbreviationNode} tree\n  * @param {Object} profile\n  * @param {Number} level Depth level\n  */\n\trequire('filters').add('haml', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\n\t\t_.each(tree.children, function (item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) processTag(item, profile, level);\n\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\n\t\treturn tree;\n\t});\n}); /**\n    * Filter that produces HTML tree\n    * @author Sergey Chikuyonok (serge.che@gmail.com)\n    * @link http://chikuyonok.ru\n    * @constructor\n    * @memberOf __htmlFilterDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\t/**\n  * Creates HTML attributes string from tag according to profile settings\n  * @param {AbbreviationNode} node\n  * @param {OutputProfile} profile\n  */\n\tfunction makeAttributesString(node, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\n\t\treturn _.map(node.attributeList(), function (a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (a.value || cursor) + attrQuote;\n\t\t}).join('');\n\t}\n\n\t/**\n  * Processes element with <code>tag</code> type\n  * @param {AbbreviationNode} item\n  * @param {OutputProfile} profile\n  * @param {Number} level Depth level\n  */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent) // looks like it's root element\n\t\t\treturn item;\n\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar start = '';\n\t\tvar end = '';\n\n\t\t// define opening and closing tags\n\t\tif (!item.isTextNode()) {\n\t\t\tvar tagName = profile.tagName(item.name());\n\t\t\tif (isUnary) {\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\n\t\t\t\titem.end = '';\n\t\t\t} else {\n\t\t\t\tstart = '<' + tagName + attrs + '>';\n\t\t\t\tend = '</' + tagName + '>';\n\t\t\t}\n\t\t}\n\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\n\n\t\t// should we put caret placeholder after opening tag?\n\t\tif (!item.children.length && !isUnary && !~item.content.indexOf(cursor) && !require('tabStops').extract(item.content).tabstops.length) {\n\t\t\titem.start += cursor;\n\t\t}\n\n\t\treturn item;\n\t}\n\n\t/**\n  * Processes simplified tree, making it suitable for output as HTML structure\n  * @param {AbbreviationNode} tree\n  * @param {Object} profile\n  * @param {Number} level Depth level\n  */\n\trequire('filters').add('html', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\n\t\t_.each(tree.children, function (item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) processTag(item, profile, level);\n\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\n\t\treturn tree;\n\t});\n}); /**\n    * Output abbreviation on a single line (i.e. no line breaks)\n    * @author Sergey Chikuyonok (serge.che@gmail.com)\n    * @link http://chikuyonok.ru\n    * @constructor\n    * @memberOf __singleLineFilterDefine\n    * @param {Function} require\n    * @param {Underscore} _\n    */\nemmet.exec(function (require, _) {\n\tvar rePad = /^\\s+/;\n\tvar reNl = /[\\n\\r]/g;\n\n\trequire('filters').add('s', function process(tree, profile, level) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\n\t\t_.each(tree.children, function (item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\t// remove padding from item \n\t\t\t\titem.start = item.start.replace(rePad, '');\n\t\t\t\titem.end = item.end.replace(rePad, '');\n\t\t\t}\n\n\t\t\t// remove newlines \n\t\t\titem.start = item.start.replace(reNl, '');\n\t\t\titem.end = item.end.replace(reNl, '');\n\t\t\titem.content = item.content.replace(reNl, '');\n\n\t\t\tprocess(item);\n\t\t});\n\n\t\treturn tree;\n\t});\n});\n/**\n * Trim filter: removes characters at the beginning of the text\n * content that indicates lists: numbers, #, *, -, etc.\n * \n * Useful for wrapping lists with abbreviation.\n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __trimFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function (require, _) {\n\trequire('preferences').define('filter.trimRegexp', '[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|*|\\\\u2022]+\\\\.?\\\\s*', 'Regular expression used to remove list markers (numbers, dashes, ' + 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter ' + 'is useful for wrapping with abbreviation lists, pased from other ' + 'documents (for example, Word documents).');\n\n\tfunction process(tree, re) {\n\t\t_.each(tree.children, function (item) {\n\t\t\tif (item.content) item.content = item.content.replace(re, '');\n\n\t\t\tprocess(item, re);\n\t\t});\n\n\t\treturn tree;\n\t}\n\n\trequire('filters').add('t', function (tree) {\n\t\tvar re = new RegExp(require('preferences').get('filter.trimRegexp'));\n\t\treturn process(tree, re);\n\t});\n});\n/**\n * Filter for trimming \"select\" attributes from some tags that contains\n * child elements\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __xslFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function (require, _) {\n\tvar tags = {\n\t\t'xsl:variable': 1,\n\t\t'xsl:with-param': 1\n\t};\n\n\t/**\n  * Removes \"select\" attribute from node\n  * @param {AbbreviationNode} node\n  */\n\tfunction trimAttribute(node) {\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\n\t}\n\n\trequire('filters').add('xsl', function process(tree) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function (item) {\n\t\t\tif (!abbrUtils.isSnippet(item) && (item.name() || '').toLowerCase() in tags && item.children.length) trimAttribute(item);\n\t\t\tprocess(item);\n\t\t});\n\n\t\treturn tree;\n\t});\n}); /**\n    * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \n    * <code>lorem(num)?</code> abbreviation.\n    * This code is based on Django's contribution: \n    * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\n    * <br><br>\n    * Examples to test:<br>\n    * <code>lipsum</code>  generates 30 words text.<br>\n    * <code>lipsum*6</code>  generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\n    * <code>ol>lipsum10*5</code>  generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\n    * with text of 10 words on each line<br>\n    * <code>span*3>lipsum20</code>  generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element .\n    * Each paragraph phrase is unique   \n    * @param {Function} require\n    * @param {Underscore} _ \n    * @constructor\n    * @memberOf __loremIpsumGeneratorDefine\n    */\nemmet.define('lorem', function (require, _) {\n\tvar langs = {\n\t\ten: {\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet', 'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi', 'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi', 'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos', 'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum', 'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus', 'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus', 'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum', 'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem', 'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus', 'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente', 'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet', 'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta', 'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima', 'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim', 'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores', 'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias', 'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea', 'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt', 'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate', 'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius', 'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos', 'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore', 'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo', 'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi', 'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam', 'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique', 'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere', 'maxime', 'corrupti']\n\t\t},\n\t\tru: {\n\t\t\tcommon: ['-', '', '', '', ' ', '', ' ', '', '', ''],\n\t\t\twords: ['', ' ', '', '', '', ' ', '', '', '', '', '', '', '', '', ' ', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'lorem', 'ipsum', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']\n\t\t}\n\t};\n\n\tvar prefs = require('preferences');\n\tprefs.define('lorem.defaultLang', 'en');\n\n\t/**\n  * @param {AbbreviationNode} tree\n  * @param {Object} options\n  */\n\trequire('abbreviationParser').addPreprocessor(function (tree, options) {\n\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i,\n\t\t    match;\n\n\t\t/** @param {AbbreviationNode} node */\n\t\ttree.findAll(function (node) {\n\t\t\tif (node._name && (match = node._name.match(re))) {\n\t\t\t\tvar wordCound = match[2] || 30;\n\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\n\n\t\t\t\t// force node name resolving if node should be repeated\n\t\t\t\t// or contains attributes. In this case, node should be outputed\n\t\t\t\t// as tag, otherwise as text-only node\n\t\t\t\tnode._name = '';\n\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\n\t\t\t\tnode.data('pasteOverwrites', true);\n\t\t\t\tnode.data('paste', function (i, content) {\n\t\t\t\t\treturn paragraph(lang, wordCound, !i);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\n\t/**\n  * Returns random integer between <code>from</code> and <code>to</code> values\n  * @param {Number} from\n  * @param {Number} to\n  * @returns {Number}\n  */\n\tfunction randint(from, to) {\n\t\treturn Math.round(Math.random() * (to - from) + from);\n\t}\n\n\t/**\n  * @param {Array} arr\n  * @param {Number} count\n  * @returns {Array}\n  */\n\tfunction sample(arr, count) {\n\t\tvar len = arr.length;\n\t\tvar iterations = Math.min(len, count);\n\t\tvar result = [];\n\t\twhile (result.length < iterations) {\n\t\t\tvar randIx = randint(0, len - 1);\n\t\t\tif (!_.include(result, randIx)) result.push(randIx);\n\t\t}\n\n\t\treturn _.map(result, function (ix) {\n\t\t\treturn arr[ix];\n\t\t});\n\t}\n\n\tfunction choice(val) {\n\t\tif (_.isString(val)) return val.charAt(randint(0, val.length - 1));\n\n\t\treturn val[randint(0, val.length - 1)];\n\t}\n\n\tfunction sentence(words, end) {\n\t\tif (words.length) {\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\n\t\t}\n\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots that question marks\n\t}\n\n\t/**\n  * Insert commas at randomly selected words. This function modifies values\n  * inside <code>words</code> array \n  * @param {Array} words\n  */\n\tfunction insertCommas(words) {\n\t\tvar len = words.length;\n\t\tvar totalCommas = 0;\n\n\t\tif (len > 3 && len <= 6) {\n\t\t\ttotalCommas = randint(0, 1);\n\t\t} else if (len > 6 && len <= 12) {\n\t\t\ttotalCommas = randint(0, 2);\n\t\t} else {\n\t\t\ttotalCommas = randint(1, 4);\n\t\t}\n\n\t\t_.each(_.range(totalCommas), function (ix) {\n\t\t\tif (ix < words.length - 1) {\n\t\t\t\twords[ix] += ',';\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n  * Generate a paragraph of \"Lorem ipsum\" text\n  * @param {Number} wordCount Words count in paragraph\n  * @param {Boolean} startWithCommon Should paragraph start with common \n  * \"lorem ipsum\" sentence.\n  * @returns {String}\n  */\n\tfunction paragraph(lang, wordCount, startWithCommon) {\n\t\tvar data = langs[lang];\n\t\tif (!data) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvar result = [];\n\t\tvar totalWords = 0;\n\t\tvar words;\n\n\t\twordCount = parseInt(wordCount, 10);\n\n\t\tif (startWithCommon && data.common) {\n\t\t\twords = data.common.slice(0, wordCount);\n\t\t\tif (words.length > 5) words[4] += ',';\n\t\t\ttotalWords += words.length;\n\t\t\tresult.push(sentence(words, '.'));\n\t\t}\n\n\t\twhile (totalWords < wordCount) {\n\t\t\twords = sample(data.words, Math.min(randint(3, 12) * randint(1, 5), wordCount - totalWords));\n\t\t\ttotalWords += words.length;\n\t\t\tinsertCommas(words);\n\t\t\tresult.push(sentence(words));\n\t\t}\n\n\t\treturn result.join(' ');\n\t}\n\n\treturn {\n\t\t/**\n   * Adds new language words for Lorem Ipsum generator\n   * @param {String} lang Two-letter lang definition\n   * @param {Object} data Words for language. Maight be either a space-separated \n   * list of words (String), Array of words or object with <code>text</code> and\n   * <code>common</code> properties\n   */\n\t\taddLang: function addLang(lang, data) {\n\t\t\tif (_.isString(data)) {\n\t\t\t\tdata = { words: _.compact(data.split(' ')) };\n\t\t\t} else if (_.isArray(data)) {\n\t\t\t\tdata = { words: data };\n\t\t\t}\n\n\t\t\tlangs[lang] = data;\n\t\t}\n\t};\n}); /**\n    * A back-end bootstrap module with commonly used methods for loading user data\n    * @param {Function} require\n    * @param {Underscore} _  \n    */\nemmet.define('bootstrap', function (require, _) {\n\tvar snippets = {\n\t\t\"variables\": {\n\t\t\t\"lang\": \"en\",\n\t\t\t\"locale\": \"en-US\",\n\t\t\t\"charset\": \"UTF-8\",\n\t\t\t\"indentation\": \"\\t\",\n\t\t\t\"newline\": \"\\n\"\n\t\t},\n\n\t\t\"css\": {\n\t\t\t\"filters\": \"html\",\n\t\t\t\"snippets\": {\n\t\t\t\t\"@i\": \"@import url(|);\",\n\t\t\t\t\"@import\": \"@import url(|);\",\n\t\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\n\t\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\n\t\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\n\n\t\t\t\t\"anim\": \"animation:|;\",\n\t\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\n\t\t\t\t\"animdel\": \"animation-delay:${1:time};\",\n\n\t\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\n\t\t\t\t\"animdir:n\": \"animation-direction:normal;\",\n\t\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\n\t\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\n\t\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\n\n\t\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\n\n\t\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\n\t\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\n\t\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\n\t\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\n\t\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\n\n\t\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\n\t\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\n\n\t\t\t\t\"animn\": \"animation-name:${1:none};\",\n\n\t\t\t\t\"animps\": \"animation-play-state:${1:running};\",\n\t\t\t\t\"animps:p\": \"animation-play-state:paused;\",\n\t\t\t\t\"animps:r\": \"animation-play-state:running;\",\n\n\t\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\n\t\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\n\t\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\n\t\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\n\t\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\n\t\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\n\t\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\n\n\t\t\t\t\"ap\": \"appearance:${none};\",\n\n\t\t\t\t\"!\": \"!important\",\n\t\t\t\t\"pos\": \"position:${1:relative};\",\n\t\t\t\t\"pos:s\": \"position:static;\",\n\t\t\t\t\"pos:a\": \"position:absolute;\",\n\t\t\t\t\"pos:r\": \"position:relative;\",\n\t\t\t\t\"pos:f\": \"position:fixed;\",\n\t\t\t\t\"t\": \"top:|;\",\n\t\t\t\t\"t:a\": \"top:auto;\",\n\t\t\t\t\"r\": \"right:|;\",\n\t\t\t\t\"r:a\": \"right:auto;\",\n\t\t\t\t\"b\": \"bottom:|;\",\n\t\t\t\t\"b:a\": \"bottom:auto;\",\n\t\t\t\t\"l\": \"left:|;\",\n\t\t\t\t\"l:a\": \"left:auto;\",\n\t\t\t\t\"z\": \"z-index:|;\",\n\t\t\t\t\"z:a\": \"z-index:auto;\",\n\t\t\t\t\"fl\": \"float:${1:left};\",\n\t\t\t\t\"fl:n\": \"float:none;\",\n\t\t\t\t\"fl:l\": \"float:left;\",\n\t\t\t\t\"fl:r\": \"float:right;\",\n\t\t\t\t\"cl\": \"clear:${1:both};\",\n\t\t\t\t\"cl:n\": \"clear:none;\",\n\t\t\t\t\"cl:l\": \"clear:left;\",\n\t\t\t\t\"cl:r\": \"clear:right;\",\n\t\t\t\t\"cl:b\": \"clear:both;\",\n\n\t\t\t\t\"colm\": \"columns:|;\",\n\t\t\t\t\"colmc\": \"column-count:|;\",\n\t\t\t\t\"colmf\": \"column-fill:|;\",\n\t\t\t\t\"colmg\": \"column-gap:|;\",\n\t\t\t\t\"colmr\": \"column-rule:|;\",\n\t\t\t\t\"colmrc\": \"column-rule-color:|;\",\n\t\t\t\t\"colmrs\": \"column-rule-style:|;\",\n\t\t\t\t\"colmrw\": \"column-rule-width:|;\",\n\t\t\t\t\"colms\": \"column-span:|;\",\n\t\t\t\t\"colmw\": \"column-width:|;\",\n\n\t\t\t\t\"d\": \"display:${1:block};\",\n\t\t\t\t\"d:n\": \"display:none;\",\n\t\t\t\t\"d:b\": \"display:block;\",\n\t\t\t\t\"d:i\": \"display:inline;\",\n\t\t\t\t\"d:ib\": \"display:inline-block;\",\n\t\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\n\t\t\t\t\"d:li\": \"display:list-item;\",\n\t\t\t\t\"d:ri\": \"display:run-in;\",\n\t\t\t\t\"d:cp\": \"display:compact;\",\n\t\t\t\t\"d:tb\": \"display:table;\",\n\t\t\t\t\"d:itb\": \"display:inline-table;\",\n\t\t\t\t\"d:tbcp\": \"display:table-caption;\",\n\t\t\t\t\"d:tbcl\": \"display:table-column;\",\n\t\t\t\t\"d:tbclg\": \"display:table-column-group;\",\n\t\t\t\t\"d:tbhg\": \"display:table-header-group;\",\n\t\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\n\t\t\t\t\"d:tbr\": \"display:table-row;\",\n\t\t\t\t\"d:tbrg\": \"display:table-row-group;\",\n\t\t\t\t\"d:tbc\": \"display:table-cell;\",\n\t\t\t\t\"d:rb\": \"display:ruby;\",\n\t\t\t\t\"d:rbb\": \"display:ruby-base;\",\n\t\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\n\t\t\t\t\"d:rbt\": \"display:ruby-text;\",\n\t\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\n\t\t\t\t\"v\": \"visibility:${1:hidden};\",\n\t\t\t\t\"v:v\": \"visibility:visible;\",\n\t\t\t\t\"v:h\": \"visibility:hidden;\",\n\t\t\t\t\"v:c\": \"visibility:collapse;\",\n\t\t\t\t\"ov\": \"overflow:${1:hidden};\",\n\t\t\t\t\"ov:v\": \"overflow:visible;\",\n\t\t\t\t\"ov:h\": \"overflow:hidden;\",\n\t\t\t\t\"ov:s\": \"overflow:scroll;\",\n\t\t\t\t\"ov:a\": \"overflow:auto;\",\n\t\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\n\t\t\t\t\"ovx:v\": \"overflow-x:visible;\",\n\t\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\n\t\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\n\t\t\t\t\"ovx:a\": \"overflow-x:auto;\",\n\t\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\n\t\t\t\t\"ovy:v\": \"overflow-y:visible;\",\n\t\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\n\t\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\n\t\t\t\t\"ovy:a\": \"overflow-y:auto;\",\n\t\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\n\t\t\t\t\"ovs:a\": \"overflow-style:auto;\",\n\t\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\n\t\t\t\t\"ovs:p\": \"overflow-style:panner;\",\n\t\t\t\t\"ovs:m\": \"overflow-style:move;\",\n\t\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\n\t\t\t\t\"zoo\": \"zoom:1;\",\n\t\t\t\t\"zm\": \"zoom:1;\",\n\t\t\t\t\"cp\": \"clip:|;\",\n\t\t\t\t\"cp:a\": \"clip:auto;\",\n\t\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\n\t\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\n\t\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\n\t\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\n\t\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\n\t\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\n\t\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\n\t\t\t\t\"bxsh:n\": \"box-shadow:none;\",\n\t\t\t\t\"m\": \"margin:|;\",\n\t\t\t\t\"m:a\": \"margin:auto;\",\n\t\t\t\t\"mt\": \"margin-top:|;\",\n\t\t\t\t\"mt:a\": \"margin-top:auto;\",\n\t\t\t\t\"mr\": \"margin-right:|;\",\n\t\t\t\t\"mr:a\": \"margin-right:auto;\",\n\t\t\t\t\"mb\": \"margin-bottom:|;\",\n\t\t\t\t\"mb:a\": \"margin-bottom:auto;\",\n\t\t\t\t\"ml\": \"margin-left:|;\",\n\t\t\t\t\"ml:a\": \"margin-left:auto;\",\n\t\t\t\t\"p\": \"padding:|;\",\n\t\t\t\t\"pt\": \"padding-top:|;\",\n\t\t\t\t\"pr\": \"padding-right:|;\",\n\t\t\t\t\"pb\": \"padding-bottom:|;\",\n\t\t\t\t\"pl\": \"padding-left:|;\",\n\t\t\t\t\"w\": \"width:|;\",\n\t\t\t\t\"w:a\": \"width:auto;\",\n\t\t\t\t\"h\": \"height:|;\",\n\t\t\t\t\"h:a\": \"height:auto;\",\n\t\t\t\t\"maw\": \"max-width:|;\",\n\t\t\t\t\"maw:n\": \"max-width:none;\",\n\t\t\t\t\"mah\": \"max-height:|;\",\n\t\t\t\t\"mah:n\": \"max-height:none;\",\n\t\t\t\t\"miw\": \"min-width:|;\",\n\t\t\t\t\"mih\": \"min-height:|;\",\n\t\t\t\t\"mar\": \"max-resolution:${1:res};\",\n\t\t\t\t\"mir\": \"min-resolution:${1:res};\",\n\t\t\t\t\"ori\": \"orientation:|;\",\n\t\t\t\t\"ori:l\": \"orientation:landscape;\",\n\t\t\t\t\"ori:p\": \"orientation:portrait;\",\n\t\t\t\t\"ol\": \"outline:|;\",\n\t\t\t\t\"ol:n\": \"outline:none;\",\n\t\t\t\t\"olo\": \"outline-offset:|;\",\n\t\t\t\t\"olw\": \"outline-width:|;\",\n\t\t\t\t\"olw:tn\": \"outline-width:thin;\",\n\t\t\t\t\"olw:m\": \"outline-width:medium;\",\n\t\t\t\t\"olw:tc\": \"outline-width:thick;\",\n\t\t\t\t\"ols\": \"outline-style:|;\",\n\t\t\t\t\"ols:n\": \"outline-style:none;\",\n\t\t\t\t\"ols:dt\": \"outline-style:dotted;\",\n\t\t\t\t\"ols:ds\": \"outline-style:dashed;\",\n\t\t\t\t\"ols:s\": \"outline-style:solid;\",\n\t\t\t\t\"ols:db\": \"outline-style:double;\",\n\t\t\t\t\"ols:g\": \"outline-style:groove;\",\n\t\t\t\t\"ols:r\": \"outline-style:ridge;\",\n\t\t\t\t\"ols:i\": \"outline-style:inset;\",\n\t\t\t\t\"ols:o\": \"outline-style:outset;\",\n\t\t\t\t\"olc\": \"outline-color:#${1:000};\",\n\t\t\t\t\"olc:i\": \"outline-color:invert;\",\n\t\t\t\t\"bd\": \"border:|;\",\n\t\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\t\"bd:n\": \"border:none;\",\n\t\t\t\t\"bdbk\": \"border-break:${1:close};\",\n\t\t\t\t\"bdbk:c\": \"border-break:close;\",\n\t\t\t\t\"bdcl\": \"border-collapse:|;\",\n\t\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\n\t\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\n\t\t\t\t\"bdc\": \"border-color:#${1:000};\",\n\t\t\t\t\"bdc:t\": \"border-color:transparent;\",\n\t\t\t\t\"bdi\": \"border-image:url(|);\",\n\t\t\t\t\"bdi:n\": \"border-image:none;\",\n\t\t\t\t\"bdti\": \"border-top-image:url(|);\",\n\t\t\t\t\"bdti:n\": \"border-top-image:none;\",\n\t\t\t\t\"bdri\": \"border-right-image:url(|);\",\n\t\t\t\t\"bdri:n\": \"border-right-image:none;\",\n\t\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\n\t\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\n\t\t\t\t\"bdli\": \"border-left-image:url(|);\",\n\t\t\t\t\"bdli:n\": \"border-left-image:none;\",\n\t\t\t\t\"bdci\": \"border-corner-image:url(|);\",\n\t\t\t\t\"bdci:n\": \"border-corner-image:none;\",\n\t\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\n\t\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\n\t\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\n\t\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\n\t\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\n\t\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\n\t\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\n\t\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\n\t\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\n\t\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\n\t\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\n\t\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\n\t\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\n\t\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\n\t\t\t\t\"bdf:c\": \"border-fit:clip;\",\n\t\t\t\t\"bdf:r\": \"border-fit:repeat;\",\n\t\t\t\t\"bdf:sc\": \"border-fit:scale;\",\n\t\t\t\t\"bdf:st\": \"border-fit:stretch;\",\n\t\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\n\t\t\t\t\"bdf:of\": \"border-fit:overflow;\",\n\t\t\t\t\"bdf:sp\": \"border-fit:space;\",\n\t\t\t\t\"bdlen\": \"border-length:|;\",\n\t\t\t\t\"bdlen:a\": \"border-length:auto;\",\n\t\t\t\t\"bdsp\": \"border-spacing:|;\",\n\t\t\t\t\"bds\": \"border-style:|;\",\n\t\t\t\t\"bds:n\": \"border-style:none;\",\n\t\t\t\t\"bds:h\": \"border-style:hidden;\",\n\t\t\t\t\"bds:dt\": \"border-style:dotted;\",\n\t\t\t\t\"bds:ds\": \"border-style:dashed;\",\n\t\t\t\t\"bds:s\": \"border-style:solid;\",\n\t\t\t\t\"bds:db\": \"border-style:double;\",\n\t\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\n\t\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\n\t\t\t\t\"bds:w\": \"border-style:wave;\",\n\t\t\t\t\"bds:g\": \"border-style:groove;\",\n\t\t\t\t\"bds:r\": \"border-style:ridge;\",\n\t\t\t\t\"bds:i\": \"border-style:inset;\",\n\t\t\t\t\"bds:o\": \"border-style:outset;\",\n\t\t\t\t\"bdw\": \"border-width:|;\",\n\t\t\t\t\"bdtw\": \"border-top-width:|;\",\n\t\t\t\t\"bdrw\": \"border-right-width:|;\",\n\t\t\t\t\"bdbw\": \"border-bottom-width:|;\",\n\t\t\t\t\"bdlw\": \"border-left-width:|;\",\n\t\t\t\t\"bdt\": \"border-top:|;\",\n\t\t\t\t\"bt\": \"border-top:|;\",\n\t\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\t\"bdt:n\": \"border-top:none;\",\n\t\t\t\t\"bdts\": \"border-top-style:|;\",\n\t\t\t\t\"bdts:n\": \"border-top-style:none;\",\n\t\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\n\t\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\n\t\t\t\t\"bdr\": \"border-right:|;\",\n\t\t\t\t\"br\": \"border-right:|;\",\n\t\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\t\"bdr:n\": \"border-right:none;\",\n\t\t\t\t\"bdrst\": \"border-right-style:|;\",\n\t\t\t\t\"bdrst:n\": \"border-right-style:none;\",\n\t\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\n\t\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\n\t\t\t\t\"bdb\": \"border-bottom:|;\",\n\t\t\t\t\"bb\": \"border-bottom:|;\",\n\t\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\t\"bdb:n\": \"border-bottom:none;\",\n\t\t\t\t\"bdbs\": \"border-bottom-style:|;\",\n\t\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\n\t\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\n\t\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\n\t\t\t\t\"bdl\": \"border-left:|;\",\n\t\t\t\t\"bl\": \"border-left:|;\",\n\t\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\t\"bdl:n\": \"border-left:none;\",\n\t\t\t\t\"bdls\": \"border-left-style:|;\",\n\t\t\t\t\"bdls:n\": \"border-left-style:none;\",\n\t\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\n\t\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\n\t\t\t\t\"bdrs\": \"border-radius:|;\",\n\t\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\n\t\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\n\t\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\n\t\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\n\t\t\t\t\"bg\": \"background:#${1:000};\",\n\t\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\n\t\t\t\t\"bg:n\": \"background:none;\",\n\t\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\n\t\t\t\t\"bgc\": \"background-color:#${1:fff};\",\n\t\t\t\t\"bgc:t\": \"background-color:transparent;\",\n\t\t\t\t\"bgi\": \"background-image:url(|);\",\n\t\t\t\t\"bgi:n\": \"background-image:none;\",\n\t\t\t\t\"bgr\": \"background-repeat:|;\",\n\t\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\n\t\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\n\t\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\n\t\t\t\t\"bgr:sp\": \"background-repeat:space;\",\n\t\t\t\t\"bgr:rd\": \"background-repeat:round;\",\n\t\t\t\t\"bga\": \"background-attachment:|;\",\n\t\t\t\t\"bga:f\": \"background-attachment:fixed;\",\n\t\t\t\t\"bga:s\": \"background-attachment:scroll;\",\n\t\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\n\t\t\t\t\"bgpx\": \"background-position-x:|;\",\n\t\t\t\t\"bgpy\": \"background-position-y:|;\",\n\t\t\t\t\"bgbk\": \"background-break:|;\",\n\t\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\n\t\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\n\t\t\t\t\"bgbk:c\": \"background-break:continuous;\",\n\t\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\n\t\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\n\t\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\n\t\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\n\t\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\n\t\t\t\t\"bgo\": \"background-origin:|;\",\n\t\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\n\t\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\n\t\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\n\t\t\t\t\"bgsz\": \"background-size:|;\",\n\t\t\t\t\"bgsz:a\": \"background-size:auto;\",\n\t\t\t\t\"bgsz:ct\": \"background-size:contain;\",\n\t\t\t\t\"bgsz:cv\": \"background-size:cover;\",\n\t\t\t\t\"c\": \"color:#${1:000};\",\n\t\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\n\t\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\n\t\t\t\t\"cm\": \"/* |${child} */\",\n\t\t\t\t\"cnt\": \"content:'|';\",\n\t\t\t\t\"cnt:n\": \"content:normal;\",\n\t\t\t\t\"cnt:oq\": \"content:open-quote;\",\n\t\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\n\t\t\t\t\"cnt:cq\": \"content:close-quote;\",\n\t\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\n\t\t\t\t\"cnt:a\": \"content:attr(|);\",\n\t\t\t\t\"cnt:c\": \"content:counter(|);\",\n\t\t\t\t\"cnt:cs\": \"content:counters(|);\",\n\n\t\t\t\t\"tbl\": \"table-layout:|;\",\n\t\t\t\t\"tbl:a\": \"table-layout:auto;\",\n\t\t\t\t\"tbl:f\": \"table-layout:fixed;\",\n\t\t\t\t\"cps\": \"caption-side:|;\",\n\t\t\t\t\"cps:t\": \"caption-side:top;\",\n\t\t\t\t\"cps:b\": \"caption-side:bottom;\",\n\t\t\t\t\"ec\": \"empty-cells:|;\",\n\t\t\t\t\"ec:s\": \"empty-cells:show;\",\n\t\t\t\t\"ec:h\": \"empty-cells:hide;\",\n\t\t\t\t\"lis\": \"list-style:|;\",\n\t\t\t\t\"lis:n\": \"list-style:none;\",\n\t\t\t\t\"lisp\": \"list-style-position:|;\",\n\t\t\t\t\"lisp:i\": \"list-style-position:inside;\",\n\t\t\t\t\"lisp:o\": \"list-style-position:outside;\",\n\t\t\t\t\"list\": \"list-style-type:|;\",\n\t\t\t\t\"list:n\": \"list-style-type:none;\",\n\t\t\t\t\"list:d\": \"list-style-type:disc;\",\n\t\t\t\t\"list:c\": \"list-style-type:circle;\",\n\t\t\t\t\"list:s\": \"list-style-type:square;\",\n\t\t\t\t\"list:dc\": \"list-style-type:decimal;\",\n\t\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\n\t\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\n\t\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\n\t\t\t\t\"lisi\": \"list-style-image:|;\",\n\t\t\t\t\"lisi:n\": \"list-style-image:none;\",\n\t\t\t\t\"q\": \"quotes:|;\",\n\t\t\t\t\"q:n\": \"quotes:none;\",\n\t\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\n\t\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\n\t\t\t\t\"ct\": \"content:|;\",\n\t\t\t\t\"ct:n\": \"content:normal;\",\n\t\t\t\t\"ct:oq\": \"content:open-quote;\",\n\t\t\t\t\"ct:noq\": \"content:no-open-quote;\",\n\t\t\t\t\"ct:cq\": \"content:close-quote;\",\n\t\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\n\t\t\t\t\"ct:a\": \"content:attr(|);\",\n\t\t\t\t\"ct:c\": \"content:counter(|);\",\n\t\t\t\t\"ct:cs\": \"content:counters(|);\",\n\t\t\t\t\"coi\": \"counter-increment:|;\",\n\t\t\t\t\"cor\": \"counter-reset:|;\",\n\t\t\t\t\"va\": \"vertical-align:${1:top};\",\n\t\t\t\t\"va:sup\": \"vertical-align:super;\",\n\t\t\t\t\"va:t\": \"vertical-align:top;\",\n\t\t\t\t\"va:tt\": \"vertical-align:text-top;\",\n\t\t\t\t\"va:m\": \"vertical-align:middle;\",\n\t\t\t\t\"va:bl\": \"vertical-align:baseline;\",\n\t\t\t\t\"va:b\": \"vertical-align:bottom;\",\n\t\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\n\t\t\t\t\"va:sub\": \"vertical-align:sub;\",\n\t\t\t\t\"ta\": \"text-align:${1:left};\",\n\t\t\t\t\"ta:l\": \"text-align:left;\",\n\t\t\t\t\"ta:c\": \"text-align:center;\",\n\t\t\t\t\"ta:r\": \"text-align:right;\",\n\t\t\t\t\"ta:j\": \"text-align:justify;\",\n\t\t\t\t\"ta-lst\": \"text-align-last:|;\",\n\t\t\t\t\"tal:a\": \"text-align-last:auto;\",\n\t\t\t\t\"tal:l\": \"text-align-last:left;\",\n\t\t\t\t\"tal:c\": \"text-align-last:center;\",\n\t\t\t\t\"tal:r\": \"text-align-last:right;\",\n\t\t\t\t\"td\": \"text-decoration:${1:none};\",\n\t\t\t\t\"td:n\": \"text-decoration:none;\",\n\t\t\t\t\"td:u\": \"text-decoration:underline;\",\n\t\t\t\t\"td:o\": \"text-decoration:overline;\",\n\t\t\t\t\"td:l\": \"text-decoration:line-through;\",\n\t\t\t\t\"te\": \"text-emphasis:|;\",\n\t\t\t\t\"te:n\": \"text-emphasis:none;\",\n\t\t\t\t\"te:ac\": \"text-emphasis:accent;\",\n\t\t\t\t\"te:dt\": \"text-emphasis:dot;\",\n\t\t\t\t\"te:c\": \"text-emphasis:circle;\",\n\t\t\t\t\"te:ds\": \"text-emphasis:disc;\",\n\t\t\t\t\"te:b\": \"text-emphasis:before;\",\n\t\t\t\t\"te:a\": \"text-emphasis:after;\",\n\t\t\t\t\"th\": \"text-height:|;\",\n\t\t\t\t\"th:a\": \"text-height:auto;\",\n\t\t\t\t\"th:f\": \"text-height:font-size;\",\n\t\t\t\t\"th:t\": \"text-height:text-size;\",\n\t\t\t\t\"th:m\": \"text-height:max-size;\",\n\t\t\t\t\"ti\": \"text-indent:|;\",\n\t\t\t\t\"ti:-\": \"text-indent:-9999px;\",\n\t\t\t\t\"tj\": \"text-justify:|;\",\n\t\t\t\t\"tj:a\": \"text-justify:auto;\",\n\t\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\n\t\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\n\t\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\n\t\t\t\t\"tj:d\": \"text-justify:distribute;\",\n\t\t\t\t\"tj:k\": \"text-justify:kashida;\",\n\t\t\t\t\"tj:t\": \"text-justify:tibetan;\",\n\t\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\n\t\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\n\t\t\t\t\"tov:c\": \"text-overflow:clip;\",\n\t\t\t\t\"to\": \"text-outline:|;\",\n\t\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\n\t\t\t\t\"to:n\": \"text-outline:none;\",\n\t\t\t\t\"tr\": \"text-replace:|;\",\n\t\t\t\t\"tr:n\": \"text-replace:none;\",\n\t\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\n\t\t\t\t\"tt:n\": \"text-transform:none;\",\n\t\t\t\t\"tt:c\": \"text-transform:capitalize;\",\n\t\t\t\t\"tt:u\": \"text-transform:uppercase;\",\n\t\t\t\t\"tt:l\": \"text-transform:lowercase;\",\n\t\t\t\t\"tw\": \"text-wrap:|;\",\n\t\t\t\t\"tw:n\": \"text-wrap:normal;\",\n\t\t\t\t\"tw:no\": \"text-wrap:none;\",\n\t\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\n\t\t\t\t\"tw:s\": \"text-wrap:suppress;\",\n\t\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\n\t\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\n\t\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\n\t\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\n\t\t\t\t\"tsh:n\": \"text-shadow:none;\",\n\t\t\t\t\"trf\": \"transform:|;\",\n\t\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\n\t\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\n\t\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\n\t\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\n\t\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\n\t\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\n\t\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\n\t\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\n\t\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\n\t\t\t\t\"trfo\": \"transform-origin:|;\",\n\t\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\n\t\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\n\t\t\t\t\"trsde\": \"transition-delay:${1:time};\",\n\t\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\n\t\t\t\t\"trsp\": \"transition-property:${1:prop};\",\n\t\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\n\t\t\t\t\"lh\": \"line-height:|;\",\n\t\t\t\t\"whs\": \"white-space:|;\",\n\t\t\t\t\"whs:n\": \"white-space:normal;\",\n\t\t\t\t\"whs:p\": \"white-space:pre;\",\n\t\t\t\t\"whs:nw\": \"white-space:nowrap;\",\n\t\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\n\t\t\t\t\"whs:pl\": \"white-space:pre-line;\",\n\t\t\t\t\"whsc\": \"white-space-collapse:|;\",\n\t\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\n\t\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\n\t\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\n\t\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\n\t\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\n\t\t\t\t\"wob\": \"word-break:|;\",\n\t\t\t\t\"wob:n\": \"word-break:normal;\",\n\t\t\t\t\"wob:k\": \"word-break:keep-all;\",\n\t\t\t\t\"wob:ba\": \"word-break:break-all;\",\n\t\t\t\t\"wos\": \"word-spacing:|;\",\n\t\t\t\t\"wow\": \"word-wrap:|;\",\n\t\t\t\t\"wow:nm\": \"word-wrap:normal;\",\n\t\t\t\t\"wow:n\": \"word-wrap:none;\",\n\t\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\n\t\t\t\t\"wow:s\": \"word-wrap:suppress;\",\n\t\t\t\t\"wow:b\": \"word-wrap:break-word;\",\n\t\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\n\t\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\n\t\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\n\t\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\n\t\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\n\t\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\n\t\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\n\t\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\n\t\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\n\t\t\t\t\"lts\": \"letter-spacing:|;\",\n\t\t\t\t\"lts-n\": \"letter-spacing:normal;\",\n\t\t\t\t\"f\": \"font:|;\",\n\t\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\n\t\t\t\t\"fw\": \"font-weight:|;\",\n\t\t\t\t\"fw:n\": \"font-weight:normal;\",\n\t\t\t\t\"fw:b\": \"font-weight:bold;\",\n\t\t\t\t\"fw:br\": \"font-weight:bolder;\",\n\t\t\t\t\"fw:lr\": \"font-weight:lighter;\",\n\t\t\t\t\"fs\": \"font-style:${italic};\",\n\t\t\t\t\"fs:n\": \"font-style:normal;\",\n\t\t\t\t\"fs:i\": \"font-style:italic;\",\n\t\t\t\t\"fs:o\": \"font-style:oblique;\",\n\t\t\t\t\"fv\": \"font-variant:|;\",\n\t\t\t\t\"fv:n\": \"font-variant:normal;\",\n\t\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\n\t\t\t\t\"fz\": \"font-size:|;\",\n\t\t\t\t\"fza\": \"font-size-adjust:|;\",\n\t\t\t\t\"fza:n\": \"font-size-adjust:none;\",\n\t\t\t\t\"ff\": \"font-family:|;\",\n\t\t\t\t\"ff:s\": \"font-family:serif;\",\n\t\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\n\t\t\t\t\"ff:c\": \"font-family:cursive;\",\n\t\t\t\t\"ff:f\": \"font-family:fantasy;\",\n\t\t\t\t\"ff:m\": \"font-family:monospace;\",\n\t\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\n\t\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\n\t\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\n\t\t\t\t\"fef\": \"font-effect:|;\",\n\t\t\t\t\"fef:n\": \"font-effect:none;\",\n\t\t\t\t\"fef:eg\": \"font-effect:engrave;\",\n\t\t\t\t\"fef:eb\": \"font-effect:emboss;\",\n\t\t\t\t\"fef:o\": \"font-effect:outline;\",\n\t\t\t\t\"fem\": \"font-emphasize:|;\",\n\t\t\t\t\"femp\": \"font-emphasize-position:|;\",\n\t\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\n\t\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\n\t\t\t\t\"fems\": \"font-emphasize-style:|;\",\n\t\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\n\t\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\n\t\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\n\t\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\n\t\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\n\t\t\t\t\"fsm\": \"font-smooth:|;\",\n\t\t\t\t\"fsm:a\": \"font-smooth:auto;\",\n\t\t\t\t\"fsm:n\": \"font-smooth:never;\",\n\t\t\t\t\"fsm:aw\": \"font-smooth:always;\",\n\t\t\t\t\"fst\": \"font-stretch:|;\",\n\t\t\t\t\"fst:n\": \"font-stretch:normal;\",\n\t\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\n\t\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\n\t\t\t\t\"fst:c\": \"font-stretch:condensed;\",\n\t\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\n\t\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\n\t\t\t\t\"fst:e\": \"font-stretch:expanded;\",\n\t\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\n\t\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\n\t\t\t\t\"op\": \"opacity:|;\",\n\t\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\n\t\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\n\t\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\n\t\t\t\t\"rsz\": \"resize:|;\",\n\t\t\t\t\"rsz:n\": \"resize:none;\",\n\t\t\t\t\"rsz:b\": \"resize:both;\",\n\t\t\t\t\"rsz:h\": \"resize:horizontal;\",\n\t\t\t\t\"rsz:v\": \"resize:vertical;\",\n\t\t\t\t\"cur\": \"cursor:${pointer};\",\n\t\t\t\t\"cur:a\": \"cursor:auto;\",\n\t\t\t\t\"cur:d\": \"cursor:default;\",\n\t\t\t\t\"cur:c\": \"cursor:crosshair;\",\n\t\t\t\t\"cur:ha\": \"cursor:hand;\",\n\t\t\t\t\"cur:he\": \"cursor:help;\",\n\t\t\t\t\"cur:m\": \"cursor:move;\",\n\t\t\t\t\"cur:p\": \"cursor:pointer;\",\n\t\t\t\t\"cur:t\": \"cursor:text;\",\n\t\t\t\t\"pgbb\": \"page-break-before:|;\",\n\t\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\n\t\t\t\t\"pgbb:al\": \"page-break-before:always;\",\n\t\t\t\t\"pgbb:l\": \"page-break-before:left;\",\n\t\t\t\t\"pgbb:r\": \"page-break-before:right;\",\n\t\t\t\t\"pgbi\": \"page-break-inside:|;\",\n\t\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\n\t\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\n\t\t\t\t\"pgba\": \"page-break-after:|;\",\n\t\t\t\t\"pgba:au\": \"page-break-after:auto;\",\n\t\t\t\t\"pgba:al\": \"page-break-after:always;\",\n\t\t\t\t\"pgba:l\": \"page-break-after:left;\",\n\t\t\t\t\"pgba:r\": \"page-break-after:right;\",\n\t\t\t\t\"orp\": \"orphans:|;\",\n\t\t\t\t\"us\": \"user-select:${none};\",\n\t\t\t\t\"wid\": \"widows:|;\",\n\t\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\n\t\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\n\t\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\n\t\t\t}\n\t\t},\n\n\t\t\"html\": {\n\t\t\t\"filters\": \"html\",\n\t\t\t\"profile\": \"html\",\n\t\t\t\"snippets\": {\n\t\t\t\t\"!!!\": \"<!doctype html>\",\n\t\t\t\t\"!!!4t\": \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\n\t\t\t\t\"!!!4s\": \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\n\t\t\t\t\"!!!xt\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\n\t\t\t\t\"!!!xs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\n\t\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\n\n\t\t\t\t\"c\": \"<!-- |${child} -->\",\n\t\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\n\t\t\t},\n\n\t\t\t\"abbreviations\": {\n\t\t\t\t\"!\": \"html:5\",\n\t\t\t\t\"a\": \"<a href=\\\"\\\">\",\n\t\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\n\t\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\n\t\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\n\t\t\t\t\"acronym\": \"<acronym title=\\\"\\\">\",\n\t\t\t\t\"base\": \"<base href=\\\"\\\" />\",\n\t\t\t\t\"basefont\": \"<basefont/>\",\n\t\t\t\t\"br\": \"<br/>\",\n\t\t\t\t\"frame\": \"<frame/>\",\n\t\t\t\t\"hr\": \"<hr/>\",\n\t\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\n\t\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\n\t\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\n\t\t\t\t\"col\": \"<col/>\",\n\t\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\n\t\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\n\t\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\n\t\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\n\t\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\n\t\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\n\t\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\n\t\t\t\t\"meta\": \"<meta/>\",\n\t\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\n\t\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\n\t\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, user-scalable=${2:no}, initial-scale=${3:1.0}, maximum-scale=${4:1.0}, minimum-scale=${5:1.0}\\\" />\",\n\t\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\n\t\t\t\t\"style\": \"<style>\",\n\t\t\t\t\"script\": \"<script>\",\n\t\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\n\t\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\n\t\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\n\t\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\n\t\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\n\t\t\t\t\"map\": \"<map name=\\\"\\\">\",\n\t\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\t\"form\": \"<form action=\\\"\\\">\",\n\t\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\n\t\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\n\t\t\t\t\"label\": \"<label for=\\\"\\\">\",\n\t\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\n\t\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\n\t\t\t\t\"input:hidden\": \"input[type=hidden name]\",\n\t\t\t\t\"input:h\": \"input:hidden\",\n\t\t\t\t\"input:text\": \"inp\",\n\t\t\t\t\"input:t\": \"inp\",\n\t\t\t\t\"input:search\": \"inp[type=search]\",\n\t\t\t\t\"input:email\": \"inp[type=email]\",\n\t\t\t\t\"input:url\": \"inp[type=url]\",\n\t\t\t\t\"input:password\": \"inp[type=password]\",\n\t\t\t\t\"input:p\": \"input:password\",\n\t\t\t\t\"input:datetime\": \"inp[type=datetime]\",\n\t\t\t\t\"input:date\": \"inp[type=date]\",\n\t\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\t\t\t\"input:month\": \"inp[type=month]\",\n\t\t\t\t\"input:week\": \"inp[type=week]\",\n\t\t\t\t\"input:time\": \"inp[type=time]\",\n\t\t\t\t\"input:number\": \"inp[type=number]\",\n\t\t\t\t\"input:color\": \"inp[type=color]\",\n\t\t\t\t\"input:checkbox\": \"inp[type=checkbox]\",\n\t\t\t\t\"input:c\": \"input:checkbox\",\n\t\t\t\t\"input:radio\": \"inp[type=radio]\",\n\t\t\t\t\"input:r\": \"input:radio\",\n\t\t\t\t\"input:range\": \"inp[type=range]\",\n\t\t\t\t\"input:file\": \"inp[type=file]\",\n\t\t\t\t\"input:f\": \"input:file\",\n\t\t\t\t\"input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\n\t\t\t\t\"input:s\": \"input:submit\",\n\t\t\t\t\"input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\t\"input:i\": \"input:image\",\n\t\t\t\t\"input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\n\t\t\t\t\"input:b\": \"input:button\",\n\t\t\t\t\"isindex\": \"<isindex/>\",\n\t\t\t\t\"input:reset\": \"input:button[type=reset]\",\n\t\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\n\t\t\t\t\"select:disabled\": \"select[disabled]\",\n\t\t\t\t\"select:d\": \"select[disabled]\",\n\t\t\t\t\"option\": \"<option value=\\\"\\\">\",\n\t\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\n\t\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\n\t\t\t\t\"menu:context\": \"menu[type=context]>\",\n\t\t\t\t\"menu:c\": \"menu:context\",\n\t\t\t\t\"menu:toolbar\": \"menu[type=toolbar]>\",\n\t\t\t\t\"menu:t\": \"menu:toolbar\",\n\t\t\t\t\"video\": \"<video src=\\\"\\\">\",\n\t\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\n\t\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\n\t\t\t\t\"keygen\": \"<keygen/>\",\n\t\t\t\t\"command\": \"<command/>\",\n\t\t\t\t\"button:submit\": \"button[type=submit]\",\n\t\t\t\t\"button:s\": \"button[type=submit]\",\n\t\t\t\t\"button:reset\": \"button[type=reset]\",\n\t\t\t\t\"button:r\": \"button[type=reset]\",\n\t\t\t\t\"button:disabled\": \"button[disabled]\",\n\t\t\t\t\"button:d\": \"button[disabled]\",\n\t\t\t\t\"fieldset:disabled\": \"fieldset[disabled]\",\n\t\t\t\t\"fieldset:d\": \"fieldset[disabled]\",\n\n\t\t\t\t\"bq\": \"blockquote\",\n\t\t\t\t\"acr\": \"acronym\",\n\t\t\t\t\"fig\": \"figure\",\n\t\t\t\t\"figc\": \"figcaption\",\n\t\t\t\t\"ifr\": \"iframe\",\n\t\t\t\t\"emb\": \"embed\",\n\t\t\t\t\"obj\": \"object\",\n\t\t\t\t\"src\": \"source\",\n\t\t\t\t\"cap\": \"caption\",\n\t\t\t\t\"colg\": \"colgroup\",\n\t\t\t\t\"fst\": \"fieldset\",\n\t\t\t\t\"fst:d\": \"fieldset[disabled]\",\n\t\t\t\t\"btn\": \"button\",\n\t\t\t\t\"btn:b\": \"button[type=button]\",\n\t\t\t\t\"btn:r\": \"button[type=reset]\",\n\t\t\t\t\"btn:s\": \"button[type=submit]\",\n\t\t\t\t\"btn:d\": \"button[disabled]\",\n\t\t\t\t\"optg\": \"optgroup\",\n\t\t\t\t\"opt\": \"option\",\n\t\t\t\t\"tarea\": \"textarea\",\n\t\t\t\t\"leg\": \"legend\",\n\t\t\t\t\"sect\": \"section\",\n\t\t\t\t\"art\": \"article\",\n\t\t\t\t\"hdr\": \"header\",\n\t\t\t\t\"ftr\": \"footer\",\n\t\t\t\t\"adr\": \"address\",\n\t\t\t\t\"dlg\": \"dialog\",\n\t\t\t\t\"str\": \"strong\",\n\t\t\t\t\"prog\": \"progress\",\n\t\t\t\t\"fset\": \"fieldset\",\n\t\t\t\t\"fset:d\": \"fieldset[disabled]\",\n\t\t\t\t\"datag\": \"datagrid\",\n\t\t\t\t\"datal\": \"datalist\",\n\t\t\t\t\"kg\": \"keygen\",\n\t\t\t\t\"out\": \"output\",\n\t\t\t\t\"det\": \"details\",\n\t\t\t\t\"cmd\": \"command\",\n\t\t\t\t\"doc\": \"html>(head>meta[charset=UTF-8]+title{${1:Document}})+body\",\n\t\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\n\n\t\t\t\t\"html:4t\": \"!!!4t+doc4[lang=${lang}]\",\n\t\t\t\t\"html:4s\": \"!!!4s+doc4[lang=${lang}]\",\n\t\t\t\t\"html:xt\": \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\t\"html:xs\": \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\t\"html:5\": \"!!!+doc[lang=${lang}]\",\n\n\t\t\t\t\"ol+\": \"ol>li\",\n\t\t\t\t\"ul+\": \"ul>li\",\n\t\t\t\t\"dl+\": \"dl>dt+dd\",\n\t\t\t\t\"map+\": \"map>area\",\n\t\t\t\t\"table+\": \"table>tr>td\",\n\t\t\t\t\"colgroup+\": \"colgroup>col\",\n\t\t\t\t\"colg+\": \"colgroup>col\",\n\t\t\t\t\"tr+\": \"tr>td\",\n\t\t\t\t\"select+\": \"select>option\",\n\t\t\t\t\"optgroup+\": \"optgroup>option\",\n\t\t\t\t\"optg+\": \"optgroup>option\"\n\t\t\t}\n\t\t},\n\n\t\t\"xml\": {\n\t\t\t\"extends\": \"html\",\n\t\t\t\"profile\": \"xml\",\n\t\t\t\"filters\": \"html\"\n\t\t},\n\n\t\t\"xsl\": {\n\t\t\t\"extends\": \"html\",\n\t\t\t\"profile\": \"xml\",\n\t\t\t\"filters\": \"html, xsl\",\n\t\t\t\"abbreviations\": {\n\t\t\t\t\"tm\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\n\t\t\t\t\"tmatch\": \"tm\",\n\t\t\t\t\"tn\": \"<xsl:template name=\\\"\\\">\",\n\t\t\t\t\"tname\": \"tn\",\n\t\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\n\t\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\n\t\t\t\t\"api\": \"<xsl:apply-imports/>\",\n\t\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\n\t\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\n\n\t\t\t\t\"ch\": \"<xsl:choose>\",\n\t\t\t\t\"xsl:when\": \"<xsl:when test=\\\"\\\">\",\n\t\t\t\t\"wh\": \"xsl:when\",\n\t\t\t\t\"ot\": \"<xsl:otherwise>\",\n\t\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\n\n\t\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\n\t\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\n\t\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\n\n\t\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\n\t\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\n\t\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\n\n\t\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\n\t\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\n\t\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\n\t\t\t\t\"each\": \"<xsl:for-each select=\\\"\\\">\",\n\t\t\t\t\"for\": \"each\",\n\t\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\n\n\t\t\t\t\"com\": \"<xsl:comment>\",\n\t\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\n\t\t\t\t\"fall\": \"<xsl:fallback>\",\n\t\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\n\t\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\n\t\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\n\t\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\n\t\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\n\t\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\n\n\t\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\n\t\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\n\t\t\t},\n\t\t\t\"snippets\": {\n\t\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n\t\t\t}\n\t\t},\n\n\t\t\"haml\": {\n\t\t\t\"filters\": \"haml\",\n\t\t\t\"extends\": \"html\",\n\t\t\t\"profile\": \"xml\"\n\t\t},\n\n\t\t\"scss\": {\n\t\t\t\"extends\": \"css\"\n\t\t},\n\n\t\t\"sass\": {\n\t\t\t\"extends\": \"css\"\n\t\t},\n\n\t\t\"less\": {\n\t\t\t\"extends\": \"css\"\n\t\t},\n\n\t\t\"stylus\": {\n\t\t\t\"extends\": \"css\"\n\t\t},\n\n\t\t\"styl\": {\n\t\t\t\"extends\": \"stylus\"\n\t\t}\n\t};\n\tvar res = require('resources');\n\tvar userData = res.getVocabulary('user') || {};\n\tres.setVocabulary(require('utils').deepMerge(userData, snippets), 'user');\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/30.4b1b4033534c8185208f.js","//     Underscore.js 1.3.3\n//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\nvar _ = (function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.3.3';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    if (obj.length === +obj.length) results.length = obj.length;\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError('Reduce of empty array with no initial value');\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = _.toArray(obj).reverse();\n    if (context && !initial) iterator = _.bind(iterator, context);\n    return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    found = any(obj, function(value) {\n      return value === target;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (_.isFunction(method) ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var shuffled = [], rand;\n    each(obj, function(value, index, list) {\n      rand = Math.floor(Math.random() * (index + 1));\n      shuffled[index] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, val, context) {\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      if (a === void 0) return 1;\n      if (b === void 0) return -1;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, val) {\n    var result = {};\n    var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj)                                     return [];\n    if (_.isArray(obj))                           return slice.call(obj);\n    if (_.isArguments(obj))                       return slice.call(obj);\n    if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.isArray(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especcialy useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator) {\n    var initial = iterator ? _.map(array, iterator) : array;\n    var results = [];\n    // The `isSorted` flag is irrelevant if the array only contains two elements.\n    if (array.length < 3) isSorted = true;\n    _.reduce(initial, function (memo, value, index) {\n      if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {\n        memo.push(value);\n        results.push(array[index]);\n      }\n      return memo;\n    }, []);\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = _.flatten(slice.call(arguments, 1), true);\n    return _.filter(array, function(value){ return !_.include(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (i in array && array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function bind(func, context) {\n    var bound, args;\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError;\n    args = slice.call(arguments, 2);\n    return bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      ctor.prototype = func.prototype;\n      var self = new ctor;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (Object(result) === result) return result;\n      return self;\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, throttling, more, result;\n    var whenDone = _.debounce(function(){ more = throttling = false; }, wait);\n    return function() {\n      context = this; args = arguments;\n      var later = function() {\n        timeout = null;\n        if (more) func.apply(context, args);\n        whenDone();\n      };\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (throttling) {\n        more = true;\n      } else {\n        result = func.apply(context, args);\n      }\n      whenDone();\n      throttling = true;\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) func.apply(context, args);\n      };\n      if (immediate && !timeout) func.apply(context, args);\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments, 0));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var result = {};\n    each(_.flatten(slice.call(arguments, 1)), function(key) {\n      if (key in obj) result[key] = obj[key];\n    });\n    return result;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function.\n  function eq(a, b, stack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // Invoke a custom `isEqual` method if one is provided.\n    if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);\n    if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = stack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (stack[length] == a) return true;\n    }\n    // Add the first object to the stack of traversed objects.\n    stack.push(a);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          // Ensure commutative equality for sparse arrays.\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent.\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    stack.pop();\n    return result;\n  }\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return toString.call(obj) == '[object Arguments]';\n  };\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return toString.call(obj) == '[object Function]';\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n  };\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return _.isNumber(obj) && isFinite(obj);\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    // `NaN` is the only value for which `===` is not reflexive.\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return toString.call(obj) == '[object RegExp]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Has own property?\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Escape a string for HTML interpolation.\n  _.escape = function(string) {\n    return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g,'&#x2F;');\n  };\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /.^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    'r': '\\r',\n    'n': '\\n',\n    't': '\\t',\n    'u2028': '\\u2028',\n    'u2029': '\\u2029'\n  };\n\n  for (var p in escapes) escapes[escapes[p]] = p;\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n  var unescaper = /\\\\(\\\\|'|r|n|t|u2028|u2029)/g;\n\n  // Within an interpolation, evaluation, or escaping, remove HTML escaping\n  // that had been previously added.\n  var unescape = function(code) {\n    return code.replace(unescaper, function(match, escape) {\n      return escapes[escape];\n    });\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    settings = _.defaults(settings || {}, _.templateSettings);\n\n    // Compile the template source, taking care to escape characters that\n    // cannot be included in a string literal and then unescape them in code\n    // blocks.\n    var source = \"__p+='\" + text\n      .replace(escaper, function(match) {\n        return '\\\\' + escapes[match];\n      })\n      .replace(settings.escape || noMatch, function(match, code) {\n        return \"'+\\n_.escape(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.interpolate || noMatch, function(match, code) {\n        return \"'+\\n(\" + unescape(code) + \")+\\n'\";\n      })\n      .replace(settings.evaluate || noMatch, function(match, code) {\n        return \"';\\n\" + unescape(code) + \"\\n;__p+='\";\n      }) + \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __p='';\" +\n      \"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\\n\" +\n      source + \"return __p;\\n\";\n\n    var render = new Function(settings.variable || 'obj', '_', source);\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for build time\n    // precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' +\n      source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      var wrapped = this._wrapped;\n      method.apply(wrapped, arguments);\n      var length = wrapped.length;\n      if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];\n      return result(wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n  return _;\n}).call({});\n/**\n * Core Emmet object, available in global scope\n */\nvar emmet = (function(global) {\n\tvar defaultSyntax = 'html';\n\tvar defaultProfile = 'plain';\n\t\n\tif (typeof _ == 'undefined') {\n\t\ttry {\n\t\t\t// avoid collisions with RequireJS loader\n\t\t\t// also, JS obfuscators tends to translate\n\t\t\t// a[\"name\"] to a.name, which also breaks RequireJS\n\t\t\t_ = global[['require'][0]]('underscore'); // node.js\n\t\t} catch (e) {}\n\t}\n\n\tif (typeof _ == 'undefined') {\n\t\tthrow 'Cannot access to Underscore.js lib';\n\t}\n\n\t/** List of registered modules */\n\tvar modules = {\n\t\t_ : _\n\t};\n\t\n\t/**\n\t * Shared empty constructor function to aid in prototype-chain creation.\n\t */\n\tvar ctor = function(){};\n\t\n\t/**\n\t * Helper function to correctly set up the prototype chain, for subclasses.\n\t * Similar to `goog.inherits`, but uses a hash of prototype properties and\n\t * class properties to be extended.\n\t * Took it from Backbone.\n\t * @param {Object} parent\n\t * @param {Object} protoProps\n\t * @param {Object} staticProps\n\t * @returns {Object}\n\t */\n\tfunction inherits(parent, protoProps, staticProps) {\n\t\tvar child;\n\n\t\t// The constructor function for the new subclass is either defined by\n\t\t// you (the \"constructor\" property in your `extend` definition), or\n\t\t// defaulted by us to simply call the parent's constructor.\n\t\tif (protoProps && protoProps.hasOwnProperty('constructor')) {\n\t\t\tchild = protoProps.constructor;\n\t\t} else {\n\t\t\tchild = function() {\n\t\t\t\tparent.apply(this, arguments);\n\t\t\t};\n\t\t}\n\n\t\t// Inherit class (static) properties from parent.\n\t\t_.extend(child, parent);\n\n\t\t// Set the prototype chain to inherit from `parent`, without calling\n\t\t// `parent`'s constructor function.\n\t\tctor.prototype = parent.prototype;\n\t\tchild.prototype = new ctor();\n\n\t\t// Add prototype properties (instance properties) to the subclass,\n\t\t// if supplied.\n\t\tif (protoProps)\n\t\t\t_.extend(child.prototype, protoProps);\n\n\t\t// Add static properties to the constructor function, if supplied.\n\t\tif (staticProps)\n\t\t\t_.extend(child, staticProps);\n\n\t\t// Correctly set child's `prototype.constructor`.\n\t\tchild.prototype.constructor = child;\n\n\t\t// Set a convenience property in case the parent's prototype is needed\n\t\t// later.\n\t\tchild.__super__ = parent.prototype;\n\n\t\treturn child;\n\t};\n\t\n\t/**\n\t * @type Function Function that loads module definition if it's not defined\n\t */\n\tvar moduleLoader = null;\n\t\n\t/**\n\t * Generic Emmet module loader (actually, it doesnt load anything, just \n\t * returns module reference). Not using `require` name to avoid conflicts\n\t * with Node.js and RequireJS\n\t */\n\tfunction r(name) {\n\t\tif (!(name in modules) && moduleLoader)\n\t\t\tmoduleLoader(name);\n\t\t\n\t\treturn modules[name];\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Simple, AMD-like module definition. The module will be added into\n\t\t * <code>emmet</code> object and will be available via\n\t\t * <code>emmet.require(name)</code> or <code>emmet[name]</code>\n\t\t * @param {String} name\n\t\t * @param {Function} factory\n\t\t * @memberOf emmet\n\t\t */\n\t\tdefine: function(name, factory) {\n\t\t\t// do not let redefine existing properties\n\t\t\tif (!(name in modules)) {\n\t\t\t\tmodules[name] = _.isFunction(factory) \n\t\t\t\t\t? this.exec(factory)\n\t\t\t\t\t: factory;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to Emmet module\n\t\t * @param {String} name Module name\n\t\t */\n\t\trequire: r,\n\t\t\n\t\t/**\n\t\t * Helper method that just executes passed function but with all \n\t\t * important arguments like 'require' and '_'\n\t\t * @param {Function} fn\n\t\t * @param {Object} context Execution context\n\t\t */\n\t\texec: function(fn, context) {\n\t\t\treturn fn.call(context || global, _.bind(r, this), _, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * The self-propagating extend function for classes.\n\t\t * Took it from Backbone \n\t\t * @param {Object} protoProps\n\t\t * @param {Object} classProps\n\t\t * @returns {Object}\n\t\t */\n\t\textend: function(protoProps, classProps) {\n\t\t\tvar child = inherits(this, protoProps, classProps);\n\t\t\tchild.extend = this.extend;\n\t\t\t// a hack required to WSH inherit `toString` method\n\t\t\tif (protoProps.hasOwnProperty('toString'))\n\t\t\t\tchild.prototype.toString = protoProps.toString;\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * The essential function that expands Emmet abbreviation\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {String} syntax Abbreviation's context syntax\n\t\t * @param {String} profile Output profile (or its name)\n\t\t * @param {Object} contextNode Contextual node where abbreviation is\n\t\t * written\n\t\t * @return {String}\n\t\t */\n\t\texpandAbbreviation: function(abbr, syntax, profile, contextNode) {\n\t\t\tif (!abbr) return '';\n\t\t\t\n\t\t\tsyntax = syntax || defaultSyntax;\n//\t\t\tprofile = profile || defaultProfile;\n\t\t\t\n\t\t\tvar filters = r('filters');\n\t\t\tvar parser = r('abbreviationParser');\n\t\t\t\n\t\t\tprofile = r('profile').get(profile, syntax);\n\t\t\tr('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar outputTree = parser.parse(data[0], {\n\t\t\t\tsyntax: syntax, \n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\t\n\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\tfilters.apply(outputTree, filtersList, profile);\n\t\t\treturn outputTree.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default syntax name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultSyntax: function() {\n\t\t\treturn defaultSyntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns default profile name used in abbreviation engine\n\t\t * @returns {String}\n\t\t */\n\t\tdefaultProfile: function() {\n\t\t\treturn defaultProfile;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Log message into console if it exists\n\t\t */\n\t\tlog: function() {\n\t\t\tif (global.console && global.console.log)\n\t\t\t\tglobal.console.log.apply(global.console, arguments);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Setups function that should synchronously load undefined modules\n\t\t * @param {Function} fn\n\t\t */\n\t\tsetModuleLoader: function(fn) {\n\t\t\tmoduleLoader = fn;\n\t\t}\n\t};\n})(this);\n\n// export core for Node.JS\nif (typeof exports !== 'undefined') {\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\texports = module.exports = emmet;\n\t}\n\texports.emmet = emmet;\n}\n\n// export as Require.js module\nif (typeof define !== 'undefined') {\n\tdefine('emmet', [], emmet);\n}/**\n * Emmet abbreviation parser.\n * Takes string abbreviation and recursively parses it into a tree. The parsed \n * tree can be transformed into a string representation with \n * <code>toString()</code> method. Note that string representation is defined\n * by custom processors (called <i>filters</i>), not by abbreviation parser \n * itself.\n * \n * This module can be extended with custom pre-/post-processors to shape-up\n * final tree or its representation. Actually, many features of abbreviation \n * engine are defined in other modules as tree processors\n * \n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @memberOf __abbreviationParser\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationParser', function(require, _) {\n\tvar reValidName = /^[\\w\\-\\$\\:@\\!%]+\\+?$/i;\n\tvar reWord = /[\\w\\-:\\$@]/;\n\t\n\tvar pairs = {\n\t\t'[': ']',\n\t\t'(': ')',\n\t\t'{': '}'\n\t};\n\t\n\tvar spliceFn = Array.prototype.splice;\n\t\n\tvar preprocessors = [];\n\tvar postprocessors = [];\n\tvar outputProcessors = [];\n\t\n\t/**\n\t * @type AbbreviationNode\n\t */\n\tfunction AbbreviationNode(parent) {\n\t\t/** @type AbbreviationNode */\n\t\tthis.parent = null;\n\t\tthis.children = [];\n\t\tthis._attributes = [];\n\t\t\n\t\t/** @type String Raw abbreviation for current node */\n\t\tthis.abbreviation = '';\n\t\tthis.counter = 1;\n\t\tthis._name = null;\n\t\tthis._text = '';\n\t\tthis.repeatCount = 1;\n\t\tthis.hasImplicitRepeat = false;\n\t\t\n\t\t/** Custom data dictionary */\n\t\tthis._data = {};\n\t\t\n\t\t// output properties\n\t\tthis.start = '';\n\t\tthis.end = '';\n\t\tthis.content = '';\n\t\tthis.padding = '';\n\t}\n\t\n\tAbbreviationNode.prototype = {\n\t\t/**\n\t\t * Adds passed node as child or creates new child\n\t\t * @param {AbbreviationNode} child\n\t\t * @param {Number} position Index in children array where child should \n\t\t * be inserted\n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\taddChild: function(child, position) {\n\t\t\tchild = child || new AbbreviationNode;\n\t\t\tchild.parent = this;\n\t\t\t\n\t\t\tif (_.isUndefined(position)) {\n\t\t\t\tthis.children.push(child);\n\t\t\t} else {\n\t\t\t\tthis.children.splice(position, 0, child);\n\t\t\t}\n\t\t\t\n\t\t\treturn child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates a deep copy of current node\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tclone: function() {\n\t\t\tvar node = new AbbreviationNode();\n\t\t\tvar attrs = ['abbreviation', 'counter', '_name', '_text', 'repeatCount', 'hasImplicitRepeat', 'start', 'end', 'content', 'padding'];\n\t\t\t_.each(attrs, function(a) {\n\t\t\t\tnode[a] = this[a];\n\t\t\t}, this);\n\t\t\t\n\t\t\t// clone attributes\n\t\t\tnode._attributes = _.map(this._attributes, function(attr) {\n\t\t\t\treturn _.clone(attr);\n\t\t\t});\n\t\t\t\n\t\t\tnode._data = _.clone(this._data);\n\t\t\t\n\t\t\t// clone children\n\t\t\tnode.children = _.map(this.children, function(child) {\n\t\t\t\tchild = child.clone();\n\t\t\t\tchild.parent = node;\n\t\t\t\treturn child;\n\t\t\t});\n\t\t\t\n\t\t\treturn node;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes current node from parents child list\n\t\t * @returns {AbbreviationNode} Current node itself\n\t\t */\n\t\tremove: function() {\n\t\t\tif (this.parent) {\n\t\t\t\tthis.parent.children = _.without(this.parent.children, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces current node in parents children list with passed nodes\n\t\t * @param {AbbreviationNode} node Replacement node or array of nodes\n\t\t */\n\t\treplace: function() {\n\t\t\tvar parent = this.parent;\n\t\t\tvar ix = _.indexOf(parent.children, this);\n\t\t\tvar items = _.flatten(arguments);\n\t\t\tspliceFn.apply(parent.children, [ix, 1].concat(items));\n\t\t\t\n\t\t\t// update parent\n\t\t\t_.each(items, function(item) {\n\t\t\t\titem.parent = parent;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively sets <code>property</code> to <code>value</code> of current\n\t\t * node and its children \n\t\t * @param {String} name Property to update\n\t\t * @param {Object} value New property value\n\t\t */\n\t\tupdateProperty: function(name, value) {\n\t\t\tthis[name] = value;\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tchild.updateProperty(name, value);\n\t\t\t});\n\t\t\t\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds first child node that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tfind: function(fn) {\n\t\t\treturn this.findAll(fn)[0];\n//\t\t\tif (!_.isFunction(fn)) {\n//\t\t\t\tvar elemName = fn.toLowerCase();\n//\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n//\t\t\t}\n//\t\t\t\n//\t\t\tvar result = null;\n//\t\t\t_.find(this.children, function(child) {\n//\t\t\t\tif (fn(child)) {\n//\t\t\t\t\treturn result = child;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\treturn result = child.find(fn);\n//\t\t\t});\n//\t\t\t\n//\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds all child nodes that matches truth test for passed \n\t\t * <code>fn</code> function\n\t\t * @param {Function} fn\n\t\t * @returns {Array}\n\t\t */\n\t\tfindAll: function(fn) {\n\t\t\tif (!_.isFunction(fn)) {\n\t\t\t\tvar elemName = fn.toLowerCase();\n\t\t\t\tfn = function(item) {return item.name().toLowerCase() == elemName;};\n\t\t\t}\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t_.each(this.children, function(child) {\n\t\t\t\tif (fn(child))\n\t\t\t\t\tresult.push(child);\n\t\t\t\t\n\t\t\t\tresult = result.concat(child.findAll(fn));\n\t\t\t});\n\t\t\t\n\t\t\treturn _.compact(result);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets/gets custom data\n\t\t * @param {String} name\n\t\t * @param {Object} value\n\t\t * @returns {Object}\n\t\t */\n\t\tdata: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\tthis._data[name] = value;\n\t\t\t\t\n\t\t\t\tif (name == 'resource' && require('elements').is(value, 'snippet')) {\n\t\t\t\t\t// setting snippet as matched resource: update `content`\n\t\t\t\t\t// property with snippet value\n\t\t\t\t\tthis.content = value.data;\n\t\t\t\t\tif (this._text) {\n\t\t\t\t\t\tthis.content = require('abbreviationUtils')\n\t\t\t\t\t\t\t.insertChildContent(value.data, this._text);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn this._data[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name of current node\n\t\t * @returns {String}\n\t\t */\n\t\tname: function() {\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element')) {\n\t\t\t\treturn res.name;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of attributes for current node\n\t\t * @returns {Array}\n\t\t */\n\t\tattributeList: function() {\n\t\t\tvar attrs = [];\n\t\t\t\n\t\t\tvar res = this.matchedResource();\n\t\t\tif (require('elements').is(res, 'element') && _.isArray(res.attributes)) {\n\t\t\t\tattrs = attrs.concat(res.attributes);\n\t\t\t}\n\t\t\t\n\t\t\treturn optimizeAttributes(attrs.concat(this._attributes));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or sets attribute value\n\t\t * @param {String} name Attribute name\n\t\t * @param {String} value New attribute value\n\t\t * @returns {String}\n\t\t */\n\t\tattribute: function(name, value) {\n\t\t\tif (arguments.length == 2) {\n\t\t\t\t// modifying attribute\n\t\t\t\tvar ix = _.indexOf(_.pluck(this._attributes, 'name'), name.toLowerCase());\n\t\t\t\tif (~ix) {\n\t\t\t\t\tthis._attributes[ix].value = value;\n\t\t\t\t} else {\n\t\t\t\t\tthis._attributes.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn (_.find(this.attributeList(), function(attr) {\n\t\t\t\treturn attr.name == name;\n\t\t\t}) || {}).value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns reference to the matched <code>element</code>, if any.\n\t\t * See {@link elements} module for a list of available elements\n\t\t * @returns {Object}\n\t\t */\n\t\tmatchedResource: function() {\n\t\t\treturn this.data('resource');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of current node in parents children list\n\t\t * @returns {Number}\n\t\t */\n\t\tindex: function() {\n\t\t\treturn this.parent ? _.indexOf(this.parent.children, this) : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets how many times current element should be repeated\n\t\t * @private\n\t\t */\n\t\t_setRepeat: function(count) {\n\t\t\tif (count) {\n\t\t\t\tthis.repeatCount = parseInt(count, 10) || 1;\n\t\t\t} else {\n\t\t\t\tthis.hasImplicitRepeat = true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets abbreviation that belongs to current node\n\t\t * @param {String} abbr\n\t\t */\n\t\tsetAbbreviation: function(abbr) {\n\t\t\tabbr = abbr || '';\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\t// find multiplier\n\t\t\tabbr = abbr.replace(/\\*(\\d+)?$/, function(str, repeatCount) {\n\t\t\t\tthat._setRepeat(repeatCount);\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\tthis.abbreviation = abbr;\n\t\t\t\n\t\t\tvar abbrText = extractText(abbr);\n\t\t\tif (abbrText) {\n\t\t\t\tabbr = abbrText.element;\n\t\t\t\tthis.content = this._text = abbrText.text;\n\t\t\t}\n\t\t\t\n\t\t\tvar abbrAttrs = parseAttributes(abbr);\n\t\t\tif (abbrAttrs) {\n\t\t\t\tabbr = abbrAttrs.element;\n\t\t\t\tthis._attributes = abbrAttrs.attributes;\n\t\t\t}\n\t\t\t\n\t\t\tthis._name = abbr;\n\t\t\t\n\t\t\t// validate name\n\t\t\tif (this._name && !reValidName.test(this._name)) {\n\t\t\t\tthrow 'Invalid abbreviation';\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of current node\n\t\t * @return {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar start = this.start;\n\t\t\tvar end = this.end;\n\t\t\tvar content = this.content;\n\t\t\t\n\t\t\t// apply output processors\n\t\t\tvar node = this;\n\t\t\t_.each(outputProcessors, function(fn) {\n\t\t\t\tstart = fn(start, node, 'start');\n\t\t\t\tcontent = fn(content, node, 'content');\n\t\t\t\tend = fn(end, node, 'end');\n\t\t\t});\n\t\t\t\n\t\t\t\n\t\t\tvar innerContent = _.map(this.children, function(child) {\n\t\t\t\treturn child.toString();\n\t\t\t}).join('');\n\t\t\t\n\t\t\tcontent = require('abbreviationUtils').insertChildContent(content, innerContent, {\n\t\t\t\tkeepVariable: false\n\t\t\t});\n\t\t\t\n\t\t\treturn start + utils.padString(content, this.padding) + end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node contains children with empty <code>expr</code>\n\t\t * property\n\t\t * @return {Boolean}\n\t\t */\n\t\thasEmptyChildren: function() {\n\t\t\treturn !!_.find(this.children, function(child) {\n\t\t\t\treturn child.isEmpty();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node has implied name that should be resolved\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasImplicitName: function() {\n\t\t\treturn !this._name && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current element is a grouping one, e.g. has no \n\t\t * representation but serves as a container for other nodes\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisGroup: function() {\n\t\t\treturn !this.abbreviation;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates empty node (i.e. without abbreviation). It may be a \n\t\t * grouping node and should not be outputted\n\t\t * @return {Boolean}\n\t\t */\n\t\tisEmpty: function() {\n\t\t\treturn !this.abbreviation && !this.children.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates that current node should be repeated\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisRepeating: function() {\n\t\t\treturn this.repeatCount > 1 || this.hasImplicitRepeat;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current node is a text-only node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisTextNode: function() {\n\t\t\treturn !this.name() && !this.attributeList().length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indicates whether this node may be used to build elements or snippets\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisElement: function() {\n\t\t\treturn !this.isEmpty() && !this.isTextNode();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns latest and deepest child of current tree\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tdeepestChild: function() {\n\t\t\tif (!this.children.length)\n\t\t\t\treturn null;\n\t\t\t\t\n\t\t\tvar deepestChild = this;\n\t\t\twhile (deepestChild.children.length) {\n\t\t\t\tdeepestChild = _.last(deepestChild.children);\n\t\t\t}\n\t\t\t\n\t\t\treturn deepestChild;\n\t\t}\n\t};\n\t\n\t/**\n\t * Returns stripped string: a string without first and last character.\n\t * Used for unquoting strings\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction stripped(str) {\n\t\treturn str.substring(1, str.length - 1);\n\t}\n\t\n\tfunction consumeQuotedValue(stream, quote) {\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch === quote)\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (ch == '\\\\')\n\t\t\t\tcontinue;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Parses abbreviation into a tree\n\t * @param {String} abbr\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction parseAbbreviation(abbr) {\n\t\tabbr = require('utils').trim(abbr);\n\t\t\n\t\tvar root = new AbbreviationNode;\n\t\tvar context = root.addChild(), ch;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\tvar loopProtector = 1000, multiplier;\n\t\t\n\t\twhile (!stream.eol() && --loopProtector > 0) {\n\t\t\tch = stream.peek();\n\t\t\t\n\t\t\tswitch (ch) {\n\t\t\t\tcase '(': // abbreviation group\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (stream.skipToPair('(', ')')) {\n\t\t\t\t\t\tvar inner = parseAbbreviation(stripped(stream.current()));\n\t\t\t\t\t\tif (multiplier = stream.match(/^\\*(\\d+)?/, true)) {\n\t\t\t\t\t\t\tcontext._setRepeat(multiplier[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t_.each(inner.children, function(child) {\n\t\t\t\t\t\t\tcontext.addChild(child);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \")\" found for character at ' + stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '>': // child operator\n\t\t\t\t\tcontext = context.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '+': // sibling operator\n\t\t\t\t\tcontext = context.parent.addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '^': // climb up operator\n\t\t\t\t\tvar parent = context.parent || context;\n\t\t\t\t\tcontext = (parent.parent || parent).addChild();\n\t\t\t\t\tstream.next();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault: // consume abbreviation\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(function(c) {\n\t\t\t\t\t\tif (c == '[' || c == '{') {\n\t\t\t\t\t\t\tif (stream.skipToPair(c, pairs[c])) {\n\t\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tthrow 'Invalid abbreviation: mo matching \"' + pairs[c] + '\" found for character at ' + stream.pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (c == '+') {\n\t\t\t\t\t\t\t// let's see if this is an expando marker\n\t\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\t\tvar isMarker = stream.eol() ||  ~'+>^*'.indexOf(stream.peek());\n\t\t\t\t\t\t\tstream.backUp(1);\n\t\t\t\t\t\t\treturn isMarker;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn c != '(' && isAllowedChar(c);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tcontext.setAbbreviation(stream.current());\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (loopProtector < 1)\n\t\t\tthrow 'Endless loop detected';\n\t\t\n\t\treturn root;\n\t}\n\t\n\t/**\n\t * Extract attributes and their values from attribute set: \n\t * <code>[attr col=3 title=\"Quoted string\"]</code>\n\t * @param {String} attrSet\n\t * @returns {Array}\n\t */\n\tfunction extractAttributes(attrSet, attrs) {\n\t\tattrSet = require('utils').trim(attrSet);\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(attrSet);\n\t\tstream.eatSpace();\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tstream.start = stream.pos;\n\t\t\tif (stream.eatWhile(reWord)) {\n\t\t\t\tvar attrName = stream.current();\n\t\t\t\tvar attrValue = '';\n\t\t\t\tif (stream.peek() == '=') {\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tvar quote = stream.peek();\n\t\t\t\t\t\n\t\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\t\tstream.next();\n\t\t\t\t\t\tif (consumeQuotedValue(stream, quote)) {\n\t\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t\t\t// strip quotes\n\t\t\t\t\t\t\tattrValue = attrValue.substring(1, attrValue.length - 1);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (stream.eatWhile(/[^\\s\\]]/)) {\n\t\t\t\t\t\tattrValue = stream.current();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow 'Invalid attribute value';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult.push({\n\t\t\t\t\tname: attrName, \n\t\t\t\t\tvalue: attrValue\n\t\t\t\t});\n\t\t\t\tstream.eatSpace();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Parses tag attributes extracted from abbreviation. If attributes found, \n\t * returns object with <code>element</code> and <code>attributes</code>\n\t * properties\n\t * @param {String} abbr\n\t * @returns {Object} Returns <code>null</code> if no attributes found in \n\t * abbreviation\n\t */\n\tfunction parseAttributes(abbr) {\n\t\t/*\n\t\t * Example of incoming data:\n\t\t * #header\n\t\t * .some.data\n\t\t * .some.data#header\n\t\t * [attr]\n\t\t * #item[attr=Hello other=\"World\"].class\n\t\t */\n\t\tvar result = [];\n\t\tvar attrMap = {'#': 'id', '.': 'class'};\n\t\tvar nameEnd = null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '#': // id\n\t\t\t\tcase '.': // class\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tvar attrName = attrMap[stream.peek()];\n\t\t\t\t\t\n\t\t\t\t\tstream.next();\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.eatWhile(reWord);\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\tname: attrName, \n\t\t\t\t\t\tvalue: stream.current()\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[': //begin attribute set\n\t\t\t\t\tif (nameEnd === null)\n\t\t\t\t\t\tnameEnd = stream.pos;\n\t\t\t\t\t\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tif (!stream.skipToPair('[', ']')) \n\t\t\t\t\t\tthrow 'Invalid attribute set definition';\n\t\t\t\t\t\n\t\t\t\t\tresult = result.concat(\n\t\t\t\t\t\textractAttributes(stripped(stream.current()))\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!result.length)\n\t\t\treturn null;\n\t\t\n\t\treturn {\n\t\t\telement: abbr.substring(0, nameEnd),\n\t\t\tattributes: optimizeAttributes(result)\n\t\t};\n\t}\n\t\n\t/**\n\t * Optimize attribute set: remove duplicates and merge class attributes\n\t * @param attrs\n\t */\n\tfunction optimizeAttributes(attrs) {\n\t\t// clone all attributes to make sure that original objects are \n\t\t// not modified\n\t\tattrs  = _.map(attrs, function(attr) {\n\t\t\treturn _.clone(attr);\n\t\t});\n\t\t\n\t\tvar lookup = {};\n\t\treturn _.filter(attrs, function(attr) {\n\t\t\tif (!(attr.name in lookup)) {\n\t\t\t\treturn lookup[attr.name] = attr;\n\t\t\t}\n\t\t\t\n\t\t\tvar la = lookup[attr.name];\n\t\t\t\n\t\t\tif (attr.name.toLowerCase() == 'class') {\n\t\t\t\tla.value += (la.value.length ? ' ' : '') + attr.value;\n\t\t\t} else {\n\t\t\t\tla.value = attr.value;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t});\n\t}\n\t\n\t/**\n\t * Extract text data from abbreviation: if <code>a{hello}</code> abbreviation\n\t * is passed, returns object <code>{element: 'a', text: 'hello'}</code>.\n\t * If nothing found, returns <code>null</code>\n\t * @param {String} abbr\n\t * \n\t */\n\tfunction extractText(abbr) {\n\t\tif (!~abbr.indexOf('{'))\n\t\t\treturn null;\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(abbr);\n\t\twhile (!stream.eol()) {\n\t\t\tswitch (stream.peek()) {\n\t\t\t\tcase '[':\n\t\t\t\tcase '(':\n\t\t\t\t\tstream.skipToPair(stream.peek(), pairs[stream.peek()]); break;\n\t\t\t\t\t\n\t\t\t\tcase '{':\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\treturn {\n\t\t\t\t\t\telement: abbr.substring(0, stream.start),\n\t\t\t\t\t\ttext: stripped(stream.current())\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tstream.next();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Un-rolls contents of current node: recursively replaces all repeating \n\t * children with their repeated clones\n\t * @param {AbbreviationNode} node\n\t * @returns {AbbreviationNode}\n\t */\n\tfunction unroll(node) {\n\t\tfor (var i = node.children.length - 1, j, child, maxCount; i >= 0; i--) {\n\t\t\tchild = node.children[i];\n\t\t\t\n\t\t\tif (child.isRepeating()) {\n\t\t\t\tmaxCount = j = child.repeatCount;\n\t\t\t\tchild.repeatCount = 1;\n\t\t\t\tchild.updateProperty('counter', 1);\n\t\t\t\tchild.updateProperty('maxCount', maxCount);\n\t\t\t\twhile (--j > 0) {\n\t\t\t\t\tchild.parent.addChild(child.clone(), i + 1)\n\t\t\t\t\t\t.updateProperty('counter', j + 1)\n\t\t\t\t\t\t.updateProperty('maxCount', maxCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// to keep proper 'counter' property, we need to walk\n\t\t// on children once again\n\t\t_.each(node.children, unroll);\n\t\t\n\t\treturn node;\n\t}\n\t\n\t/**\n\t * Optimizes tree node: replaces empty nodes with their children\n\t * @param {AbbreviationNode} node\n\t * @return {AbbreviationNode}\n\t */\n\tfunction squash(node) {\n\t\tfor (var i = node.children.length - 1; i >= 0; i--) {\n\t\t\t/** @type AbbreviationNode */\n\t\t\tvar n = node.children[i];\n\t\t\tif (n.isGroup()) {\n\t\t\t\tn.replace(squash(n).children);\n\t\t\t} else if (n.isEmpty()) {\n\t\t\t\tn.remove();\n\t\t\t}\n\t\t}\n\t\t\n\t\t_.each(node.children, squash);\n\t\t\n\t\treturn node;\n\t}\n\t\n\tfunction isAllowedChar(ch) {\n\t\tvar charCode = ch.charCodeAt(0);\n\t\tvar specialChars = '#.*:$-_!@|%';\n\t\t\n\t\treturn (charCode > 64 && charCode < 91)       // uppercase letter\n\t\t\t\t|| (charCode > 96 && charCode < 123)  // lowercase letter\n\t\t\t\t|| (charCode > 47 && charCode < 58)   // number\n\t\t\t\t|| specialChars.indexOf(ch) != -1;    // special character\n\t}\n\t\n\t// XXX add counter replacer function as output processor\n\toutputProcessors.push(function(text, node) {\n\t\treturn require('utils').replaceCounter(text, node.counter, node.maxCount);\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses abbreviation into tree with respect of groups, \n\t\t * text nodes and attributes. Each node of the tree is a single \n\t\t * abbreviation. Tree represents actual structure of the outputted \n\t\t * result\n\t\t * @memberOf abbreviationParser\n\t\t * @param {String} abbr Abbreviation to parse\n\t\t * @param {Object} options Additional options for parser and processors\n\t\t * \n\t\t * @return {AbbreviationNode}\n\t\t */\n\t\tparse: function(abbr, options) {\n\t\t\toptions = options || {};\n\t\t\t\n\t\t\tvar tree = parseAbbreviation(abbr);\n\t\t\t\n\t\t\tif (options.contextNode) {\n\t\t\t\t// add info about context node \n\t\t\t\t// a parent XHTML node in editor inside which abbreviation is \n\t\t\t\t// expanded\n\t\t\t\ttree._name = options.contextNode.name;\n\t\t\t\tvar attrLookup = {};\n\t\t\t\t_.each(tree._attributes, function(attr) {\n\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t_.each(options.contextNode.attributes, function(attr) {\n\t\t\t\t\tif (attr.name in attrLookup) {\n\t\t\t\t\t\tattrLookup[attr.name].value = attr.value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tattr = _.clone(attr);\n\t\t\t\t\t\ttree._attributes.push(attr);\n\t\t\t\t\t\tattrLookup[attr.name] = attr;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t// apply preprocessors\n\t\t\t_.each(preprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\ttree = squash(unroll(tree));\n\t\t\t\n\t\t\t// apply postprocessors\n\t\t\t_.each(postprocessors, function(fn) {\n\t\t\t\tfn(tree, options);\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\tAbbreviationNode: AbbreviationNode,\n\t\t\n\t\t/**\n\t\t * Add new abbreviation preprocessor. <i>Preprocessor</i> is a function\n\t\t * that applies to a parsed abbreviation tree right after it get parsed.\n\t\t * The passed tree is in unoptimized state.\n\t\t * @param {Function} fn Preprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPreprocessor: function(fn) {\n\t\t\tif (!_.include(preprocessors, fn))\n\t\t\t\tpreprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered preprocessor\n\t\t */\n\t\tremoveFilter: function(fn) {\n\t\t\tpreprocessor = _.without(preprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new abbreviation postprocessor. <i>Postprocessor</i> is a \n\t\t * functinon that applies to <i>optimized</i> parsed abbreviation tree\n\t\t * right before it returns from <code>parse()</code> method\n\t\t * @param {Function} fn Postprocessor function. This function receives\n\t\t * two arguments: parsed abbreviation tree (<code>AbbreviationNode</code>)\n\t\t * and <code>options</code> hash that was passed to <code>parse</code>\n\t\t * method\n\t\t */\n\t\taddPostprocessor: function(fn) {\n\t\t\tif (!_.include(postprocessors, fn))\n\t\t\t\tpostprocessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered postprocessor function\n\t\t */\n\t\tremovePostprocessor: function(fn) {\n\t\t\tpostprocessors = _.without(postprocessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers output postprocessor. <i>Output processor</i> is a \n\t\t * function that applies to output part (<code>start</code>, \n\t\t * <code>end</code> and <code>content</code>) when \n\t\t * <code>AbbreviationNode.toString()</code> method is called\n\t\t */\n\t\taddOutputProcessor: function(fn) {\n\t\t\tif (!_.include(outputProcessors, fn))\n\t\t\t\toutputProcessors.push(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered output processor\n\t\t */\n\t\tremoveOutputProcessor: function(fn) {\n\t\t\toutputProcessors = _.without(outputProcessors, fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is valid symbol for abbreviation expression\n\t\t * @param {String} ch\n\t\t * @return {Boolean}\n\t\t */\n\t\tisAllowedChar: function(ch) {\n\t\t\tch = String(ch); // convert Java object to JS\n\t\t\treturn isAllowedChar(ch) || ~'>+^[](){}'.indexOf(ch);\n\t\t}\n\t};\n});/**\n * Processor function that matches parsed <code>AbbreviationNode</code>\n * against resources defined in <code>resource</code> module\n * @param {Function} require\n * @param {Underscore} _\n */ \nemmet.exec(function(require, _) {\n\t/**\n\t * Finds matched resources for child nodes of passed <code>node</code> \n\t * element. A matched resource is a reference to <i>snippets.json</i> entry\n\t * that describes output of parsed node \n\t * @param {AbbreviationNode} node\n\t * @param {String} syntax\n\t */\n\tfunction matchResources(node, syntax) {\n\t\tvar resources = require('resources');\n\t\tvar elements = require('elements');\n\t\tvar parser = require('abbreviationParser');\n\t\t\n\t\t// do a shallow copy because the children list can be modified during\n\t\t// resource matching\n\t\t_.each(_.clone(node.children), /** @param {AbbreviationNode} child */ function(child) {\n\t\t\tvar r = resources.getMatchedResource(child, syntax);\n\t\t\tif (_.isString(r)) {\n\t\t\t\tchild.data('resource', elements.create('snippet', r));\n\t\t\t} else if (elements.is(r, 'reference')) {\n\t\t\t\t// its a reference to another abbreviation:\n\t\t\t\t// parse it and insert instead of current child\n\t\t\t\t/** @type AbbreviationNode */\n\t\t\t\tvar subtree = parser.parse(r.data, {\n\t\t\t\t\tsyntax: syntax\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t// if context element should be repeated, check if we need to \n\t\t\t\t// transfer repeated element to specific child node\n\t\t\t\tif (child.repeatCount > 1) {\n\t\t\t\t\tvar repeatedChildren = subtree.findAll(function(node) {\n\t\t\t\t\t\treturn node.hasImplicitRepeat;\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\t_.each(repeatedChildren, function(node) {\n\t\t\t\t\t\tnode.repeatCount = child.repeatCount;\n\t\t\t\t\t\tnode.hasImplicitRepeat = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// move childs children into the deepest child of new subtree\n\t\t\t\tvar deepestChild = subtree.deepestChild();\n\t\t\t\tif (deepestChild) {\n\t\t\t\t\t_.each(child.children, function(c) {\n\t\t\t\t\t\tdeepestChild.addChild(c);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// copy current attributes to children\n\t\t\t\t_.each(subtree.children, function(node) {\n\t\t\t\t\t_.each(child.attributeList(), function(attr) {\n\t\t\t\t\t\tnode.attribute(attr.name, attr.value);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tchild.replace(subtree.children);\n\t\t\t} else {\n\t\t\t\tchild.data('resource', r);\n\t\t\t}\n\t\t\t\n\t\t\tmatchResources(child, syntax);\n\t\t});\n\t}\n\t\n\t// XXX register abbreviation filter that creates references to resources\n\t// on abbreviation nodes\n\t/**\n\t * @param {AbbreviationNode} tree\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar syntax = options.syntax || emmet.defaultSyntax();\n\t\tmatchResources(tree, syntax);\n\t});\n\t\n});/**\n * Pasted content abbreviation processor. A pasted content is a content that\n * should be inserted into implicitly repeated abbreviation nodes.\n * This processor powers Wrap With Abbreviation action\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar parser = require('abbreviationParser');\n\tvar outputPlaceholder = '$#';\n\t\n\t/**\n\t * Locates output placeholders inside text\n\t * @param {String} text\n\t * @returns {Array} Array of ranges of output placeholder in text\n\t */\n\tfunction locateOutputPlaceholder(text) {\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\t\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(text);\n\t\t\n\t\twhile (!stream.eol()) {\n\t\t\tif (stream.peek() == '\\\\') {\n\t\t\t\tstream.next();\n\t\t\t} else {\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tif (stream.match(outputPlaceholder, true)) {\n\t\t\t\t\tresult.push(range.create(stream.start, outputPlaceholder));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstream.next();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Replaces output placeholders inside <code>source</code> with \n\t * <code>value</code>\n\t * @param {String} source\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction replaceOutputPlaceholders(source, value) {\n\t\tvar utils = require('utils');\n\t\tvar ranges = locateOutputPlaceholder(source);\n\t\t\n\t\tranges.reverse();\n\t\t_.each(ranges, function(r) {\n\t\t\tsource = utils.replaceSubstring(source, value, r);\n\t\t});\n\t\t\n\t\treturn source;\n\t}\n\t\n\t/**\n\t * Check if parsed node contains output placeholder  a target where\n\t * pasted content should be inserted\n\t * @param {AbbreviationNode} node\n\t * @returns {Boolean}\n\t */\n\tfunction hasOutputPlaceholder(node) {\n\t\tif (locateOutputPlaceholder(node.content).length)\n\t\t\treturn true;\n\t\t\n\t\t// check if attributes contains placeholder\n\t\treturn !!_.find(node.attributeList(), function(attr) {\n\t\t\treturn !!locateOutputPlaceholder(attr.value).length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Insert pasted content into correct positions of parsed node\n\t * @param {AbbreviationNode} node\n\t * @param {String} content\n\t * @param {Boolean} overwrite Overwrite node content if no value placeholders\n\t * found instead of appending to existing content\n\t */\n\tfunction insertPastedContent(node, content, overwrite) {\n\t\tvar nodesWithPlaceholders = node.findAll(function(item) {\n\t\t\treturn hasOutputPlaceholder(item);\n\t\t});\n\t\t\n\t\tif (hasOutputPlaceholder(node))\n\t\t\tnodesWithPlaceholders.unshift(node);\n\t\t\n\t\tif (nodesWithPlaceholders.length) {\n\t\t\t_.each(nodesWithPlaceholders, function(item) {\n\t\t\t\titem.content = replaceOutputPlaceholders(item.content, content);\n\t\t\t\t_.each(item._attributes, function(attr) {\n\t\t\t\t\tattr.value = replaceOutputPlaceholders(attr.value, content);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\t// on output placeholders in subtree, insert content in the deepest\n\t\t\t// child node\n\t\t\tvar deepest = node.deepestChild() || node;\n\t\t\tif (overwrite) {\n\t\t\t\tdeepest.content = content;\n\t\t\t} else {\n\t\t\t\tdeepest.content = require('abbreviationUtils').insertChildContent(deepest.content, content);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPreprocessor(function(tree, options) {\n\t\tif (options.pastedContent) {\n\t\t\tvar utils = require('utils');\n\t\t\tvar lines = _.map(utils.splitByLines(options.pastedContent, true), utils.trim);\n\t\t\t\n\t\t\t// set repeat count for implicitly repeated elements before\n\t\t\t// tree is unrolled\n\t\t\ttree.findAll(function(item) {\n\t\t\t\tif (item.hasImplicitRepeat) {\n\t\t\t\t\titem.data('paste', lines);\n\t\t\t\t\treturn item.repeatCount = lines.length;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\t\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\tparser.addPostprocessor(function(tree, options) {\n\t\t// for each node with pasted content, update text data\n\t\tvar targets = tree.findAll(function(item) {\n\t\t\tvar pastedContentObj = item.data('paste');\n\t\t\tvar pastedContent = '';\n\t\t\tif (_.isArray(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj[item.counter - 1];\n\t\t\t} else if (_.isFunction(pastedContentObj)) {\n\t\t\t\tpastedContent = pastedContentObj(item.counter - 1, item.content);\n\t\t\t} else if (pastedContentObj) {\n\t\t\t\tpastedContent = pastedContentObj;\n\t\t\t}\n\t\t\t\n\t\t\tif (pastedContent) {\n\t\t\t\tinsertPastedContent(item, pastedContent, !!item.data('pasteOverwrites'));\n\t\t\t}\n\t\t\t\n\t\t\titem.data('paste', null);\n\t\t\treturn !!pastedContentObj;\n\t\t});\n\t\t\n\t\tif (!targets.length && options.pastedContent) {\n\t\t\t// no implicitly repeated elements, put pasted content in\n\t\t\t// the deepest child\n\t\t\tinsertPastedContent(tree, options.pastedContent);\n\t\t}\n\t});\n});/**\n * Resolves tag names in abbreviations with implied name\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Resolves implicit node names in parsed tree\n\t * @param {AbbreviationNode} tree\n\t */\n\tfunction resolveNodeNames(tree) {\n\t\tvar tagName = require('tagName');\n\t\t_.each(tree.children, function(node) {\n\t\t\tif (node.hasImplicitName() || node.data('forceNameResolving')) {\n\t\t\t\tnode._name = tagName.resolve(node.parent.name());\n\t\t\t}\n\t\t\tresolveNodeNames(node);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('abbreviationParser').addPostprocessor(resolveNodeNames);\n});/**\n * @author Stoyan Stefanov\n * @link https://github.com/stoyan/etc/tree/master/cssex\n */\n\nemmet.define('cssParser', function(require, _) {\nvar walker, tokens = [], isOp, isNameChar, isDigit;\n    \n    // walks around the source\n    walker = {\n        lines: null,\n        total_lines: 0,\n        linenum: -1,\n        line: '',\n        ch: '',\n        chnum: -1,\n        init: function (source) {\n            var me = walker;\n        \n            // source, yumm\n            me.lines = source\n                .replace(/\\r\\n/g, '\\n')\n                .replace(/\\r/g, '\\n')\n                .split('\\n');\n            me.total_lines = me.lines.length;\n        \n            // reset\n            me.chnum = -1;\n            me.linenum = -1;\n            me.ch = '';\n            me.line = '';\n        \n            // advance\n            me.nextLine();\n            me.nextChar();\n        },\n        nextLine: function () {\n            var me = this;\n            me.linenum += 1;\n            if (me.total_lines <= me.linenum) {\n                me.line = false;\n            } else {\n                me.line = me.lines[me.linenum];\n            }\n            if (me.chnum !== -1) {\n                me.chnum = 0;\n            }\n            return me.line;\n        }, \n        nextChar: function () {\n            var me = this;\n            me.chnum += 1;\n            while (me.line.charAt(me.chnum) === '') {\n                if (this.nextLine() === false) {\n                    me.ch = false;\n                    return false; // end of source\n                }\n                me.chnum = -1;\n                me.ch = '\\n';\n                return '\\n';\n            }\n            me.ch = me.line.charAt(me.chnum);\n            return me.ch;\n        },\n        peek: function() {\n            return this.line.charAt(this.chnum + 1);\n        }\n    };\n\n    // utility helpers\n    isNameChar = function (c) {\n    \t// be more tolerate for name tokens: allow & character for LESS syntax\n        return (c == '&' || c === '_' || c === '-' || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));\n    };\n\n    isDigit = function (ch) {\n        return (ch !== false && ch >= '0' && ch <= '9');\n    };  \n\n    isOp = (function () {\n        var opsa = \"{}[]()+*=.,;:>~|\\\\%$#@^!\".split(''),\n            opsmatcha = \"*^|$~\".split(''),\n            ops = {},\n            opsmatch = {},\n            i = 0;\n        for (; i < opsa.length; i += 1) {\n            ops[opsa[i]] = true;\n        }\n        for (i = 0; i < opsmatcha.length; i += 1) {\n            opsmatch[opsmatcha[i]] = true;\n        }\n        return function (ch, matchattr) {\n            if (matchattr) {\n                return !!opsmatch[ch];\n            }\n            return !!ops[ch];\n        };\n    }());\n    \n    // shorthands\n    function isset(v) {\n        return typeof v !== 'undefined';\n    }\n    function getConf() {\n        return {\n            'char': walker.chnum,\n            line: walker.linenum\n        };\n    }\n\n\n    // creates token objects and pushes them to a list\n    function tokener(value, type, conf) {\n        var w = walker, c = conf || {};\n        tokens.push({\n            charstart: isset(c['char']) ? c['char'] : w.chnum,\n            charend:   isset(c.charend) ? c.charend : w.chnum,\n            linestart: isset(c.line)    ? c.line    : w.linenum,\n            lineend:   isset(c.lineend) ? c.lineend : w.linenum,\n            value:     value,\n            type:      type || value\n        });\n    }\n    \n    // oops\n    function error(m, config) { \n        var w = walker,\n            conf = config || {},\n            c = isset(conf['char']) ? conf['char'] : w.chnum,\n            l = isset(conf.line) ? conf.line : w.linenum;\n        return {\n            name: \"ParseError\",\n            message: m + \" at line \" + (l + 1) + ' char ' + (c + 1),\n            walker: w,\n            tokens: tokens\n        };\n    }\n\n\n    // token handlers follow for:\n    // white space, comment, string, identifier, number, operator\n    function white() {\n    \n        var c = walker.ch,\n            token = '',\n            conf = getConf();\n    \n        while (c === \" \" || c === \"\\t\") {\n            token += c;\n            c = walker.nextChar();\n        }\n    \n        tokener(token, 'white', conf);\n    \n    }\n\n    function comment() {\n    \n        var w = walker,\n            c = w.ch,\n            token = c,\n            cnext,\n            conf = getConf();    \n     \n        cnext = w.nextChar();\n\n        if (cnext === '/') {\n            // inline comment in SCSS and such\n            token += cnext;\n            var pk = w.peek();\n            while (pk && pk !== '\\n') {\n                token += cnext;\n                cnext = w.nextChar();\n                pk = w.peek();\n            }\n        } else if (cnext === '*') {\n            // multiline CSS commment\n            while (!(c === \"*\" && cnext === \"/\")) {\n                token += cnext;\n                c = cnext;\n                cnext = w.nextChar();        \n            }            \n        } else {\n            // oops, not a comment, just a /\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, token, conf);\n        }\n        \n        token += cnext;\n        w.nextChar();\n        tokener(token, 'comment', conf);\n    }\n\n    function str() {\n        var w = walker,\n            c = w.ch,\n            q = c,\n            token = c,\n            cnext,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== q) {\n            \n            if (c === '\\n') {\n                cnext = w.nextChar();\n                if (cnext === \"\\\\\") {\n                    token += c + cnext;\n                } else {\n                    // end of line with no \\ escape = bad\n                    throw error(\"Unterminated string\", conf);\n                }\n            } else {\n                if (c === \"\\\\\") {\n                    token += c + w.nextChar();\n                } else {\n                    token += c;\n                }\n            }\n        \n            c = w.nextChar();\n        \n        }\n        token += c;\n        w.nextChar();\n        tokener(token, 'string', conf);\n    }\n    \n    function brace() {\n        var w = walker,\n            c = w.ch,\n            depth = 0,\n            token = c,\n            conf = getConf();\n    \n        c = w.nextChar();\n    \n        while (c !== ')' && !depth) {\n        \tif (c === '(') {\n        \t\tdepth++;\n        \t} else if (c === ')') {\n        \t\tdepth--;\n        \t} else if (c === false) {\n        \t\tthrow error(\"Unterminated brace\", conf);\n        \t}\n        \t\n        \ttoken += c;\n            c = w.nextChar();\n        }\n        \n        token += c;\n        w.nextChar();\n        tokener(token, 'brace', conf);\n    }\n\n    function identifier(pre) {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = (pre) ? pre + c : c;\n            \n        c = w.nextChar();\n    \n        if (pre) { // adjust token position\n        \tconf['char'] -= pre.length;\n        }\n        \n        while (isNameChar(c) || isDigit(c)) {\n            token += c;\n            c = w.nextChar();\n        }\n    \n        tokener(token, 'identifier', conf);    \n    }\n\n    function num() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            point = token === '.',\n            nondigit;\n        \n        c = w.nextChar();\n        nondigit = !isDigit(c);\n    \n        // .2px or .classname?\n        if (point && nondigit) {\n            // meh, NaN, could be a class name, so it's an operator for now\n            conf.charend = conf['char'];\n            conf.lineend = conf.line;\n            return tokener(token, '.', conf);    \n        }\n        \n        // -2px or -moz-something\n        if (token === '-' && nondigit) {\n            return identifier('-');\n        }\n    \n        while (c !== false && (isDigit(c) || (!point && c === '.'))) { // not end of source && digit or first instance of .\n            if (c === '.') {\n                point = true;\n            }\n            token += c;\n            c = w.nextChar();\n        }\n\n        tokener(token, 'number', conf);    \n    \n    }\n\n    function op() {\n        var w = walker,\n            c = w.ch,\n            conf = getConf(),\n            token = c,\n            next = w.nextChar();\n            \n        if (next === \"=\" && isOp(token, true)) {\n            token += next;\n            tokener(token, 'match', conf);\n            w.nextChar();\n            return;\n        } \n        \n        conf.charend = conf['char'] + 1;\n        conf.lineend = conf.line;    \n        tokener(token, token, conf);\n    }\n\n\n    // call the appropriate handler based on the first character in a token suspect\n    function tokenize() {\n\n        var ch = walker.ch;\n    \n        if (ch === \" \" || ch === \"\\t\") {\n            return white();\n        }\n\n        if (ch === '/') {\n            return comment();\n        } \n\n        if (ch === '\"' || ch === \"'\") {\n            return str();\n        }\n        \n        if (ch === '(') {\n            return brace();\n        }\n    \n        if (ch === '-' || ch === '.' || isDigit(ch)) { // tricky - char: minus (-1px) or dash (-moz-stuff)\n            return num();\n        }\n    \n        if (isNameChar(ch)) {\n            return identifier();\n        }\n\n        if (isOp(ch)) {\n            return op();\n        }\n        \n        if (ch === \"\\n\") {\n            tokener(\"line\");\n            walker.nextChar();\n            return;\n        }\n        \n        throw error(\"Unrecognized character\");\n    }\n    \n    /**\n\t * Returns newline character at specified position in content\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @return {String}\n\t */\n\tfunction getNewline(content, pos) {\n\t\treturn content.charAt(pos) == '\\r' && content.charAt(pos + 1) == '\\n' \n\t\t\t? '\\r\\n' \n\t\t\t: content.charAt(pos);\n\t}\n\n    return {\n    \t/**\n    \t * @param source\n    \t * @returns\n    \t * @memberOf emmet.cssParser\n    \t */\n        lex: function (source) {\n            walker.init(source);\n            tokens = [];\n            while (walker.ch !== false) {\n                tokenize();            \n            }\n            return tokens;\n        },\n        \n        /**\n         * Tokenizes CSS source\n         * @param {String} source\n         * @returns {Array}\n         */\n        parse: function(source) {\n        \t// transform tokens\n\t \t\tvar pos = 0;\n\t \t\treturn _.map(this.lex(source), function(token) {\n\t \t\t\tif (token.type == 'line') {\n\t \t\t\t\ttoken.value = getNewline(source, pos);\n\t \t\t\t}\n\t \t\t\t\n\t \t\t\treturn {\n\t \t\t\t\ttype: token.type,\n\t \t\t\t\tstart: pos,\n\t \t\t\t\tend: (pos += token.value.length)\n\t \t\t\t};\n\t\t\t});\n\t\t},\n        \n        toSource: function (toks) {\n            var i = 0, max = toks.length, t, src = '';\n            for (; i < max; i += 1) {\n                t = toks[i];\n                if (t.type === 'line') {\n                    src += '\\n';\n                } else {\n                    src += t.value;\n                }\n            }\n            return src;\n        }\n    };\n});/**\n * HTML tokenizer by Marijn Haverbeke\n * http://codemirror.net/\n * @constructor\n * @memberOf __xmlParseDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('xmlParser', function(require, _) {\n\tvar Kludges = {\n\t\tautoSelfClosers : {},\n\t\timplicitlyClosed : {},\n\t\tcontextGrabbers : {},\n\t\tdoNotIndent : {},\n\t\tallowUnquoted : true,\n\t\tallowMissing : true\n\t};\n\n\t// Return variables for tokenizers\n\tvar tagName = null, type = null;\n\n\tfunction inText(stream, state) {\n\t\tfunction chain(parser) {\n\t\t\tstate.tokenize = parser;\n\t\t\treturn parser(stream, state);\n\t\t}\n\n\t\tvar ch = stream.next();\n\t\tif (ch == \"<\") {\n\t\t\tif (stream.eat(\"!\")) {\n\t\t\t\tif (stream.eat(\"[\")) {\n\t\t\t\t\tif (stream.match(\"CDATA[\"))\n\t\t\t\t\t\treturn chain(inBlock(\"atom\", \"]]>\"));\n\t\t\t\t\telse\n\t\t\t\t\t\treturn null;\n\t\t\t\t} else if (stream.match(\"--\"))\n\t\t\t\t\treturn chain(inBlock(\"comment\", \"-->\"));\n\t\t\t\telse if (stream.match(\"DOCTYPE\", true, true)) {\n\t\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\t\treturn chain(doctype(1));\n\t\t\t\t} else\n\t\t\t\t\treturn null;\n\t\t\t} else if (stream.eat(\"?\")) {\n\t\t\t\tstream.eatWhile(/[\\w\\._\\-]/);\n\t\t\t\tstate.tokenize = inBlock(\"meta\", \"?>\");\n\t\t\t\treturn \"meta\";\n\t\t\t} else {\n\t\t\t\ttype = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n\t\t\t\tstream.eatSpace();\n\t\t\t\ttagName = \"\";\n\t\t\t\tvar c;\n\t\t\t\twhile ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/)))\n\t\t\t\t\ttagName += c;\n\t\t\t\tstate.tokenize = inTag;\n\t\t\t\treturn \"tag\";\n\t\t\t}\n\t\t} else if (ch == \"&\") {\n\t\t\tvar ok;\n\t\t\tif (stream.eat(\"#\")) {\n\t\t\t\tif (stream.eat(\"x\")) {\n\t\t\t\t\tok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");\n\t\t\t\t} else {\n\t\t\t\t\tok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(\";\");\n\t\t\t}\n\t\t\treturn ok ? \"atom\" : \"error\";\n\t\t} else {\n\t\t\tstream.eatWhile(/[^&<]/);\n\t\t\treturn \"text\";\n\t\t}\n\t}\n\n\tfunction inTag(stream, state) {\n\t\tvar ch = stream.next();\n\t\tif (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n\t\t\tstate.tokenize = inText;\n\t\t\ttype = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n\t\t\treturn \"tag\";\n\t\t} else if (ch == \"=\") {\n\t\t\ttype = \"equals\";\n\t\t\treturn null;\n\t\t} else if (/[\\'\\\"]/.test(ch)) {\n\t\t\tstate.tokenize = inAttribute(ch);\n\t\t\treturn state.tokenize(stream, state);\n\t\t} else {\n\t\t\tstream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\n\t\t\treturn \"word\";\n\t\t}\n\t}\n\n\tfunction inAttribute(quote) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.next() == quote) {\n\t\t\t\t\tstate.tokenize = inTag;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"string\";\n\t\t};\n\t}\n\n\tfunction inBlock(style, terminator) {\n\t\treturn function(stream, state) {\n\t\t\twhile (!stream.eol()) {\n\t\t\t\tif (stream.match(terminator)) {\n\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstream.next();\n\t\t\t}\n\t\t\treturn style;\n\t\t};\n\t}\n\t\n\tfunction doctype(depth) {\n\t\treturn function(stream, state) {\n\t\t\tvar ch;\n\t\t\twhile ((ch = stream.next()) != null) {\n\t\t\t\tif (ch == \"<\") {\n\t\t\t\t\tstate.tokenize = doctype(depth + 1);\n\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t} else if (ch == \">\") {\n\t\t\t\t\tif (depth == 1) {\n\t\t\t\t\t\tstate.tokenize = inText;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate.tokenize = doctype(depth - 1);\n\t\t\t\t\t\treturn state.tokenize(stream, state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn \"meta\";\n\t\t};\n\t}\n\n\tvar curState = null, setStyle;\n\tfunction pass() {\n\t\tfor (var i = arguments.length - 1; i >= 0; i--)\n\t\t\tcurState.cc.push(arguments[i]);\n\t}\n\t\n\tfunction cont() {\n\t\tpass.apply(null, arguments);\n\t\treturn true;\n\t}\n\n\tfunction pushContext(tagName, startOfLine) {\n\t\tvar noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) \n\t\t\t|| (curState.context && curState.context.noIndent);\n\t\tcurState.context = {\n\t\t\tprev : curState.context,\n\t\t\ttagName : tagName,\n\t\t\tindent : curState.indented,\n\t\t\tstartOfLine : startOfLine,\n\t\t\tnoIndent : noIndent\n\t\t};\n\t}\n\t\n\tfunction popContext() {\n\t\tif (curState.context)\n\t\t\tcurState.context = curState.context.prev;\n\t}\n\n\tfunction element(type) {\n\t\tif (type == \"openTag\") {\n\t\t\tcurState.tagName = tagName;\n\t\t\treturn cont(attributes, endtag(curState.startOfLine));\n\t\t} else if (type == \"closeTag\") {\n\t\t\tvar err = false;\n\t\t\tif (curState.context) {\n\t\t\t\tif (curState.context.tagName != tagName) {\n\t\t\t\t\tif (Kludges.implicitlyClosed.hasOwnProperty(curState.context.tagName.toLowerCase())) {\n\t\t\t\t\t\tpopContext();\n\t\t\t\t\t}\n\t\t\t\t\terr = !curState.context || curState.context.tagName != tagName;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(endclosetag(err));\n\t\t}\n\t\treturn cont();\n\t}\n\t\n\tfunction endtag(startOfLine) {\n\t\treturn function(type) {\n\t\t\tif (type == \"selfcloseTag\"\n\t\t\t\t\t|| (type == \"endTag\" && Kludges.autoSelfClosers\n\t\t\t\t\t\t\t.hasOwnProperty(curState.tagName\n\t\t\t\t\t\t\t\t\t.toLowerCase()))) {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tmaybePopContext(curState.tagName.toLowerCase());\n\t\t\t\tpushContext(curState.tagName, startOfLine);\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\treturn cont();\n\t\t};\n\t}\n\t\n\tfunction endclosetag(err) {\n\t\treturn function(type) {\n\t\t\tif (err)\n\t\t\t\tsetStyle = \"error\";\n\t\t\tif (type == \"endTag\") {\n\t\t\t\tpopContext();\n\t\t\t\treturn cont();\n\t\t\t}\n\t\t\tsetStyle = \"error\";\n\t\t\treturn cont(arguments.callee);\n\t\t};\n\t}\n\t\n\tfunction maybePopContext(nextTagName) {\n\t\tvar parentTagName;\n\t\twhile (true) {\n\t\t\tif (!curState.context) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparentTagName = curState.context.tagName.toLowerCase();\n\t\t\tif (!Kludges.contextGrabbers.hasOwnProperty(parentTagName)\n\t\t\t\t\t|| !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpopContext();\n\t\t}\n\t}\n\n\tfunction attributes(type) {\n\t\tif (type == \"word\") {\n\t\t\tsetStyle = \"attribute\";\n\t\t\treturn cont(attribute, attributes);\n\t\t}\n\t\tif (type == \"endTag\" || type == \"selfcloseTag\")\n\t\t\treturn pass();\n\t\tsetStyle = \"error\";\n\t\treturn cont(attributes);\n\t}\n\t\n\tfunction attribute(type) {\n\t\tif (type == \"equals\")\n\t\t\treturn cont(attvalue, attributes);\n\t\tif (!Kludges.allowMissing)\n\t\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfcloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvalue(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\tif (type == \"word\" && Kludges.allowUnquoted) {\n\t\t\tsetStyle = \"string\";\n\t\t\treturn cont();\n\t\t}\n\t\tsetStyle = \"error\";\n\t\treturn (type == \"endTag\" || type == \"selfCloseTag\") ? pass()\n\t\t\t\t: cont();\n\t}\n\t\n\tfunction attvaluemaybe(type) {\n\t\tif (type == \"string\")\n\t\t\treturn cont(attvaluemaybe);\n\t\telse\n\t\t\treturn pass();\n\t}\n\t\n\tfunction startState() {\n\t\treturn {\n\t\t\ttokenize : inText,\n\t\t\tcc : [],\n\t\t\tindented : 0,\n\t\t\tstartOfLine : true,\n\t\t\ttagName : null,\n\t\t\tcontext : null\n\t\t};\n\t}\n\t\n\tfunction token(stream, state) {\n\t\tif (stream.sol()) {\n\t\t\tstate.startOfLine = true;\n\t\t\tstate.indented = 0;\n\t\t}\n\t\t\n\t\tif (stream.eatSpace())\n\t\t\treturn null;\n\n\t\tsetStyle = type = tagName = null;\n\t\tvar style = state.tokenize(stream, state);\n\t\tstate.type = type;\n\t\tif ((style || type) && style != \"comment\") {\n\t\t\tcurState = state;\n\t\t\twhile (true) {\n\t\t\t\tvar comb = state.cc.pop() || element;\n\t\t\t\tif (comb(type || style))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstate.startOfLine = false;\n\t\treturn setStyle || style;\n\t}\n\n\treturn {\n\t\t/**\n\t\t * @memberOf emmet.xmlParser\n\t\t * @returns\n\t\t */\n\t\tparse: function(data, offset) {\n\t\t\toffset = offset || 0;\n\t\t\tvar state = startState();\n\t\t\tvar stream = require('stringStream').create(data);\n\t\t\tvar tokens = [];\n\t\t\twhile (!stream.eol()) {\n\t\t\t\ttokens.push({\n\t\t\t\t\ttype: token(stream, state),\n\t\t\t\t\tstart: stream.start + offset,\n\t\t\t\t\tend: stream.pos + offset\n\t\t\t\t});\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn tokens;\n\t\t}\t\t\n\t};\n});\n/*!\n * string_score.js: String Scoring Algorithm 0.1.10 \n *\n * http://joshaven.com/string_score\n * https://github.com/joshaven/string_score\n *\n * Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score\n * MIT license: http://www.opensource.org/licenses/mit-license.php\n *\n * Date: Tue Mar 1 2011\n*/\n\n/**\n * Scores a string against another string.\n *  'Hello World'.score('he');     //=> 0.5931818181818181\n *  'Hello World'.score('Hello');  //=> 0.7318181818181818\n */\nemmet.define('string-score', function(require, _) {\n\treturn {\n\t\tscore: function(string, abbreviation, fuzziness) {\n\t\t\t// If the string is equal to the abbreviation, perfect match.\n\t\t\t  if (string == abbreviation) {return 1;}\n\t\t\t  //if it's not a perfect match and is empty return 0\n\t\t\t  if(abbreviation == \"\") {return 0;}\n\n\t\t\t  var total_character_score = 0,\n\t\t\t      abbreviation_length = abbreviation.length,\n\t\t\t      string_length = string.length,\n\t\t\t      start_of_string_bonus,\n\t\t\t      abbreviation_score,\n\t\t\t      fuzzies=1,\n\t\t\t      final_score;\n\t\t\t  \n\t\t\t  // Walk through abbreviation and add up scores.\n\t\t\t  for (var i = 0,\n\t\t\t         character_score/* = 0*/,\n\t\t\t         index_in_string/* = 0*/,\n\t\t\t         c/* = ''*/,\n\t\t\t         index_c_lowercase/* = 0*/,\n\t\t\t         index_c_uppercase/* = 0*/,\n\t\t\t         min_index/* = 0*/;\n\t\t\t     i < abbreviation_length;\n\t\t\t     ++i) {\n\t\t\t    \n\t\t\t    // Find the first case-insensitive match of a character.\n\t\t\t    c = abbreviation.charAt(i);\n\t\t\t    \n\t\t\t    index_c_lowercase = string.indexOf(c.toLowerCase());\n\t\t\t    index_c_uppercase = string.indexOf(c.toUpperCase());\n\t\t\t    min_index = Math.min(index_c_lowercase, index_c_uppercase);\n\t\t\t    index_in_string = (min_index > -1) ? min_index : Math.max(index_c_lowercase, index_c_uppercase);\n\t\t\t    \n\t\t\t    if (index_in_string === -1) { \n\t\t\t      if (fuzziness) {\n\t\t\t        fuzzies += 1-fuzziness;\n\t\t\t        continue;\n\t\t\t      } else {\n\t\t\t        return 0;\n\t\t\t      }\n\t\t\t    } else {\n\t\t\t      character_score = 0.1;\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Set base score for matching 'c'.\n\t\t\t    \n\t\t\t    // Same case bonus.\n\t\t\t    if (string[index_in_string] === c) { \n\t\t\t      character_score += 0.1; \n\t\t\t    }\n\t\t\t    \n\t\t\t    // Consecutive letter & start-of-string Bonus\n\t\t\t    if (index_in_string === 0) {\n\t\t\t      // Increase the score when matching first character of the remainder of the string\n\t\t\t      character_score += 0.6;\n\t\t\t      if (i === 0) {\n\t\t\t        // If match is the first character of the string\n\t\t\t        // & the first character of abbreviation, add a\n\t\t\t        // start-of-string match bonus.\n\t\t\t        start_of_string_bonus = 1; //true;\n\t\t\t      }\n\t\t\t    }\n\t\t\t    else {\n\t\t\t  // Acronym Bonus\n\t\t\t  // Weighing Logic: Typing the first character of an acronym is as if you\n\t\t\t  // preceded it with two perfect character matches.\n\t\t\t  if (string.charAt(index_in_string - 1) === ' ') {\n\t\t\t    character_score += 0.8; // * Math.min(index_in_string, 5); // Cap bonus at 0.4 * 5\n\t\t\t  }\n\t\t\t    }\n\t\t\t    \n\t\t\t    // Left trim the already matched part of the string\n\t\t\t    // (forces sequential matching).\n\t\t\t    string = string.substring(index_in_string + 1, string_length);\n\t\t\t    \n\t\t\t    total_character_score += character_score;\n\t\t\t  } // end of for loop\n\t\t\t  \n\t\t\t  // Uncomment to weigh smaller words higher.\n\t\t\t  // return total_character_score / string_length;\n\t\t\t  \n\t\t\t  abbreviation_score = total_character_score / abbreviation_length;\n\t\t\t  //percentage_of_matched_string = abbreviation_length / string_length;\n\t\t\t  //word_score = abbreviation_score * percentage_of_matched_string;\n\t\t\t  \n\t\t\t  // Reduce penalty for longer strings.\n\t\t\t  //final_score = (word_score + abbreviation_score) / 2;\n\t\t\t  final_score = ((abbreviation_score * (abbreviation_length / string_length)) + abbreviation_score) / 2;\n\t\t\t  \n\t\t\t  final_score = final_score / fuzzies;\n\t\t\t  \n\t\t\t  if (start_of_string_bonus && (final_score + 0.15 < 1)) {\n\t\t\t    final_score += 0.15;\n\t\t\t  }\n\t\t\t  \n\t\t\t  return final_score;\n\t\t}\n\t};\n});/**\n * Utility module for Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('utils', function(require, _) {\n\t/** \n\t * Special token used as a placeholder for caret positions inside \n\t * generated output \n\t */\n\tvar caretPlaceholder = '${0}';\n\t\n\t/**\n\t * A simple string builder, optimized for faster text concatenation\n\t * @param {String} value Initial value\n\t */\n\tfunction StringBuilder(value) {\n\t\tthis._data = [];\n\t\tthis.length = 0;\n\t\t\n\t\tif (value)\n\t\t\tthis.append(value);\n\t}\n\t\n\tStringBuilder.prototype = {\n\t\t/**\n\t\t * Append string\n\t\t * @param {String} text\n\t\t */\n\t\tappend: function(text) {\n\t\t\tthis._data.push(text);\n\t\t\tthis.length += text.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this._data.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {String}\n\t\t */\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/** @memberOf utils */\n\t\treTag: /<\\/?[\\w:\\-]+(?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*\\s*(\\/?)>$/,\n\t\t\n\t\t/**\n\t\t * Test if passed string ends with XHTML tag. This method is used for testing\n\t\t * '>' character: it belongs to tag or it's a part of abbreviation? \n\t\t * @param {String} str\n\t\t * @return {Boolean}\n\t\t */\n\t\tendsWithTag: function(str) {\n\t\t\treturn this.reTag.test(str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed symbol is a number\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisNumeric: function(ch) {\n\t\t\tif (typeof(ch) == 'string')\n\t\t\t\tch = ch.charCodeAt(0);\n\t\t\t\t\n\t\t\treturn (ch && ch > 47 && ch < 58);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Trim whitespace from string\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\ttrim: function(text) {\n\t\t\treturn (text || \"\").replace(/^\\s+|\\s+$/g, \"\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns newline character\n\t\t * @returns {String}\n\t\t */\n\t\tgetNewline: function() {\n\t\t\tvar res = require('resources');\n\t\t\tif (!res) {\n\t\t\t\treturn '\\n';\n\t\t\t}\n\t\t\t\n\t\t\tvar nl = res.getVariable('newline');\n\t\t\treturn _.isString(nl) ? nl : '\\n';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new newline character that will be used in output\n\t\t * @param {String} str\n\t\t */\n\t\tsetNewline: function(str) {\n\t\t\tvar res = require('resources');\n\t\t\tres.setVariable('newline', str);\n\t\t\tres.setVariable('nl', str);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split text into lines. Set <code>remove_empty</code> to true to filter\n\t\t * empty lines\n\t\t * @param {String} text Text to split\n\t\t * @param {Boolean} removeEmpty Remove empty lines from result\n\t\t * @return {Array}\n\t\t */\n\t\tsplitByLines: function(text, removeEmpty) {\n\t\t\t// IE fails to split string by regexp, \n\t\t\t// need to normalize newlines first\n\t\t\t// Also, Mozilla's Rhiho JS engine has a weird newline bug\n\t\t\tvar nl = this.getNewline();\n\t\t\tvar lines = (text || '')\n\t\t\t\t.replace(/\\r\\n/g, '\\n')\n\t\t\t\t.replace(/\\n\\r/g, '\\n')\n\t\t\t\t.replace(/\\r/g, '\\n')\n\t\t\t\t.replace(/\\n/g, nl)\n\t\t\t\t.split(nl);\n\t\t\t\n\t\t\tif (removeEmpty) {\n\t\t\t\tlines = _.filter(lines, function(line) {\n\t\t\t\t\treturn line.length && !!this.trim(line);\n\t\t\t\t}, this);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes newline character: replaces newlines in <code>text</code> \n\t\t * with newline defined in preferences\n\t\t * @param {String} text\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeNewline: function(text) {\n\t\t\treturn this.splitByLines(text).join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeats string <code>howMany</code> times\n\t\t * @param {String} str\n\t\t * @param {Number} how_many\n\t\t * @return {String}\n\t\t */\n\t\trepeatString: function(str, howMany) {\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tfor (var i = 0; i < howMany; i++) \n\t\t\t\tresult.push(str);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of paddings that should be used to align passed string\n\t\t * @param {Array} strings\n\t\t * @returns {Array}\n\t\t */\n\t\tgetStringsPads: function(strings) {\n\t\t\tvar lengths = _.map(strings, function(s) {\n\t\t\t\treturn _.isString(s) ? s.length : +s;\n\t\t\t});\n\t\t\t\n\t\t\tvar max = _.max(lengths);\n\t\t\treturn _.map(lengths, function(l) {\n\t\t\t\tvar pad = max - l;\n\t\t\t\treturn pad ? this.repeatString(' ', pad) : '';\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Indents text with padding\n\t\t * @param {String} text Text to indent\n\t\t * @param {String} pad Padding size (number) or padding itself (string)\n\t\t * @return {String}\n\t\t */\n\t\tpadString: function(text, pad) {\n\t\t\tvar padStr = (_.isNumber(pad)) \n\t\t\t\t? this.repeatString(require('resources').getVariable('indentation') || '\\t', pad) \n\t\t\t\t: pad;\n\t\t\t\t\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tvar nl = this.getNewline();\n\t\t\t\t\n\t\t\tresult.push(lines[0]);\n\t\t\tfor (var j = 1; j < lines.length; j++) \n\t\t\t\tresult.push(nl + padStr + lines[j]);\n\t\t\t\t\n\t\t\treturn result.join('');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Pad string with zeroes\n\t\t * @param {String} str String to pad\n\t\t * @param {Number} pad Desired string length\n\t\t * @return {String}\n\t\t */\n\t\tzeroPadString: function(str, pad) {\n\t\t\tvar padding = '';\n\t\t\tvar il = str.length;\n\t\t\t\t\n\t\t\twhile (pad > il++) padding += '0';\n\t\t\treturn padding + str; \n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes padding at the beginning of each text's line\n\t\t * @param {String} text\n\t\t * @param {String} pad\n\t\t */\n\t\tunindentString: function(text, pad) {\n\t\t\tvar lines = this.splitByLines(text);\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\t\t\t\tif (lines[i].search(pad) == 0)\n\t\t\t\t\tlines[i] = lines[i].substr(pad.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn lines.join(this.getNewline());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces unescaped symbols in <code>str</code>. For example, the '$' symbol\n\t\t * will be replaced in 'item$count', but not in 'item\\$count'.\n\t\t * @param {String} str Original string\n\t\t * @param {String} symbol Symbol to replace\n\t\t * @param {String} replace Symbol replacement. Might be a function that \n\t\t * returns new value\n\t\t * @return {String}\n\t\t */\n\t\treplaceUnescapedSymbol: function(str, symbol, replace) {\n\t\t\tvar i = 0;\n\t\t\tvar il = str.length;\n\t\t\tvar sl = symbol.length;\n\t\t\tvar matchCount = 0;\n\t\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tif (str.charAt(i) == '\\\\') {\n\t\t\t\t\t// escaped symbol, skip next character\n\t\t\t\t\ti += sl + 1;\n\t\t\t\t} else if (str.substr(i, sl) == symbol) {\n\t\t\t\t\t// have match\n\t\t\t\t\tvar curSl = sl;\n\t\t\t\t\tmatchCount++;\n\t\t\t\t\tvar newValue = replace;\n\t\t\t\t\tif (_.isFunction(replace)) {\n\t\t\t\t\t\tvar replaceData = replace(str, symbol, i, matchCount);\n\t\t\t\t\t\tif (replaceData) {\n\t\t\t\t\t\t\tcurSl = replaceData[0].length;\n\t\t\t\t\t\t\tnewValue = replaceData[1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnewValue = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === false) { // skip replacement\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstr = str.substring(0, i) + newValue + str.substring(i + curSl);\n\t\t\t\t\t// adjust indexes\n\t\t\t\t\til = str.length;\n\t\t\t\t\ti += newValue.length;\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn str;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace variables like ${var} in string\n\t\t * @param {String} str\n\t\t * @param {Object} vars Variable set (defaults to variables defined in \n\t\t * <code>snippets.json</code>) or variable resolver (<code>Function</code>)\n\t\t * @return {String}\n\t\t */\n\t\treplaceVariables: function(str, vars) {\n\t\t\tvars = vars || {};\n\t\t\tvar resolver = _.isFunction(vars) ? vars : function(str, p1) {\n\t\t\t\treturn p1 in vars ? vars[p1] : null;\n\t\t\t};\n\t\t\t\n\t\t\tvar res = require('resources');\n\t\t\treturn require('tabStops').processText(str, {\n\t\t\t\tvariable: function(data) {\n\t\t\t\t\tvar newValue = resolver(data.token, data.name, data);\n\t\t\t\t\tif (newValue === null) {\n\t\t\t\t\t\t// try to find variable in resources\n\t\t\t\t\t\tnewValue = res.getVariable(data.name);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newValue === null || _.isUndefined(newValue))\n\t\t\t\t\t\t// nothing found, return token itself\n\t\t\t\t\t\tnewValue = data.token;\n\t\t\t\t\treturn newValue;\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replaces '$' character in string assuming it might be escaped with '\\'\n\t\t * @param {String} str String where character should be replaced\n\t\t * @param {String} value New value\n\t\t * @return {String}\n\t\t */\n\t\treplaceCounter: function(str, value, total) {\n\t\t\tvar symbol = '$';\n\t\t\t// in case we received strings from Java, convert the to native strings\n\t\t\tstr = String(str);\n\t\t\tvalue = String(value);\n\t\t\t\n\t\t\tif (/^\\-?\\d+$/.test(value)) {\n\t\t\t\tvalue = +value;\n\t\t\t}\n\t\t\t\n\t\t\tvar that = this;\n\t\t\t\n\t\t\treturn this.replaceUnescapedSymbol(str, symbol, function(str, symbol, pos, matchNum){\n\t\t\t\tif (str.charAt(pos + 1) == '{' || that.isNumeric(str.charAt(pos + 1)) ) {\n\t\t\t\t\t// it's a variable, skip it\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// replace sequense of $ symbols with padded number  \n\t\t\t\tvar j = pos + 1;\n\t\t\t\twhile(str.charAt(j) == '$' && str.charAt(j + 1) != '{') j++;\n\t\t\t\tvar pad = j - pos;\n\t\t\t\t\n\t\t\t\t// get counter base\n\t\t\t\tvar base = 0, decrement = false, m;\n\t\t\t\tif (m = str.substr(j).match(/^@(\\-?)(\\d*)/)) {\n\t\t\t\t\tj += m[0].length;\n\t\t\t\t\t\n\t\t\t\t\tif (m[1]) {\n\t\t\t\t\t\tdecrement = true;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tbase = parseInt(m[2] || 1) - 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (decrement && total && _.isNumber(value)) {\n\t\t\t\t\tvalue = total - value + 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvalue += base;\n\t\t\t\t\n\t\t\t\treturn [str.substring(pos, j), that.zeroPadString(value + '', pad)];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if string matches against <code>reTag</code> regexp. This \n\t\t * function may be used to test if provided string contains HTML tags\n\t\t * @param {String} str\n\t\t * @returns {Boolean}\n\t\t */\n\t\tmatchesTag: function(str) {\n\t\t\treturn this.reTag.test(str || '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escapes special characters used in Emmet, like '$', '|', etc.\n\t\t * Use this method before passing to actions like \"Wrap with Abbreviation\"\n\t\t * to make sure that existing special characters won't be altered\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tescapeText: function(text) {\n\t\t\treturn text.replace(/([\\$\\\\])/g, '\\\\$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unescapes special characters used in Emmet, like '$', '|', etc.\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunescapeText: function(text) {\n\t\t\treturn text.replace(/\\\\(.)/g, '$1');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns caret placeholder\n\t\t * @returns {String}\n\t\t */\n\t\tgetCaretPlaceholder: function() {\n\t\t\treturn _.isFunction(caretPlaceholder) \n\t\t\t\t? caretPlaceholder.apply(this, arguments)\n\t\t\t\t: caretPlaceholder;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets new representation for carets in generated output\n\t\t * @param {String} value New caret placeholder. Might be a \n\t\t * <code>Function</code>\n\t\t */\n\t\tsetCaretPlaceholder: function(value) {\n\t\t\tcaretPlaceholder = value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns line padding\n\t\t * @param {String} line\n\t\t * @return {String}\n\t\t */\n\t\tgetLinePadding: function(line) {\n\t\t\treturn (line.match(/^(\\s+)/) || [''])[0];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that returns padding of line of <code>pos</code>\n\t\t * position in <code>content</code>\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @returns {String}\n\t\t */\n\t\tgetLinePaddingFromPosition: function(content, pos) {\n\t\t\tvar lineRange = this.findNewlineBounds(content, pos);\n\t\t\treturn this.getLinePadding(lineRange.substring(content));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Escape special regexp chars in string, making it usable for creating dynamic\n\t\t * regular expressions\n\t\t * @param {String} str\n\t\t * @return {String}\n\t\t */\n\t\tescapeForRegexp: function(str) {\n\t\t\tvar specials = new RegExp(\"[.*+?|()\\\\[\\\\]{}\\\\\\\\]\", \"g\"); // .*+?|()[]{}\\\n\t\t\treturn str.replace(specials, \"\\\\$&\");\n\t\t},\n\t\t\n\t\t/**\n\t\t * Make decimal number look good: convert it to fixed precision end remove\n\t\t * traling zeroes \n\t\t * @param {Number} num\n\t\t * @param {Number} fracion Fraction numbers (default is 2)\n\t\t * @return {String}\n\t\t */\n\t\tprettifyNumber: function(num, fraction) {\n\t\t\treturn num.toFixed(typeof fraction == 'undefined' ? 2 : fraction).replace(/\\.?0+$/, '');\n\t\t},\n\t\t\n\t\t/**\n\t\t * A simple mutable string shim, optimized for faster text concatenation\n\t\t * @param {String} value Initial value\n\t\t * @returns {StringBuilder}\n\t\t */\n\t\tstringBuilder: function(value) {\n\t\t\treturn new StringBuilder(value);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Replace substring of <code>str</code> with <code>value</code>\n\t\t * @param {String} str String where to replace substring\n\t\t * @param {String} value New substring value\n\t\t * @param {Number} start Start index of substring to replace. May also\n\t\t * be a <code>Range</code> object: in this case, the <code>end</code>\n\t\t * argument is not required\n\t\t * @param {Number} end End index of substring to replace. If ommited, \n\t\t * <code>start</code> argument is used\n\t\t */\n\t\treplaceSubstring: function(str, value, start, end) {\n\t\t\tif (_.isObject(start) && 'end' in start) {\n\t\t\t\tend = start.end;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(end))\n\t\t\t\tend = start + end.length;\n\t\t\t\n\t\t\tif (_.isUndefined(end))\n\t\t\t\tend = start;\n\t\t\t\n\t\t\tif (start < 0 || start > str.length)\n\t\t\t\treturn str;\n\t\t\t\n\t\t\treturn str.substring(0, start) + value + str.substring(end);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Narrows down text range, adjusting selection to non-space characters\n\t\t * @param {String} text\n\t\t * @param {Number} start Starting range in <code>text</code> where \n\t\t * slection should be adjusted. Can also be any object that is accepted\n\t\t * by <code>Range</code> class\n\t\t * @return {Range}\n\t\t */\n\t\tnarrowToNonSpace: function(text, start, end) {\n\t\t\tvar range = require('range').create(start, end);\n\t\t\t\n\t\t\tvar reSpace = /[\\s\\n\\r\\u00a0]/;\n\t\t\t// narrow down selection until first non-space character\n\t\t\twhile (range.start < range.end) {\n\t\t\t\tif (!reSpace.test(text.charAt(range.start)))\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\trange.start++;\n\t\t\t}\n\t\t\t\n\t\t\twhile (range.end > range.start) {\n\t\t\t\trange.end--;\n\t\t\t\tif (!reSpace.test(text.charAt(range.end))) {\n\t\t\t\t\trange.end++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn range;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find start and end index of text line for <code>from</code> index\n\t\t * @param {String} text \n\t\t * @param {Number} from\n\t\t */\n\t\tfindNewlineBounds: function(text, from) {\n\t\t\tvar len = text.length,\n\t\t\t\tstart = 0,\n\t\t\t\tend = len - 1;\n\t\t\t\n\t\t\t// search left\n\t\t\tfor (var i = from - 1; i > 0; i--) {\n\t\t\t\tvar ch = text.charAt(i);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tstart = i + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// search right\n\t\t\tfor (var j = from; j < len; j++) {\n\t\t\t\tvar ch = text.charAt(j);\n\t\t\t\tif (ch == '\\n' || ch == '\\r') {\n\t\t\t\t\tend = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn require('range').create(start, end - start);\n\t\t},\n\n\t\t/**\n\t\t * Deep merge of two or more objects. Taken from jQuery.extend()\n\t\t */\n\t\tdeepMerge: function() {\n\t\t\tvar options, name, src, copy, copyIsArray, clone,\n\t\t\t\ttarget = arguments[0] || {},\n\t\t\t\ti = 1,\n\t\t\t\tlength = arguments.length;\n\n\n\t\t\t// Handle case when target is a string or something (possible in deep copy)\n\t\t\tif (!_.isObject(target) && !_.isFunction(target)) {\n\t\t\t\ttarget = {};\n\t\t\t}\n\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\t// Only deal with non-null/undefined values\n\t\t\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t\t\t// Extend the base object\n\t\t\t\t\tfor ( name in options ) {\n\t\t\t\t\t\tsrc = target[ name ];\n\t\t\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t\t\t// Prevent never-ending loop\n\t\t\t\t\t\tif ( target === copy ) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\t\tif ( copy && ( _.isObject(copy) || (copyIsArray = _.isArray(copy)) ) ) {\n\t\t\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\t\tclone = src && _.isArray(src) ? src : [];\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tclone = src && _.isObject(src) ? src : {};\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\t\ttarget[ name ] = this.deepMerge(clone, copy );\n\n\t\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return the modified object\n\t\t\treturn target;\n\t\t}\n\t};\n});\n/**\n * Helper module to work with ranges\n * @constructor\n * @memberOf __rangeDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('range', function(require, _) {\n\tfunction cmp(a, b, op) {\n\t\tswitch (op) {\n\t\t\tcase 'eq':\n\t\t\tcase '==':\n\t\t\t\treturn a === b;\n\t\t\tcase 'lt':\n\t\t\tcase '<':\n\t\t\t\treturn a < b;\n\t\t\tcase 'lte':\n\t\t\tcase '<=':\n\t\t\t\treturn a <= b;\n\t\t\tcase 'gt':\n\t\t\tcase '>':\n\t\t\t\treturn a > b;\n\t\t\tcase 'gte':\n\t\t\tcase '>=':\n\t\t\t\treturn a >= b;\n\t\t}\n\t}\n\t\n\t\n\t/**\n\t * @type Range\n\t * @constructor\n\t * @param {Object} start\n\t * @param {Number} len\n\t */\n\tfunction Range(start, len) {\n\t\tif (_.isObject(start) && 'start' in start) {\n\t\t\t// create range from object stub\n\t\t\tthis.start = Math.min(start.start, start.end);\n\t\t\tthis.end = Math.max(start.start, start.end);\n\t\t} else if (_.isArray(start)) {\n\t\t\tthis.start = start[0];\n\t\t\tthis.end = start[1];\n\t\t} else {\n\t\t\tlen = _.isString(len) ? len.length : +len;\n\t\t\tthis.start = start;\n\t\t\tthis.end = start + len;\n\t\t}\n\t}\n\t\n\tRange.prototype = {\n\t\tlength: function() {\n\t\t\treturn Math.abs(this.end - this.start);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns <code>true</code> if passed range is equals to current one\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\tequal: function(range) {\n\t\t\treturn this.cmp(range, 'eq', 'eq');\n//\t\t\treturn this.start === range.start && this.end === range.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shifts indexes position with passed <code>delat</code>\n\t\t * @param {Number} delta\n\t\t * @returns {Range} range itself\n\t\t */\n\t\tshift: function(delta) {\n\t\t\tthis.start += delta;\n\t\t\tthis.end += delta;\n\t\t\treturn this;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if two ranges are overlapped\n\t\t * @param {Range} range\n\t\t * @returns {Boolean}\n\t\t */\n\t\toverlap: function(range) {\n\t\t\treturn range.start <= this.end && range.end >= this.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Finds intersection of two ranges\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges does not overlap\n\t\t */\n\t\tintersection: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.max(range.start, this.start);\n\t\t\t\tvar end = Math.min(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the union of the thow ranges.\n\t\t * @param {Range} range\n\t\t * @returns {Range} <code>null</code> if ranges are not overlapped\n\t\t */\n\t\tunion: function(range) {\n\t\t\tif (this.overlap(range)) {\n\t\t\t\tvar start = Math.min(range.start, this.start);\n\t\t\t\tvar end = Math.max(range.end, this.end);\n\t\t\t\treturn new Range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range.\n\t\t * @param {Number} loc\n\t\t */\n\t\tinside: function(loc) {\n\t\t\treturn this.cmp(loc, 'lte', 'gt');\n//\t\t\treturn this.start <= loc && this.end > loc;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns a Boolean value that indicates whether a specified position \n\t\t * is in a given range, but not equals bounds.\n\t\t * @param {Number} loc\n\t\t */\n\t\tcontains: function(loc) {\n\t\t\treturn this.cmp(loc, 'lt', 'gt');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current range completely includes specified one\n\t\t * @param {Range} r\n\t\t * @returns {Boolean} \n\t\t */\n\t\tinclude: function(r) {\n\t\t\treturn this.cmp(loc, 'lte', 'gte');\n//\t\t\treturn this.start <= r.start && this.end >= r.end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Low-level comparision method\n\t\t * @param {Number} loc\n\t\t * @param {String} left Left comparison operator\n\t\t * @param {String} right Right comaprison operator\n\t\t */\n\t\tcmp: function(loc, left, right) {\n\t\t\tvar a, b;\n\t\t\tif (loc instanceof Range) {\n\t\t\t\ta = loc.start;\n\t\t\t\tb = loc.end;\n\t\t\t} else {\n\t\t\t\ta = b = loc;\n\t\t\t}\n\t\t\t\n\t\t\treturn cmp(this.start, a, left || '<=') && cmp(this.end, b, right || '>');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns substring of specified <code>str</code> for current range\n\t\t * @param {String} str\n\t\t * @returns {String}\n\t\t */\n\t\tsubstring: function(str) {\n\t\t\treturn this.length() > 0 \n\t\t\t\t? str.substring(this.start, this.end) \n\t\t\t\t: '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates copy of current range\n\t\t * @returns {Range}\n\t\t */\n\t\tclone: function() {\n\t\t\treturn new Range(this.start, this.length());\n\t\t},\n\t\t\n\t\t/**\n\t\t * @returns {Array}\n\t\t */\n\t\ttoArray: function() {\n\t\t\treturn [this.start, this.end];\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn '{' + this.start + ', ' + this.length() + '}';\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new range object instance\n\t\t * @param {Object} start Range start or array with 'start' and 'end'\n\t\t * as two first indexes or object with 'start' and 'end' properties\n\t\t * @param {Number} len Range length or string to produce range from\n\t\t * @returns {Range}\n\t\t * @memberOf emmet.range\n\t\t */\n\t\tcreate: function(start, len) {\n\t\t\tif (_.isUndefined(start) || start === null)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (start instanceof Range)\n\t\t\t\treturn start;\n\t\t\t\n\t\t\tif (_.isObject(start) && 'start' in start && 'end' in start) {\n\t\t\t\tlen = start.end - start.start;\n\t\t\t\tstart = start.start;\n\t\t\t}\n\t\t\t\t\n\t\t\treturn new Range(start, len);\n\t\t},\n\t\t\n\t\t/**\n\t\t * <code>Range</code> object factory, the same as <code>this.create()</code>\n\t\t * but last argument represents end of range, not length\n\t\t * @returns {Range}\n\t\t */\n\t\tcreate2: function(start, end) {\n\t\t\tif (_.isNumber(start) && _.isNumber(end)) {\n\t\t\t\tend -= start;\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(start, end);\n\t\t}\n\t};\n});/**\n * Utility module that provides ordered storage of function handlers. \n * Many Emmet modules' functionality can be extended/overridden by custom\n * function. This modules provides unified storage of handler functions, their \n * management and execution\n * \n * @constructor\n * @memberOf __handlerListDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('handlerList', function(require, _) {\n\t/**\n\t * @type HandlerList\n\t * @constructor\n\t */\n\tfunction HandlerList() {\n\t\tthis._list = [];\n\t}\n\t\n\tHandlerList.prototype = {\n\t\t/**\n\t\t * Adds function handler\n\t\t * @param {Function} fn Handler\n\t\t * @param {Object} options Handler options. Possible values are:<br><br>\n\t\t * <b>order</b> : (<code>Number</code>)  order in handler list. Handlers\n\t\t * with higher order value will be executed earlier.\n\t\t */\n\t\tadd: function(fn, options) {\n\t\t\tthis._list.push(_.extend({order: 0}, options || {}, {fn: fn}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes handler from list\n\t\t * @param {Function} fn\n\t\t */\n\t\tremove: function(fn) {\n\t\t\tthis._list = _.without(this._list, _.find(this._list, function(item) {\n\t\t\t\treturn item.fn === fn;\n\t\t\t}));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handlers. By default, handlers \n\t\t * with the same <code>order</code> option returned in reverse order, \n\t\t * i.e. the latter function was added into the handlers list, the higher \n\t\t * it will be in the returned array \n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.sortBy(this._list, 'order').reverse();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ordered list of handler functions\n\t\t * @returns {Array}\n\t\t */\n\t\tlistFn: function() {\n\t\t\treturn _.pluck(this.list(), 'fn');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Executes handler functions in their designated order. If function\n\t\t * returns <code>skipVal</code>, meaning that function was unable to \n\t\t * handle passed <code>args</code>, the next function will be executed\n\t\t * and so on.\n\t\t * @param {Object} skipValue If function returns this value, execute \n\t\t * next handler.\n\t\t * @param {Array} args Arguments to pass to handler function\n\t\t * @returns {Boolean} Whether any of registered handlers performed\n\t\t * successfully  \n\t\t */\n\t\texec: function(skipValue, args) {\n\t\t\targs = args || [];\n\t\t\tvar result = null;\n\t\t\t_.find(this.list(), function(h) {\n\t\t\t\tresult = h.fn.apply(h, args);\n\t\t\t\tif (result !== skipValue)\n\t\t\t\t\treturn true;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Factory method that produces <code>HandlerList</code> instance\n\t\t * @returns {HandlerList}\n\t\t * @memberOf handlerList\n\t\t */\n\t\tcreate: function() {\n\t\t\treturn new HandlerList();\n\t\t}\n\t};\n});/**\n * Helper class for convenient token iteration\n */\nemmet.define('tokenIterator', function(require, _) {\n\t/**\n\t * @type TokenIterator\n\t * @param {Array} tokens\n\t * @type TokenIterator\n\t * @constructor\n\t */\n\tfunction TokenIterator(tokens) {\n\t\t/** @type Array */\n\t\tthis.tokens = tokens;\n\t\tthis._position = 0;\n\t\tthis.reset();\n\t}\n\t\n\tTokenIterator.prototype = {\n\t\tnext: function() {\n\t\t\tif (this.hasNext()) {\n\t\t\t\tvar token = this.tokens[++this._i];\n\t\t\t\tthis._position = token.start;\n\t\t\t\treturn token;\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\tcurrent: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\tposition: function() {\n\t\t\treturn this._position;\n\t\t},\n\t\t\n\t\thasNext: function() {\n\t\t\treturn this._i < this._il - 1;\n\t\t},\n\t\t\n\t\treset: function() {\n\t\t\tthis._i = -1;\n\t\t\tthis._il = this.tokens.length;\n\t\t},\n\t\t\n\t\titem: function() {\n\t\t\treturn this.tokens[this._i];\n\t\t},\n\t\t\n\t\titemNext: function() {\n\t\t\treturn this.tokens[this._i + 1];\n\t\t},\n\t\t\n\t\titemPrev: function() {\n\t\t\treturn this.tokens[this._i - 1];\n\t\t},\n\t\t\n\t\tnextUntil: function(type, callback) {\n\t\t\tvar token;\n\t\t\tvar test = _.isString(type) \n\t\t\t\t? function(t){return t.type == type;} \n\t\t\t\t: type;\n\t\t\t\n\t\t\twhile (token = this.next()) {\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback.call(this, token);\n\t\t\t\tif (test.call(this, token))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(tokens) {\n\t\t\treturn new TokenIterator(tokens);\n\t\t}\n\t};\n});/**\n * A trimmed version of CodeMirror's StringStream module for string parsing\n */\nemmet.define('stringStream', function(require, _) {\n\t/**\n\t * @type StringStream\n\t * @constructor\n\t * @param {String} string\n\t */\n\tfunction StringStream(string) {\n\t\tthis.pos = this.start = 0;\n\t\tthis.string = string;\n\t}\n\t\n\tStringStream.prototype = {\n\t\t/**\n\t\t * Returns true only if the stream is at the end of the line.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teol: function() {\n\t\t\treturn this.pos >= this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns true only if the stream is at the start of the line\n\t\t * @returns {Boolean}\n\t\t */\n\t\tsol: function() {\n\t\t\treturn this.pos == 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream without advancing it. \n\t\t * Will return <code>undefined</code> at the end of the line.\n\t\t * @returns {String}\n\t\t */\n\t\tpeek: function() {\n\t\t\treturn this.string.charAt(this.pos);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns the next character in the stream and advances it.\n\t\t * Also returns <code>undefined</code> when no more characters are available.\n\t\t * @returns {String}\n\t\t */\n\t\tnext: function() {\n\t\t\tif (this.pos < this.string.length)\n\t\t\t\treturn this.string.charAt(this.pos++);\n\t\t},\n\t\t\n\t\t/**\n\t\t * match can be a character, a regular expression, or a function that\n\t\t * takes a character and returns a boolean. If the next character in the\n\t\t * stream 'matches' the given argument, it is consumed and returned.\n\t\t * Otherwise, undefined is returned.\n\t\t * @param {Object} match\n\t\t * @returns {String}\n\t\t */\n\t\teat: function(match) {\n\t\t\tvar ch = this.string.charAt(this.pos), ok;\n\t\t\tif (typeof match == \"string\")\n\t\t\t\tok = ch == match;\n\t\t\telse\n\t\t\t\tok = ch && (match.test ? match.test(ch) : match(ch));\n\t\t\t\n\t\t\tif (ok) {\n\t\t\t\t++this.pos;\n\t\t\t\treturn ch;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Repeatedly calls <code>eat</code> with the given argument, until it\n\t\t * fails. Returns <code>true</code> if any characters were eaten.\n\t\t * @param {Object} match\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatWhile: function(match) {\n\t\t\tvar start = this.pos;\n\t\t\twhile (this.eat(match)) {}\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Shortcut for <code>eatWhile</code> when matching white-space.\n\t\t * @returns {Boolean}\n\t\t */\n\t\teatSpace: function() {\n\t\t\tvar start = this.pos;\n\t\t\twhile (/[\\s\\u00a0]/.test(this.string.charAt(this.pos)))\n\t\t\t\t++this.pos;\n\t\t\treturn this.pos > start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Moves the position to the end of the line.\n\t\t */\n\t\tskipToEnd: function() {\n\t\t\tthis.pos = this.string.length;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to the next occurrence of the given character, if found on the\n\t\t * current line (doesn't advance the stream if the character does not\n\t\t * occur on the line). Returns true if the character was found.\n\t\t * @param {String} ch\n\t\t * @returns {Boolean}\n\t\t */\n\t\tskipTo: function(ch) {\n\t\t\tvar found = this.string.indexOf(ch, this.pos);\n\t\t\tif (found > -1) {\n\t\t\t\tthis.pos = found;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Skips to <code>close</code> character which is pair to <code>open</code>\n\t\t * character, considering possible pair nesting. This function is used\n\t\t * to consume pair of characters, like opening and closing braces\n\t\t * @param {String} open\n\t\t * @param {String} close\n\t\t * @returns {Boolean} Returns <code>true</code> if pair was successfully\n\t\t * consumed\n\t\t */\n\t\tskipToPair: function(open, close) {\n\t\t\tvar braceCount = 0, ch;\n\t\t\tvar pos = this.pos, len = this.string.length;\n\t\t\twhile (pos < len) {\n\t\t\t\tch = this.string.charAt(pos++);\n\t\t\t\tif (ch == open) {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == close) {\n\t\t\t\t\tbraceCount--;\n\t\t\t\t\tif (braceCount < 1) {\n\t\t\t\t\t\tthis.pos = pos;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Backs up the stream n characters. Backing it up further than the\n\t\t * start of the current token will cause things to break, so be careful.\n\t\t * @param {Number} n\n\t\t */\n\t\tbackUp : function(n) {\n\t\t\tthis.pos -= n;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Act like a multi-character <code>eat</code>if <code>consume</code> is true or\n\t\t * not givenor a look-ahead that doesn't update the stream positionif\n\t\t * it is false. <code>pattern</code> can be either a string or a\n\t\t * regular expression starting with ^. When it is a string,\n\t\t * <code>caseInsensitive</code> can be set to true to make the match\n\t\t * case-insensitive. When successfully matching a regular expression,\n\t\t * the returned value will be the array returned by <code>match</code>,\n\t\t * in case you need to extract matched groups.\n\t\t * \n\t\t * @param {RegExp} pattern\n\t\t * @param {Boolean} consume\n\t\t * @param {Boolean} caseInsensitive\n\t\t * @returns\n\t\t */\n\t\tmatch: function(pattern, consume, caseInsensitive) {\n\t\t\tif (typeof pattern == \"string\") {\n\t\t\t\tvar cased = caseInsensitive\n\t\t\t\t\t? function(str) {return str.toLowerCase();}\n\t\t\t\t\t: function(str) {return str;};\n\t\t\t\t\n\t\t\t\tif (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n\t\t\t\t\tif (consume !== false)\n\t\t\t\t\t\tthis.pos += pattern.length;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar match = this.string.slice(this.pos).match(pattern);\n\t\t\t\tif (match && consume !== false)\n\t\t\t\t\tthis.pos += match[0].length;\n\t\t\t\treturn match;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Get the string between the start of the current token and the \n\t\t * current stream position.\n\t\t * @returns {String}\n\t\t */\n\t\tcurrent: function() {\n\t\t\treturn this.string.slice(this.start, this.pos);\n\t\t}\n\t};\n\t\n\treturn {\n\t\tcreate: function(string) {\n\t\t\treturn new StringStream(string);\n\t\t}\n\t};\n});/**\n * Parsed resources (snippets, abbreviations, variables, etc.) for Emmet.\n * Contains convenient method to get access for snippets with respect of \n * inheritance. Also provides ability to store data in different vocabularies\n * ('system' and 'user') for fast and safe resource update\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('resources', function(require, _) {\n\tvar VOC_SYSTEM = 'system';\n\tvar VOC_USER = 'user';\n\t\n\tvar cache = {};\n\t\t\n\t/** Regular expression for XML tag matching */\n\tvar reTag = /^<(\\w+\\:?[\\w\\-]*)((?:\\s+[\\w\\:\\-]+\\s*=\\s*(['\"]).*?\\3)*)\\s*(\\/?)>/;\n\t\t\n\tvar systemSettings = {};\n\tvar userSettings = {};\n\t\n\t/** @type HandlerList List of registered abbreviation resolvers */\n\tvar resolvers = require('handlerList').create();\n\t\n\t/**\n\t * Normalizes caret plceholder in passed text: replaces | character with\n\t * default caret placeholder\n\t * @param {String} text\n\t * @returns {String}\n\t */\n\tfunction normalizeCaretPlaceholder(text) {\n\t\tvar utils = require('utils');\n\t\treturn utils.replaceUnescapedSymbol(text, '|', utils.getCaretPlaceholder());\n\t}\n\t\n\tfunction parseItem(name, value, type) {\n\t\tvalue = normalizeCaretPlaceholder(value);\n\t\t\n\t\tif (type == 'snippets') {\n\t\t\treturn require('elements').create('snippet', value);\n\t\t}\n\t\t\n\t\tif (type == 'abbreviations') {\n\t\t\treturn parseAbbreviation(name, value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Parses single abbreviation\n\t * @param {String} key Abbreviation name\n\t * @param {String} value Abbreviation value\n\t * @return {Object}\n\t */\n\tfunction parseAbbreviation(key, value) {\n\t\tkey = require('utils').trim(key);\n\t\tvar elements = require('elements');\n\t\tvar m;\n\t\tif (m = reTag.exec(value)) {\n\t\t\treturn elements.create('element', m[1], m[2], m[4] == '/');\n\t\t} else {\n\t\t\t// assume it's reference to another abbreviation\n\t\t\treturn elements.create('reference', value);\n\t\t}\n\t}\n\t\n\t/**\n\t * Normalizes snippet key name for better fuzzy search\n\t * @param {String} str\n\t * @returns {String}\n\t */\n\tfunction normalizeName(str) {\n\t\treturn str.replace(/:$/, '').replace(/:/g, '-');\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Sets new unparsed data for specified settings vocabulary\n\t\t * @param {Object} data\n\t\t * @param {String} type Vocabulary type ('system' or 'user')\n\t\t * @memberOf resources\n\t\t */\n\t\tsetVocabulary: function(data, type) {\n\t\t\tcache = {};\n\t\t\tif (type == VOC_SYSTEM)\n\t\t\t\tsystemSettings = data;\n\t\t\telse\n\t\t\t\tuserSettings = data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource vocabulary by its name\n\t\t * @param {String} name Vocabulary name ('system' or 'user')\n\t\t * @return {Object}\n\t\t */\n\t\tgetVocabulary: function(name) {\n\t\t\treturn name == VOC_SYSTEM ? systemSettings : userSettings;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns resource (abbreviation, snippet, etc.) matched for passed \n\t\t * abbreviation\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetMatchedResource: function(node, syntax) {\n\t\t\treturn resolvers.exec(null, _.toArray(arguments)) \n\t\t\t\t|| this.findSnippet(syntax, node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns variable value\n\t\t * @return {String}\n\t\t */\n\t\tgetVariable: function(name) {\n\t\t\treturn (this.getSection('variables') || {})[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Store runtime variable in user storage\n\t\t * @param {String} name Variable name\n\t\t * @param {String} value Variable value\n\t\t */\n\t\tsetVariable: function(name, value){\n\t\t\tvar voc = this.getVocabulary('user') || {};\n\t\t\tif (!('variables' in voc))\n\t\t\t\tvoc.variables = {};\n\t\t\t\t\n\t\t\tvoc.variables[name] = value;\n\t\t\tthis.setVocabulary(voc, 'user');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if there are resources for specified syntax\n\t\t * @param {String} syntax\n\t\t * @return {Boolean}\n\t\t */\n\t\thasSyntax: function(syntax) {\n\t\t\treturn syntax in this.getVocabulary(VOC_USER) \n\t\t\t\t|| syntax in this.getVocabulary(VOC_SYSTEM);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Registers new abbreviation resolver.\n\t\t * @param {Function} fn Abbreviation resolver which will receive \n\t\t * abbreviation as first argument and should return parsed abbreviation\n\t\t * object if abbreviation has handled successfully, <code>null</code>\n\t\t * otherwise\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddResolver: function(fn, options) {\n\t\t\tresolvers.add(fn, options);\n\t\t},\n\t\t\n\t\tremoveResolver: function(fn) {\n\t\t\tresolvers.remove(fn);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actual section data, merged from both\n\t\t * system and user data\n\t\t * @param {String} name Section name (syntax)\n\t\t * @param {String} ...args Subsections\n\t\t * @returns\n\t\t */\n\t\tgetSection: function(name) {\n\t\t\tif (!name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tif (!(name in cache)) {\n\t\t\t\tcache[name] = require('utils').deepMerge({}, systemSettings[name], userSettings[name]);\n\t\t\t}\n\t\t\t\n\t\t\tvar data = cache[name], subsections = _.rest(arguments), key;\n\t\t\twhile (data && (key = subsections.shift())) {\n\t\t\t\tif (key in data) {\n\t\t\t\t\tdata = data[key];\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn data;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a item inside top level sections (syntaxes)\n\t\t * with respect of `extends` attribute\n\t\t * @param {String} topSection Top section name (syntax)\n\t\t * @param {String} subsection Inner section name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindItem: function(topSection, subsection) {\n\t\t\tvar data = this.getSection(topSection);\n\t\t\twhile (data) {\n\t\t\t\tif (subsection in data)\n\t\t\t\t\treturn data[subsection];\n\t\t\t\t\n\t\t\t\tdata = this.getSection(data['extends']);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Recursively searches for a snippet definition inside syntax section.\n\t\t * Definition is searched inside `snippets` and `abbreviations` \n\t\t * subsections  \n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns {Object}\n\t\t */\n\t\tfindSnippet: function(syntax, name, memo) {\n\t\t\tif (!syntax || !name)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tmemo = memo || [];\n\t\t\t\n\t\t\tvar names = [name];\n\t\t\t// create automatic aliases to properties with colons,\n\t\t\t// e.g. pos-a == pos:a\n\t\t\tif (~name.indexOf('-'))\n\t\t\t\tnames.push(name.replace(/\\-/g, ':'));\n\t\t\t\n\t\t\tvar data = this.getSection(syntax), matchedItem = null;\n\t\t\t_.find(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\tvar data = this.getSection(syntax, sectionName);\n\t\t\t\tif (data) {\n\t\t\t\t\treturn _.find(names, function(n) {\n\t\t\t\t\t\tif (data[n])\n\t\t\t\t\t\t\treturn matchedItem = parseItem(n, data[n], sectionName);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tmemo.push(syntax);\n\t\t\tif (!matchedItem && data['extends'] && !_.include(memo, data['extends'])) {\n\t\t\t\t// try to find item in parent syntax section\n\t\t\t\treturn this.findSnippet(data['extends'], name, memo);\n\t\t\t}\n\t\t\t\n\t\t\treturn matchedItem;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Performs fuzzy search of snippet definition\n\t\t * @param {String} syntax Top-level section name (syntax)\n\t\t * @param {String} name Snippet name\n\t\t * @returns\n\t\t */\n\t\tfuzzyFindSnippet: function(syntax, name, minScore) {\n\t\t\tminScore = minScore || 0.3;\n\t\t\t\n\t\t\tvar payload = this.getAllSnippets(syntax);\n\t\t\tvar sc = require('string-score');\n\t\t\t\n\t\t\tname = normalizeName(name);\n\t\t\tvar scores = _.map(payload, function(value, key) {\n\t\t\t\treturn {\n\t\t\t\t\tkey: key,\n\t\t\t\t\tscore: sc.score(value.nk, name, 0.1)\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tvar result = _.last(_.sortBy(scores, 'score'));\n\t\t\tif (result && result.score >= minScore) {\n\t\t\t\tvar k = result.key;\n\t\t\t\treturn payload[k].parsedValue;\n//\t\t\t\treturn parseItem(k, payload[k].value, payload[k].type);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns plain dictionary of all available abbreviations and snippets\n\t\t * for specified syntax with respect of inheritance\n\t\t * @param {String} syntax\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAllSnippets: function(syntax) {\n\t\t\tvar cacheKey = 'all-' + syntax;\n\t\t\tif (!cache[cacheKey]) {\n\t\t\t\tvar stack = [], sectionKey = syntax;\n\t\t\t\tvar memo = [];\n\t\t\t\t\n\t\t\t\tdo {\n\t\t\t\t\tvar section = this.getSection(sectionKey);\n\t\t\t\t\tif (!section)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t_.each(['snippets', 'abbreviations'], function(sectionName) {\n\t\t\t\t\t\tvar stackItem = {};\n\t\t\t\t\t\t_.each(section[sectionName] || null, function(v, k) {\n\t\t\t\t\t\t\tstackItem[k] = {\n\t\t\t\t\t\t\t\tnk: normalizeName(k),\n\t\t\t\t\t\t\t\tvalue: v,\n\t\t\t\t\t\t\t\tparsedValue: parseItem(k, v, sectionName),\n\t\t\t\t\t\t\t\ttype: sectionName\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tstack.push(stackItem);\n\t\t\t\t\t});\n\t\t\t\t\t\n\t\t\t\t\tmemo.push(sectionKey);\n\t\t\t\t\tsectionKey = section['extends'];\n\t\t\t\t} while (sectionKey && !_.include(memo, sectionKey));\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcache[cacheKey] = _.extend.apply(_, stack.reverse());\n\t\t\t}\n\t\t\t\n\t\t\treturn cache[cacheKey];\n\t\t}\n\t};\n});/**\n * Module describes and performs Emmet actions. The actions themselves are\n * defined in <i>actions</i> folder\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('actions', function(require, _, zc) {\n\tvar actions = {};\n\t\n\t/**\n\t * Humanizes action name, makes it more readable for people\n\t * @param {String} name Action name (like 'expand_abbreviation')\n\t * @return Humanized name (like 'Expand Abbreviation')\n\t */\n\tfunction humanizeActionName(name) {\n\t\treturn require('utils').trim(name.charAt(0).toUpperCase() \n\t\t\t+ name.substring(1).replace(/_[a-z]/g, function(str) {\n\t\t\t\treturn ' ' + str.charAt(1).toUpperCase();\n\t\t\t}));\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Registers new action\n\t\t * @param {String} name Action name\n\t\t * @param {Function} fn Action function\n\t\t * @param {Object} options Custom action options:<br>\n\t\t * <b>label</b> : (<code>String</code>)  Human-readable action name. \n\t\t * May contain '/' symbols as submenu separators<br>\n\t\t * <b>hidden</b> : (<code>Boolean</code>)  Indicates whether action\n\t\t * should be displayed in menu (<code>getMenu()</code> method)\n\t\t * \n\t\t * @memberOf actions\n\t\t */\n\t\tadd: function(name, fn, options) {\n\t\t\tname = name.toLowerCase();\n\t\t\toptions = options || {};\n\t\t\tif (!options.label) {\n\t\t\t\toptions.label = humanizeActionName(name);\n\t\t\t}\n\t\t\t\n\t\t\tactions[name] = {\n\t\t\t\tname: name,\n\t\t\t\tfn: fn,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns action object\n\t\t * @param {String} name Action name\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn actions[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Runs Emmet action. For list of available actions and their\n\t\t * arguments see <i>actions</i> folder.\n\t\t * @param {String} name Action name \n\t\t * @param {Array} args Additional arguments. It may be array of arguments\n\t\t * or inline arguments. The first argument should be <code>IEmmetEditor</code> instance\n\t\t * @returns {Boolean} Status of performed operation, <code>true</code>\n\t\t * means action was performed successfully.\n\t\t * @example\n\t\t * emmet.require('actions').run('expand_abbreviation', editor);  \n\t\t * emmet.require('actions').run('wrap_with_abbreviation', [editor, 'div']);  \n\t\t */\n\t\trun: function(name, args) {\n\t\t\tif (!_.isArray(args)) {\n\t\t\t\targs = _.rest(arguments);\n\t\t\t}\n\t\t\t\n\t\t\tvar action = this.get(name);\n\t\t\tif (action) {\n\t\t\t\treturn action.fn.apply(emmet, args);\n\t\t\t} else {\n\t\t\t\temmet.log('Action \"%s\" is not defined', name);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as object\n\t\t * @returns {Object}\n\t\t */\n\t\tgetAll: function() {\n\t\t\treturn actions;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all registered actions as array\n\t\t * @returns {Array}\n\t\t */\n\t\tgetList: function() {\n\t\t\treturn _.values(this.getAll());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns actions list as structured menu. If action has <i>label</i>,\n\t\t * it will be splitted by '/' symbol into submenus (for example: \n\t\t * CSS/Reflect Value) and grouped with other items\n\t\t * @param {Array} skipActions List of action identifiers that should be \n\t\t * skipped from menu\n\t\t * @returns {Array}\n\t\t */\n\t\tgetMenu: function(skipActions) {\n\t\t\tvar result = [];\n\t\t\tskipActions = skipActions || [];\n\t\t\t_.each(this.getList(), function(action) {\n\t\t\t\tif (action.options.hidden || _.include(skipActions, action.name))\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tvar actionName = humanizeActionName(action.name);\n\t\t\t\tvar ctx = result;\n\t\t\t\tif (action.options.label) {\n\t\t\t\t\tvar parts = action.options.label.split('/');\n\t\t\t\t\tactionName = parts.pop();\n\t\t\t\t\t\n\t\t\t\t\t// create submenus, if needed\n\t\t\t\t\tvar menuName, submenu;\n\t\t\t\t\twhile (menuName = parts.shift()) {\n\t\t\t\t\t\tsubmenu = _.find(ctx, function(item) {\n\t\t\t\t\t\t\treturn item.type == 'submenu' && item.name == menuName;\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!submenu) {\n\t\t\t\t\t\t\tsubmenu = {\n\t\t\t\t\t\t\t\tname: menuName,\n\t\t\t\t\t\t\t\ttype: 'submenu',\n\t\t\t\t\t\t\t\titems: []\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tctx.push(submenu);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tctx = submenu.items;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tctx.push({\n\t\t\t\t\ttype: 'action',\n\t\t\t\t\tname: action.name,\n\t\t\t\t\tlabel: actionName\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\n\t\t/**\n\t\t * Returns action name associated with menu item title\n\t\t * @param {String} title\n\t\t * @returns {String}\n\t\t */\n\t\tgetActionNameForMenuTitle: function(title, menu) {\n\t\t\tvar item = null;\n\t\t\t_.find(menu || this.getMenu(), function(val) {\n\t\t\t\tif (val.type == 'action') {\n\t\t\t\t\tif (val.label == title || val.name == title) {\n\t\t\t\t\t\treturn item = val.name;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn item = this.getActionNameForMenuTitle(title, val.items);\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn item || null;\n\t\t}\n\t};\n});/**\n * Output profile module.\n * Profile defines how XHTML output data should look like\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('profile', function(require, _) {\n\tvar profiles = {};\n\t\n\tvar defaultProfile = {\n\t\ttag_case: 'asis',\n\t\tattr_case: 'asis',\n\t\tattr_quotes: 'double',\n\t\t\n\t\t// each tag on new line\n\t\ttag_nl: 'decide',\n\t\t\n\t\t// with tag_nl === true, defines if leaf node (e.g. node with no children)\n\t\t// should have formatted line breaks\n\t\ttag_nl_leaf: false,\n\t\t\n\t\tplace_cursor: true,\n\t\t\n\t\t// indent tags\n\t\tindent: true,\n\t\t\n\t\t// how many inline elements should be to force line break \n\t\t// (set to 0 to disable)\n\t\tinline_break: 3,\n\t\t\n\t\t// use self-closing style for writing empty elements, e.g. <br /> or <br>\n\t\tself_closing_tag: 'xhtml',\n\t\t\n\t\t// Profile-level output filters, re-defines syntax filters \n\t\tfilters: '',\n\t\t\n\t\t// Additional filters applied to abbreviation.\n\t\t// Unlike \"filters\", this preference doesn't override default filters\n\t\t// but add the instead every time given profile is chosen\n\t\textraFilters: ''\n\t};\n\t\n\t/**\n\t * @constructor\n\t * @type OutputProfile\n\t * @param {Object} options\n\t */\n\tfunction OutputProfile(options) {\n\t\t_.extend(this, defaultProfile, options);\n\t}\n\t\n\tOutputProfile.prototype = {\n\t\t/**\n\t\t * Transforms tag name case depending on current profile settings\n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\ttagName: function(name) {\n\t\t\treturn stringCase(name, this.tag_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Transforms attribute name case depending on current profile settings \n\t\t * @param {String} name String to transform\n\t\t * @returns {String}\n\t\t */\n\t\tattributeName: function(name) {\n\t\t\treturn stringCase(name, this.attr_case);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns quote character for current profile\n\t\t * @returns {String}\n\t\t */\n\t\tattributeQuote: function() {\n\t\t\treturn this.attr_quotes == 'single' ? \"'\" : '\"';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns self-closing tag symbol for current profile\n\t\t * @param {String} param\n\t\t * @returns {String}\n\t\t */\n\t\tselfClosing: function(param) {\n\t\t\tif (this.self_closing_tag == 'xhtml')\n\t\t\t\treturn ' /';\n\t\t\t\n\t\t\tif (this.self_closing_tag === true)\n\t\t\t\treturn '/';\n\t\t\t\n\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns cursor token based on current profile settings\n\t\t * @returns {String}\n\t\t */\n\t\tcursor: function() {\n\t\t\treturn this.place_cursor ? require('utils').getCaretPlaceholder() : '';\n\t\t}\n\t};\n\t\n\t/**\n\t * Helper function that converts string case depending on \n\t * <code>caseValue</code> \n\t * @param {String} str String to transform\n\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t * <i>upper</i> and <i>leave</i>\n\t * @returns {String}\n\t */\n\tfunction stringCase(str, caseValue) {\n\t\tswitch (String(caseValue || '').toLowerCase()) {\n\t\t\tcase 'lower':\n\t\t\t\treturn str.toLowerCase();\n\t\t\tcase 'upper':\n\t\t\t\treturn str.toUpperCase();\n\t\t}\n\t\t\n\t\treturn str;\n\t}\n\t\n\t/**\n\t * Creates new output profile\n\t * @param {String} name Profile name\n\t * @param {Object} options Profile options\n\t */\n\tfunction createProfile(name, options) {\n\t\treturn profiles[name.toLowerCase()] = new OutputProfile(options);\n\t}\n\t\n\tfunction createDefaultProfiles() {\n\t\tcreateProfile('xhtml');\n\t\tcreateProfile('html', {self_closing_tag: false});\n\t\tcreateProfile('xml', {self_closing_tag: true, tag_nl: true});\n\t\tcreateProfile('plain', {tag_nl: false, indent: false, place_cursor: false});\n\t\tcreateProfile('line', {tag_nl: false, indent: false, extraFilters: 's'});\n\t}\n\t\n\tcreateDefaultProfiles();\n\t\n\treturn  {\n\t\t/**\n\t\t * Creates new output profile and adds it into internal dictionary\n\t\t * @param {String} name Profile name\n\t\t * @param {Object} options Profile options\n\t\t * @memberOf emmet.profile\n\t\t * @returns {Object} New profile\n\t\t */\n\t\tcreate: function(name, options) {\n\t\t\tif (arguments.length == 2)\n\t\t\t\treturn createProfile(name, options);\n\t\t\telse\n\t\t\t\t// create profile object only\n\t\t\t\treturn new OutputProfile(_.defaults(name || {}, defaultProfile));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns profile by its name. If profile wasn't found, returns\n\t\t * 'plain' profile\n\t\t * @param {String} name Profile name. Might be profile itself\n\t\t * @param {String} syntax. Optional. Current editor syntax. If defined,\n\t\t * profile is searched in resources first, then in predefined profiles\n\t\t * @returns {Object}\n\t\t */\n\t\tget: function(name, syntax) {\n\t\t\tif (!name && syntax) {\n\t\t\t\t// search in user resources first\n\t\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\t\tif (profile) {\n\t\t\t\t\tname = profile;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!name) {\n\t\t\t\treturn profiles.plain;\n\t\t\t}\n\t\t\t\n\t\t\tif (name instanceof OutputProfile) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t\t\n\t\t\tif (_.isString(name) && name.toLowerCase() in profiles) {\n\t\t\t\treturn profiles[name.toLowerCase()];\n\t\t\t}\n\t\t\t\n\t\t\treturn this.create(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Deletes profile with specified name\n\t\t * @param {String} name Profile name\n\t\t */\n\t\tremove: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\tif (name in profiles)\n\t\t\t\tdelete profiles[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets all user-defined profiles\n\t\t */\n\t\treset: function() {\n\t\t\tprofiles = {};\n\t\t\tcreateDefaultProfiles();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that converts string case depending on \n\t\t * <code>caseValue</code> \n\t\t * @param {String} str String to transform\n\t\t * @param {String} caseValue Case value: can be <i>lower</i>, \n\t\t * <i>upper</i> and <i>leave</i>\n\t\t * @returns {String}\n\t\t */\n\t\tstringCase: stringCase\n\t};\n});/**\n * Utility module used to prepare text for pasting into back-end editor\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('editorUtils', function(require, _) {\n\treturn  {\n\t\t/**\n\t\t * Check if cursor is placed inside XHTML tag\n\t\t * @param {String} html Contents of the document\n\t\t * @param {Number} caretPos Current caret position inside tag\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInsideTag: function(html, caretPos) {\n\t\t\tvar reTag = /^<\\/?\\w[\\w\\:\\-]*.*?>/;\n\t\t\t\n\t\t\t// search left to find opening brace\n\t\t\tvar pos = caretPos;\n\t\t\twhile (pos > -1) {\n\t\t\t\tif (html.charAt(pos) == '<') \n\t\t\t\t\tbreak;\n\t\t\t\tpos--;\n\t\t\t}\n\t\t\t\n\t\t\tif (pos != -1) {\n\t\t\t\tvar m = reTag.exec(html.substring(pos));\n\t\t\t\tif (m && caretPos > pos && caretPos < pos + m[0].length)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sanitizes incoming editor data and provides default values for\n\t\t * output-specific info\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {String} syntax\n\t\t * @param {String} profile\n\t\t */\n\t\toutputInfo: function(editor, syntax, profile) {\n\t\t\t// most of this code makes sense for Java/Rhino environment\n\t\t\t// because string that comes from Java are not actually JS string\n\t\t\t// but Java String object so the have to be explicitly converted\n\t\t\t// to native string\n\t\t\tprofile = profile || editor.getProfileName();\n\t\t\treturn  {\n\t\t\t\t/** @memberOf outputInfo */\n\t\t\t\tsyntax: String(syntax || editor.getSyntax()),\n\t\t\t\tprofile: profile || null,\n\t\t\t\tcontent: String(editor.getContent())\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Unindent content, thus preparing text for tag wrapping\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @param {String} text\n\t\t * @return {String}\n\t\t */\n\t\tunindent: function(editor, text) {\n\t\t\treturn require('utils').unindentString(text, this.getCurrentLinePadding(editor));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns padding of current editor's line\n\t\t * @param {IEmmetEditor} Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tgetCurrentLinePadding: function(editor) {\n\t\t\treturn require('utils').getLinePadding(editor.getCurrentLine());\n\t\t}\n\t};\n});\n/**\n * Utility methods for Emmet actions\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('actionUtils', function(require, _) {\n\treturn {\n\t\tmimeTypes: {\n\t\t\t'gif' : 'image/gif',\n\t\t\t'png' : 'image/png',\n\t\t\t'jpg' : 'image/jpeg',\n\t\t\t'jpeg': 'image/jpeg',\n\t\t\t'svg' : 'image/svg+xml',\n\t\t\t'html': 'text/html',\n\t\t\t'htm' : 'text/html'\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts abbreviations from text stream, starting from the end\n\t\t * @param {String} str\n\t\t * @return {String} Abbreviation or empty string\n\t\t * @memberOf emmet.actionUtils\n\t\t */\n\t\textractAbbreviation: function(str) {\n\t\t\tvar curOffset = str.length;\n\t\t\tvar startIndex = -1;\n\t\t\tvar groupCount = 0;\n\t\t\tvar braceCount = 0;\n\t\t\tvar textCount = 0;\n\t\t\t\n\t\t\tvar utils = require('utils');\n\t\t\tvar parser = require('abbreviationParser');\n\t\t\t\n\t\t\twhile (true) {\n\t\t\t\tcurOffset--;\n\t\t\t\tif (curOffset < 0) {\n\t\t\t\t\t// moved to the beginning of the line\n\t\t\t\t\tstartIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar ch = str.charAt(curOffset);\n\t\t\t\t\n\t\t\t\tif (ch == ']') {\n\t\t\t\t\tbraceCount++;\n\t\t\t\t} else if (ch == '[') {\n\t\t\t\t\tif (!braceCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbraceCount--;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\ttextCount++;\n\t\t\t\t} else if (ch == '{') {\n\t\t\t\t\tif (!textCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttextCount--;\n\t\t\t\t} else if (ch == ')') {\n\t\t\t\t\tgroupCount++;\n\t\t\t\t} else if (ch == '(') {\n\t\t\t\t\tif (!groupCount) { // unexpected brace\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tgroupCount--;\n\t\t\t\t} else {\n\t\t\t\t\tif (braceCount || textCount) \n\t\t\t\t\t\t// respect all characters inside attribute sets or text nodes\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (!parser.isAllowedChar(ch) || (ch == '>' && utils.endsWithTag(str.substring(0, curOffset + 1)))) {\n\t\t\t\t\t\t// found stop symbol\n\t\t\t\t\t\tstartIndex = curOffset + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (startIndex != -1 && !textCount && !braceCount && !groupCount) \n\t\t\t\t// found something, remove some invalid symbols from the \n\t\t\t\t// beginning and return abbreviation\n\t\t\t\treturn str.substring(startIndex).replace(/^[\\*\\+\\>\\^]+/, '');\n\t\t\telse\n\t\t\t\treturn '';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Gets image size from image byte stream.\n\t\t * @author http://romeda.org/rePublish/\n\t\t * @param {String} stream Image byte stream (use <code>IEmmetFile.read()</code>)\n\t\t * @return {Object} Object with <code>width</code> and <code>height</code> properties\n\t\t */\n\t\tgetImageSize: function(stream) {\n\t\t\tvar pngMagicNum = \"211PNG\\r\\n032\\n\",\n\t\t\t\tjpgMagicNum = \"377330\",\n\t\t\t\tgifMagicNum = \"GIF8\",\n\t\t\t\tnextByte = function() {\n\t\t\t\t\treturn stream.charCodeAt(pos++);\n\t\t\t\t};\n\t\t\n\t\t\tif (stream.substr(0, 8) === pngMagicNum) {\n\t\t\t\t// PNG. Easy peasy.\n\t\t\t\tvar pos = stream.indexOf('IHDR') + 4;\n\t\t\t\n\t\t\t\treturn { width:  (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte(),\n\t\t\t\t\t\t height: (nextByte() << 24) | (nextByte() << 16) |\n\t\t\t\t\t\t\t\t (nextByte() <<  8) | nextByte() };\n\t\t\t\n\t\t\t} else if (stream.substr(0, 4) === gifMagicNum) {\n\t\t\t\tpos = 6;\n\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\twidth:  nextByte() | (nextByte() << 8),\n\t\t\t\t\theight: nextByte() | (nextByte() << 8)\n\t\t\t\t};\n\t\t\t\n\t\t\t} else if (stream.substr(0, 2) === jpgMagicNum) {\n\t\t\t\tpos = 2;\n\t\t\t\n\t\t\t\tvar l = stream.length;\n\t\t\t\twhile (pos < l) {\n\t\t\t\t\tif (nextByte() != 0xFF) return;\n\t\t\t\t\n\t\t\t\t\tvar marker = nextByte();\n\t\t\t\t\tif (marker == 0xDA) break;\n\t\t\t\t\n\t\t\t\t\tvar size = (nextByte() << 8) | nextByte();\n\t\t\t\t\n\t\t\t\t\tif (marker >= 0xC0 && marker <= 0xCF && !(marker & 0x4) && !(marker & 0x8)) {\n\t\t\t\t\t\tpos += 1;\n\t\t\t\t\t\treturn { height:  (nextByte() << 8) | nextByte(),\n\t\t\t\t\t\t\t\t width: (nextByte() << 8) | nextByte() };\n\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpos += size - 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Captures context XHTML element from editor under current caret position.\n\t\t * This node can be used as a helper for abbreviation extraction\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Object}\n\t\t */\n\t\tcaptureContext: function(editor) {\n\t\t\tvar allowedSyntaxes = {'html': 1, 'xml': 1, 'xsl': 1};\n\t\t\tvar syntax = String(editor.getSyntax());\n\t\t\tif (syntax in allowedSyntaxes) {\n\t\t\t\tvar content = String(editor.getContent());\n\t\t\t\tvar tag = require('htmlMatcher').find(content, editor.getCaretPos());\n\t\t\t\t\n\t\t\t\tif (tag && tag.type == 'tag') {\n\t\t\t\t\tvar startTag = tag.open;\n\t\t\t\t\tvar contextNode = {\n\t\t\t\t\t\tname: startTag.name,\n\t\t\t\t\t\tattributes: []\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\t// parse attributes\n\t\t\t\t\tvar tagTree = require('xmlEditTree').parse(startTag.range.substring(content));\n\t\t\t\t\tif (tagTree) {\n\t\t\t\t\t\tcontextNode.attributes = _.map(tagTree.getAll(), function(item) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname: item.name(),\n\t\t\t\t\t\t\t\tvalue: item.value()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn contextNode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Find expression bounds in current editor at caret position. \n\t\t * On each character a <code>fn</code> function will be called and must \n\t\t * return <code>true</code> if current character meets requirements, \n\t\t * <code>false</code> otherwise\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Function} fn Function to test each character of expression\n\t\t * @return {Range}\n\t\t */\n\t\tfindExpressionBounds: function(editor, fn) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar il = content.length;\n\t\t\tvar exprStart = editor.getCaretPos() - 1;\n\t\t\tvar exprEnd = exprStart + 1;\n\t\t\t\t\n\t\t\t// start by searching left\n\t\t\twhile (exprStart >= 0 && fn(content.charAt(exprStart), exprStart, content)) exprStart--;\n\t\t\t\n\t\t\t// then search right\n\t\t\twhile (exprEnd < il && fn(content.charAt(exprEnd), exprEnd, content)) exprEnd++;\n\t\t\t\n\t\t\tif (exprEnd > exprStart) {\n\t\t\t\treturn require('range').create([++exprStart, exprEnd]);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * @param {IEmmetEditor} editor\n\t\t * @param {Object} data\n\t\t * @returns {Boolean}\n\t\t */\n\t\tcompoundUpdate: function(editor, data) {\n\t\t\tif (data) {\n\t\t\t\tvar sel = editor.getSelectionRange();\n\t\t\t\teditor.replaceContent(data.data, data.start, data.end, true);\n\t\t\t\teditor.createSelection(data.caret, data.caret + sel.end - sel.start);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common syntax detection method for editors that doesnt provide any\n\t\t * info about current syntax scope. \n\t\t * @param {IEmmetEditor} editor Current editor\n\t\t * @param {String} hint Any syntax hint that editor can provide \n\t\t * for syntax detection. Default is 'html'\n\t\t * @returns {String} \n\t\t */\n\t\tdetectSyntax: function(editor, hint) {\n\t\t\tvar syntax = hint || 'html';\n\t\t\t\n\t\t\tif (!require('resources').hasSyntax(syntax)) {\n\t\t\t\tsyntax = 'html';\n\t\t\t}\n\t\t\t\n\t\t\tif (syntax == 'html' && (this.isStyle(editor) || this.isInlineCSS(editor))) {\n\t\t\t\tsyntax = 'css';\n\t\t\t}\n\t\t\t\n\t\t\treturn syntax;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Common method for detecting output profile\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {String}\n\t\t */\n\t\tdetectProfile: function(editor) {\n\t\t\tvar syntax = editor.getSyntax();\n\t\t\t\n\t\t\t// get profile from syntax definition\n\t\t\tvar profile = require('resources').findItem(syntax, 'profile');\n\t\t\tif (profile) {\n\t\t\t\treturn profile;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(syntax) {\n\t\t\t\tcase 'xml':\n\t\t\t\tcase 'xsl':\n\t\t\t\t\treturn 'xml';\n\t\t\t\tcase 'css':\n\t\t\t\t\tif (this.isInlineCSS(editor)) {\n\t\t\t\t\t\treturn 'line';\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'html':\n\t\t\t\t\tvar profile = require('resources').getVariable('profile');\n\t\t\t\t\tif (!profile) { // no forced profile, guess from content\n\t\t\t\t\t\t// html or xhtml?\n\t\t\t\t\t\tprofile = this.isXHTML(editor) ? 'xhtml': 'html';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn profile;\n\t\t\t}\n\n\t\t\treturn 'xhtml';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Tries to detect if current document is XHTML one.\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisXHTML: function(editor) {\n\t\t\treturn editor.getContent().search(/<!DOCTYPE[^>]+XHTML/i) != -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside &lt;style&gt; tag\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns\n\t\t */\n\t\tisStyle: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(content, caretPos);\n\t\t\treturn tag && tag.open.name.toLowerCase() == 'style' \n\t\t\t\t&& tag.innerRange.cmp(caretPos, 'lte', 'gte');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if current caret position is inside \"style\" attribute of HTML\n\t\t * element\n\t\t * @param {IEmmetEditor} editor\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineCSS: function(editor) {\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tree = require('xmlEditTree').parseFromPosition(content, caretPos, true);\n            if (tree) {\n                var attr = tree.itemFromPosition(caretPos, true);\n                return attr && attr.name().toLowerCase() == 'style' \n                \t&& attr.valueRange(true).cmp(caretPos, 'lte', 'gte');\n            }\n            \n            return false;\n\t\t}\n\t};\n});/**\n * Utility functions to work with <code>AbbreviationNode</code> as HTML element\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('abbreviationUtils', function(require, _) {\n\treturn {\n\t\t/**\n\t\t * Check if passed abbreviation node has matched snippet resource\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t * @memberOf abbreviationUtils\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is unary (no closing tag)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisUnary: function(node) {\n\t\t\tif (node.children.length || node._text || this.isSnippet(node)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tvar r = node.matchedResource();\n\t\t\treturn r && r.is_empty;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is inline-level (like &lt;strong&gt;, &lt;img&gt;)\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisInline: function(node) {\n\t\t\treturn node.isTextNode() \n\t\t\t\t|| !node.name() \n\t\t\t\t|| require('tagName').isInlineLevel(node.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if passed node is block-level\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisBlock: function(node) {\n\t\t\treturn this.isSnippet(node) || !this.isInline(node);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if given node is a snippet\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\tisSnippet: function(node) {\n\t\t\treturn require('elements').is(node.matchedResource(), 'snippet');\n\t\t},\n\t\t\n\t\t/**\n\t\t * This function tests if passed node content contains HTML tags. \n\t\t * This function is mostly used for output formatting\n\t\t * @param {AbbreviationNode} node\n\t\t * @returns {Boolean}\n\t\t */\n\t\thasTagsInContent: function(node) {\n\t\t\treturn require('utils').matchesTag(node.content);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Test if current element contains block-level children\n\t\t * @param {AbbreviationNode} node\n\t\t * @return {Boolean}\n\t\t */\n\t\thasBlockChildren: function(node) {\n\t\t\treturn (this.hasTagsInContent(node) && this.isBlock(node)) \n\t\t\t\t|| _.any(node.children, function(child) {\n\t\t\t\t\treturn this.isBlock(child);\n\t\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Utility function that inserts content instead of <code>${child}</code>\n\t\t * variables on <code>text</code>\n\t\t * @param {String} text Text where child content should be inserted\n\t\t * @param {String} childContent Content to insert\n\t\t * @param {Object} options\n\t\t * @returns {String\n\t\t */\n\t\tinsertChildContent: function(text, childContent, options) {\n\t\t\toptions = _.extend({\n\t\t\t\tkeepVariable: true,\n\t\t\t\tappendIfNoChild: true\n\t\t\t}, options || {});\n\t\t\t\n\t\t\tvar childVariableReplaced = false;\n\t\t\tvar utils = require('utils');\n\t\t\ttext = utils.replaceVariables(text, function(variable, name, data) {\n\t\t\t\tvar output = variable;\n\t\t\t\tif (name == 'child') {\n\t\t\t\t\t// add correct indentation\n\t\t\t\t\toutput = utils.padString(childContent, utils.getLinePaddingFromPosition(text, data.start));\n\t\t\t\t\tchildVariableReplaced = true;\n\t\t\t\t\tif (options.keepVariable)\n\t\t\t\t\t\toutput += variable;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn output;\n\t\t\t});\n\t\t\t\n\t\t\tif (!childVariableReplaced && options.appendIfNoChild) {\n\t\t\t\ttext += childContent;\n\t\t\t}\n\t\t\t\n\t\t\treturn text;\n\t\t}\n\t};\n});/**\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.define('base64', function(require, _) {\n\tvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t\n\treturn {\n\t\t/**\n\t\t * Encodes data using base64 algorithm\n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} input\n\t\t * @returns {String}\n\t\t * @memberOf emmet.base64\n\t\t */\n\t\tencode : function(input) {\n\t\t\tvar output = [];\n\t\t\tvar chr1, chr2, chr3, enc1, enc2, enc3, enc4, cdp1, cdp2, cdp3;\n\t\t\tvar i = 0, il = input.length, b64 = chars;\n\n\t\t\twhile (i < il) {\n\n\t\t\t\tcdp1 = input.charCodeAt(i++);\n\t\t\t\tcdp2 = input.charCodeAt(i++);\n\t\t\t\tcdp3 = input.charCodeAt(i++);\n\n\t\t\t\tchr1 = cdp1 & 0xff;\n\t\t\t\tchr2 = cdp2 & 0xff;\n\t\t\t\tchr3 = cdp3 & 0xff;\n\n\t\t\t\tenc1 = chr1 >> 2;\n\t\t\t\tenc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n\t\t\t\tenc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n\t\t\t\tenc4 = chr3 & 63;\n\n\t\t\t\tif (isNaN(cdp2)) {\n\t\t\t\t\tenc3 = enc4 = 64;\n\t\t\t\t} else if (isNaN(cdp3)) {\n\t\t\t\t\tenc4 = 64;\n\t\t\t\t}\n\n\t\t\t\toutput.push(b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4));\n\t\t\t}\n\n\t\t\treturn output.join('');\n\t\t},\n\n\t\t/**\n\t\t * Decodes string using MIME base64 algorithm\n\t\t * \n\t\t * @author Tyler Akins (http://rumkin.com)\n\t\t * @param {String} data\n\t\t * @return {String}\n\t\t */\n\t\tdecode : function(data) {\n\t\t\tvar o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, tmpArr = [];\n\t\t\tvar b64 = chars, il = data.length;\n\n\t\t\tif (!data) {\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\tdata += '';\n\n\t\t\tdo { // unpack four hexets into three octets using index points in b64\n\t\t\t\th1 = b64.indexOf(data.charAt(i++));\n\t\t\t\th2 = b64.indexOf(data.charAt(i++));\n\t\t\t\th3 = b64.indexOf(data.charAt(i++));\n\t\t\t\th4 = b64.indexOf(data.charAt(i++));\n\n\t\t\t\tbits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n\t\t\t\to1 = bits >> 16 & 0xff;\n\t\t\t\to2 = bits >> 8 & 0xff;\n\t\t\t\to3 = bits & 0xff;\n\n\t\t\t\tif (h3 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1);\n\t\t\t\t} else if (h4 == 64) {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2);\n\t\t\t\t} else {\n\t\t\t\t\ttmpArr[ac++] = String.fromCharCode(o1, o2, o3);\n\t\t\t\t}\n\t\t\t} while (i < il);\n\n\t\t\treturn tmpArr.join('');\n\t\t}\n\t};\n});/**\n * HTML matcher: takes string and searches for HTML tag pairs for given position \n * \n * Unlike classic matchers, it parses content from the specified \n * position, not from the start, so it may work even outside HTML documents\n * (for example, inside strings of programming languages like JavaScript, Python \n * etc.)\n * @constructor\n * @memberOf __htmlMatcherDefine\n */\nemmet.define('htmlMatcher', function(require, _) {\n\t// Regular Expressions for parsing tags and attributes\n\tvar reOpenTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\tvar reCloseTag = /^<\\/([\\w\\:\\-]+)[^>]*>/;\n\t\n\tfunction openTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\tselfClose: !!match[3],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'open'\n\t\t};\n\t}\n\t\n\tfunction closeTag(i, match) {\n\t\treturn {\n\t\t\tname: match[1],\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, match[0]),\n\t\t\ttype: 'close'\n\t\t};\n\t}\n\t\n\tfunction comment(i, match) {\n\t\treturn {\n\t\t\t/** @type Range */\n\t\t\trange: require('range').create(i, _.isNumber(match) ? match - i : match[0]),\n\t\t\ttype: 'comment'\n\t\t};\n\t}\n\t\n\t/**\n\t * Creates new tag matcher session\n\t * @param {String} text\n\t */\n\tfunction createMatcher(text) {\n\t\tvar memo = {}, m;\n\t\treturn {\n\t\t\t/**\n\t\t\t * Test if given position matches opening tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\topen: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'open' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Test if given position matches closing tag\n\t\t\t * @param {Number} i\n\t\t\t * @returns {Object} Matched tag object\n\t\t\t */\n\t\t\tclose: function(i) {\n\t\t\t\tvar m = this.matches(i);\n\t\t\t\treturn m && m.type == 'close' ? m : null;\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Matches either opening or closing tag for given position\n\t\t\t * @param i\n\t\t\t * @returns\n\t\t\t */\n\t\t\tmatches: function(i) {\n\t\t\t\tvar key = 'p' + i;\n\t\t\t\t\n\t\t\t\tif (!(key in memo)) {\n\t\t\t\t\tif (text.charAt(i) == '<') {\n\t\t\t\t\t\tvar substr = text.slice(i);\n\t\t\t\t\t\tif (m = substr.match(reOpenTag)) {\n\t\t\t\t\t\t\tmemo[key] = openTag(i, m);\n\t\t\t\t\t\t} else if (m = substr.match(reCloseTag)) {\n\t\t\t\t\t\t\tmemo[key] = closeTag(i, m);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// remember that given position contains no valid tag\n\t\t\t\t\t\t\tmemo[key] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn memo[key];\n\t\t\t},\n\t\t\t\n\t\t\t/**\n\t\t\t * Returns original text\n\t\t\t * @returns {String}\n\t\t\t */\n\t\t\ttext: function() {\n\t\t\t\treturn text;\n\t\t\t}\n\t\t};\n\t}\n\t\n\tfunction matches(text, pos, pattern) {\n\t\treturn text.substring(pos, pos + pattern.length) == pattern;\n\t}\n\t\n\t/**\n\t * Search for closing pair of opening tag\n\t * @param {Object} open Open tag instance\n\t * @param {Object} matcher Matcher instance\n\t */\n\tfunction findClosingPair(open, matcher) {\n\t\tvar stack = [], tag = null;\n\t\tvar text = matcher.text();\n\t\t\n\t\tfor (var pos = open.range.end, len = text.length; pos < len; pos++) {\n\t\t\tif (matches(text, pos, '<!--')) {\n\t\t\t\t// skip to end of comment\n\t\t\t\tfor (var j = pos; j < len; j++) {\n\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\tpos = j + 3;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (tag = matcher.matches(pos)) {\n\t\t\t\tif (tag.type == 'open' && !tag.selfClose) {\n\t\t\t\t\tstack.push(tag.name);\n\t\t\t\t} else if (tag.type == 'close') {\n\t\t\t\t\tif (!stack.length) { // found valid pair?\n\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// check if current closing tag matches previously opened one\n\t\t\t\t\tif (_.last(stack) == tag.name) {\n\t\t\t\t\t\tstack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\twhile (stack.length && !found) {\n\t\t\t\t\t\t\tvar last = stack.pop();\n\t\t\t\t\t\t\tif (last == tag.name) {\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!stack.length && !found) {\n\t\t\t\t\t\t\treturn tag.name == open.name ? tag : null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Main function: search for tag pair in <code>text</code> for given \n\t\t * position\n\t\t * @memberOf htmlMatcher\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\tfind: function(text, pos) {\n\t\t\tvar range = require('range');\n\t\t\tvar matcher = createMatcher(text); \n\t\t\tvar open = null, close = null;\n\t\t\t\n\t\t\tfor (var i = pos; i >= 0; i--) {\n\t\t\t\tif (open = matcher.open(i)) {\n\t\t\t\t\t// found opening tag\n\t\t\t\t\tif (open.selfClose) {\n\t\t\t\t\t\tif (open.range.cmp(pos, 'lt', 'gt')) {\n\t\t\t\t\t\t\t// inside self-closing tag, found match\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// outside self-closing tag, continue\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tclose = findClosingPair(open, matcher);\n\t\t\t\t\tif (close) {\n\t\t\t\t\t\t// found closing tag.\n\t\t\t\t\t\tvar r = range.create2(open.range.start, close.range.end);\n\t\t\t\t\t\tif (r.contains(pos)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (open.range.contains(pos)) {\n\t\t\t\t\t\t// we inside empty HTML tag like <br>\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = null;\n\t\t\t\t} else if (matches(text, i, '-->')) {\n\t\t\t\t\t// skip back to comment start\n\t\t\t\t\tfor (var j = i - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\t// found another comment end, do nothing\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (matches(text, j, '<!--')) {\n\t\t\t\t\t\t\ti = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (matches(text, i, '<!--')) {\n\t\t\t\t\t// we're inside comment, match it\n\t\t\t\t\tvar j = i + 4, jl = text.length;\n\t\t\t\t\tfor (; j < jl; j++) {\n\t\t\t\t\t\tif (matches(text, j, '-->')) {\n\t\t\t\t\t\t\tj += 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\topen = comment(i, j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (open) {\n\t\t\t\tvar outerRange = null;\n\t\t\t\tvar innerRange = null;\n\t\t\t\t\n\t\t\t\tif (close) {\n\t\t\t\t\touterRange = range.create2(open.range.start, close.range.end);\n\t\t\t\t\tinnerRange = range.create2(open.range.end, close.range.start);\n\t\t\t\t} else {\n\t\t\t\t\touterRange = innerRange = range.create2(open.range.start, open.range.end);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (open.type == 'comment') {\n\t\t\t\t\t// adjust positions of inner range for comment\n\t\t\t\t\tvar _c = outerRange.substring(text);\n\t\t\t\t\tinnerRange.start += _c.length - _c.replace(/^<\\!--\\s*/, '').length;\n\t\t\t\t\tinnerRange.end -= _c.length - _c.replace(/\\s*-->$/, '').length;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\topen: open,\n\t\t\t\t\tclose: close,\n\t\t\t\t\ttype: open.type == 'comment' ? 'comment' : 'tag',\n\t\t\t\t\tinnerRange: innerRange,\n\t\t\t\t\tinnerContent: function() {\n\t\t\t\t\t\treturn this.innerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\touterRange: outerRange,\n\t\t\t\t\touterContent: function() {\n\t\t\t\t\t\treturn this.outerRange.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\trange: !innerRange.length() || !innerRange.cmp(pos, 'lte', 'gte') ? outerRange : innerRange,\n\t\t\t\t\tcontent: function() {\n\t\t\t\t\t\treturn this.range.substring(text);\n\t\t\t\t\t},\n\t\t\t\t\tsource: text\n\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * The same as <code>find()</code> method, but restricts matched result \n\t\t * to <code>tag</code> type\n\t\t * @param {String} text \n\t\t * @param {Number} pos\n\t\t * @returns {Object}\n\t\t */\n\t\ttag: function(text, pos) {\n\t\t\tvar result = this.find(text, pos);\n\t\t\tif (result && result.type == 'tag') {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Utility module for handling tabstops tokens generated by Emmet's \n * \"Expand Abbreviation\" action. The main <code>extract</code> method will take\n * raw text (for example: <i>${0} some ${1:text}</i>), find all tabstops \n * occurrences, replace them with tokens suitable for your editor of choice and \n * return object with processed text and list of found tabstops and their ranges.\n * For sake of portability (Objective-C/Java) the tabstops list is a plain \n * sorted array with plain objects.\n * \n * Placeholders with the same are meant to be <i>linked</i> in your editor.\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('tabStops', function(require, _) {\n\t/**\n\t * Global placeholder value, automatically incremented by \n\t * <code>variablesResolver()</code> function\n\t */\n\tvar startPlaceholderNum = 100;\n\t\n\tvar tabstopIndex = 0;\n\t\n\tvar defaultOptions = {\n\t\treplaceCarets: false,\n\t\tescape: function(ch) {\n\t\t\treturn '\\\\' + ch;\n\t\t},\n\t\ttabstop: function(data) {\n\t\t\treturn data.token;\n\t\t},\n\t\tvariable: function(data) {\n\t\t\treturn data.token;\n\t\t}\n\t};\n\t\n\t// XXX register output processor that will upgrade tabstops of parsed node\n\t// in order to prevent tabstop index conflicts\n\trequire('abbreviationParser').addOutputProcessor(function(text, node, type) {\n\t\tvar maxNum = 0;\n\t\tvar tabstops = require('tabStops');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar tsOptions = {\n\t\t\ttabstop: function(data) {\n\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\tif (group == 0)\n\t\t\t\t\treturn '${0}';\n\t\t\t\t\n\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\tif (data.placeholder) {\n\t\t\t\t\t// respect nested placeholders\n\t\t\t\t\tvar ix = group + tabstopIndex;\n\t\t\t\t\tvar placeholder = tabstops.processText(data.placeholder, tsOptions);\n\t\t\t\t\treturn '${' + ix + ':' + placeholder + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn '${' + (group + tabstopIndex) + '}';\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\t// upgrade tabstops\n\t\ttext = tabstops.processText(text, tsOptions);\n\t\t\n\t\t// resolve variables\n\t\ttext = utils.replaceVariables(text, tabstops.variablesResolver(node));\n\t\t\n\t\ttabstopIndex += maxNum + 1;\n\t\treturn text;\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Main function that looks for a tabstops in provided <code>text</code>\n\t\t * and returns a processed version of <code>text</code> with expanded \n\t\t * placeholders and list of tabstops found.\n\t\t * @param {String} text Text to process\n\t\t * @param {Object} options List of processor options:<br>\n\t\t * \n\t\t * <b>replaceCarets</b> : <code>Boolean</code>  replace all default\n\t\t * caret placeholders (like <i>{%::emmet-caret::%}</i>) with <i>${0:caret}</i><br>\n\t\t * \n\t\t * <b>escape</b> : <code>Function</code>  function that handle escaped\n\t\t * characters (mostly '$'). By default, it returns the character itself \n\t\t * to be displayed as is in output, but sometimes you will use \n\t\t * <code>extract</code> method as intermediate solution for further \n\t\t * processing and want to keep character escaped. Thus, you should override\n\t\t * <code>escape</code> method to return escaped symbol (e.g. '\\\\$')<br>\n\t\t * \n\t\t * <b>tabstop</b> : <code>Function</code>  a tabstop handler. Receives \n\t\t * a single argument  an object describing token: its position, number \n\t\t * group, placeholder and token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * <b>variable</b> : <code>Function</code>  variable handler. Receives \n\t\t * a single argument  an object describing token: its position, name \n\t\t * and original token itself. Should return a replacement \n\t\t * string that will appear in final output\n\t\t * \n\t\t * @returns {Object} Object with processed <code>text</code> property\n\t\t * and array of <code>tabstops</code> found\n\t\t * @memberOf tabStops\n\t\t */\n\t\textract: function(text, options) {\n\t\t\t// prepare defaults\n\t\t\tvar utils = require('utils');\n\t\t\tvar placeholders = {carets: ''};\n\t\t\tvar marks = [];\n\t\t\t\n\t\t\toptions = _.extend({}, defaultOptions, options, {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar token = data.token;\n\t\t\t\t\tvar ret = '';\n\t\t\t\t\tif (data.placeholder == 'cursor') {\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: 'carets',\n\t\t\t\t\t\t\tvalue: ''\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unify placeholder value for single group\n\t\t\t\t\t\tif ('placeholder' in data)\n\t\t\t\t\t\t\tplaceholders[data.group] = data.placeholder;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (data.group in placeholders)\n\t\t\t\t\t\t\tret = placeholders[data.group];\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarks.push({\n\t\t\t\t\t\t\tstart: data.start,\n\t\t\t\t\t\t\tend: data.start + token.length,\n\t\t\t\t\t\t\tgroup: data.group,\n\t\t\t\t\t\t\tvalue: ret\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn token;\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tif (options.replaceCarets) {\n\t\t\t\ttext = text.replace(new RegExp( utils.escapeForRegexp( utils.getCaretPlaceholder() ), 'g'), '${0:cursor}');\n\t\t\t}\n\t\t\t\n\t\t\t// locate tabstops and unify group's placeholders\n\t\t\ttext = this.processText(text, options);\n\t\t\t\n\t\t\t// now, replace all tabstops with placeholders\n\t\t\tvar buf = utils.stringBuilder(), lastIx = 0;\n\t\t\tvar tabStops = _.map(marks, function(mark) {\n\t\t\t\tbuf.append(text.substring(lastIx, mark.start));\n\t\t\t\t\n\t\t\t\tvar pos = buf.length;\n\t\t\t\tvar ph = placeholders[mark.group] || '';\n\t\t\t\t\n\t\t\t\tbuf.append(ph);\n\t\t\t\tlastIx = mark.end;\n\t\t\t\t\n\t\t\t\treturn {\n\t\t\t\t\tgroup: mark.group,\n\t\t\t\t\tstart: pos,\n\t\t\t\t\tend:  pos + ph.length\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\t\t\tbuf.append(text.substring(lastIx));\n\t\t\t\n\t\t\treturn {\n\t\t\t\ttext: buf.toString(),\n\t\t\t\ttabstops: _.sortBy(tabStops, 'start')\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Text processing routine. Locates escaped characters and tabstops and\n\t\t * replaces them with values returned by handlers defined in \n\t\t * <code>options</code>\n\t\t * @param {String} text\n\t\t * @param {Object} options See <code>extract</code> method options \n\t\t * description\n\t\t * @returns {String}\n\t\t */\n\t\tprocessText: function(text, options) {\n\t\t\toptions = _.extend({}, defaultOptions, options);\n\t\t\t\n\t\t\tvar buf = require('utils').stringBuilder();\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(text);\n\t\t\tvar ch, m, a;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '\\\\' && !stream.eol()) {\n\t\t\t\t\t// handle escaped character\n\t\t\t\t\tbuf.append(options.escape(stream.next()));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ta = ch;\n\t\t\t\t\n\t\t\t\tif (ch == '$') {\n\t\t\t\t\t// looks like a tabstop\n\t\t\t\t\tstream.start = stream.pos - 1;\n\t\t\t\t\t\n\t\t\t\t\tif (m = stream.match(/^[0-9]+/)) {\n\t\t\t\t\t\t// it's $N\n\t\t\t\t\t\ta = options.tabstop({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: stream.current().substr(1),\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([a-z_\\-][\\w\\-]*)\\}/)) {\n\t\t\t\t\t\t// ${variable}\n\t\t\t\t\t\ta = options.variable({\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (m = stream.match(/^\\{([0-9]+)(:.+?)?\\}/, false)) {\n\t\t\t\t\t\t// ${N:value} or ${N} placeholder\n\t\t\t\t\t\t// parse placeholder, including nested ones\n\t\t\t\t\t\tstream.skipToPair('{', '}');\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t\tstart: buf.length, \n\t\t\t\t\t\t\tgroup: m[1],\n\t\t\t\t\t\t\ttoken: stream.current()\n\t\t\t\t\t\t};\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar placeholder = obj.token.substring(obj.group.length + 2, obj.token.length - 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (placeholder) {\n\t\t\t\t\t\t\tobj.placeholder = placeholder.substr(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ta = options.tabstop(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbuf.append(a);\n\t\t\t}\n\t\t\t\n\t\t\treturn buf.toString();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Upgrades tabstops in output node in order to prevent naming conflicts\n\t\t * @param {AbbreviationNode} node\n\t\t * @param {Number} offset Tab index offset\n\t\t * @returns {Number} Maximum tabstop index in element\n\t\t */\n\t\tupgrade: function(node, offset) {\n\t\t\tvar maxNum = 0;\n\t\t\tvar options = {\n\t\t\t\ttabstop: function(data) {\n\t\t\t\t\tvar group = parseInt(data.group);\n\t\t\t\t\tif (group > maxNum) maxNum = group;\n\t\t\t\t\t\t\n\t\t\t\t\tif (data.placeholder)\n\t\t\t\t\t\treturn '${' + (group + offset) + ':' + data.placeholder + '}';\n\t\t\t\t\telse\n\t\t\t\t\t\treturn '${' + (group + offset) + '}';\n\t\t\t\t}\n\t\t\t};\n\t\t\t\n\t\t\t_.each(['start', 'end', 'content'], function(p) {\n\t\t\t\tnode[p] = this.processText(node[p], options);\n\t\t\t}, this);\n\t\t\t\n\t\t\treturn maxNum;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Helper function that produces a callback function for \n\t\t * <code>replaceVariables()</code> method from {@link utils}\n\t\t * module. This callback will replace variable definitions (like \n\t\t * ${var_name}) with their value defined in <i>resource</i> module,\n\t\t * or outputs tabstop with variable name otherwise.\n\t\t * @param {AbbreviationNode} node Context node\n\t\t * @returns {Function}\n\t\t */\n\t\tvariablesResolver: function(node) {\n\t\t\tvar placeholderMemo = {};\n\t\t\tvar res = require('resources');\n\t\t\treturn function(str, varName) {\n\t\t\t\t// do not mark `child` variable as placeholder  its a reserved\n\t\t\t\t// variable name\n\t\t\t\tif (varName == 'child')\n\t\t\t\t\treturn str;\n\t\t\t\t\n\t\t\t\tif (varName == 'cursor')\n\t\t\t\t\treturn require('utils').getCaretPlaceholder();\n\t\t\t\t\n\t\t\t\tvar attr = node.attribute(varName);\n\t\t\t\tif (!_.isUndefined(attr) && attr !== str) {\n\t\t\t\t\treturn attr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar varValue = res.getVariable(varName);\n\t\t\t\tif (varValue)\n\t\t\t\t\treturn varValue;\n\t\t\t\t\n\t\t\t\t// output as placeholder\n\t\t\t\tif (!placeholderMemo[varName])\n\t\t\t\t\tplaceholderMemo[varName] = startPlaceholderNum++;\n\t\t\t\t\t\n\t\t\t\treturn '${' + placeholderMemo[varName] + ':' + varName + '}';\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Resets global tabstop index. When parsed tree is converted to output\n\t\t * string (<code>AbbreviationNode.toString()</code>), all tabstops \n\t\t * defined in snippets and elements are upgraded in order to prevent\n\t\t * naming conflicts of nested. For example, <code>${1}</code> of a node\n\t\t * should not be linked with the same placehilder of the child node.\n\t\t * By default, <code>AbbreviationNode.toString()</code> automatically\n\t\t * upgrades tabstops of the same index for each node and writes maximum\n\t\t * tabstop index into the <code>tabstopIndex</code> variable. To keep\n\t\t * this variable at reasonable value, it is recommended to call \n\t\t * <code>resetTabstopIndex()</code> method each time you expand variable \n\t\t * @returns\n\t\t */\n\t\tresetTabstopIndex: function() {\n\t\t\ttabstopIndex = 0;\n\t\t\tstartPlaceholderNum = 100;\n\t\t}\n\t};\n});/**\n * Common module's preferences storage. This module \n * provides general storage for all module preferences, their description and\n * default values.<br><br>\n * \n * This module can also be used to list all available properties to create \n * UI for updating properties\n * \n * @memberOf __preferencesDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('preferences', function(require, _) {\n\tvar preferences = {};\n\tvar defaults = {};\n\tvar _dbgDefaults = null;\n\tvar _dbgPreferences = null;\n\n\tfunction toBoolean(val) {\n\t\tif (_.isString(val)) {\n\t\t\tval = val.toLowerCase();\n\t\t\treturn val == 'yes' || val == 'true' || val == '1';\n\t\t}\n\n\t\treturn !!val;\n\t}\n\t\n\tfunction isValueObj(obj) {\n\t\treturn _.isObject(obj) \n\t\t\t&& 'value' in obj \n\t\t\t&& _.keys(obj).length < 3;\n\t}\n\t\n\treturn {\n\t\t/**\n\t\t * Creates new preference item with default value\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @param {String} description Item textual description\n\t\t * @memberOf preferences\n\t\t */\n\t\tdefine: function(name, value, description) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tdescription: description\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tdefaults[k] = isValueObj(v) ? v : {value: v};\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Updates preference item value. Preference value should be defined\n\t\t * first with <code>define</code> method.\n\t\t * @param {String} name Preference name. You can also pass object\n\t\t * with many options\n\t\t * @param {Object} value Preference default value\n\t\t * @memberOf preferences\n\t\t */\n\t\tset: function(name, value) {\n\t\t\tvar prefs = name;\n\t\t\tif (_.isString(name)) {\n\t\t\t\tprefs = {};\n\t\t\t\tprefs[name] = value;\n\t\t\t}\n\t\t\t\n\t\t\t_.each(prefs, function(v, k) {\n\t\t\t\tif (!(k in defaults)) {\n\t\t\t\t\tthrow 'Property \"' + k + '\" is not defined. You should define it first with `define` method of current module';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// do not set value if it equals to default value\n\t\t\t\tif (v !== defaults[k].value) {\n\t\t\t\t\t// make sure we have value of correct type\n\t\t\t\t\tswitch (typeof defaults[k].value) {\n\t\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\t\tv = toBoolean(v);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'number':\n\t\t\t\t\t\t\tv = parseInt(v + '', 10) || 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: // convert to string\n\t\t\t\t\t\t\tif (v !== null) {\n\t\t\t\t\t\t\t\tv += '';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tpreferences[k] = v;\n\t\t\t\t} else if  (k in preferences) {\n\t\t\t\t\tdelete preferences[k];\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns preference value\n\t\t * @param {String} name\n\t\t * @returns {String} Returns <code>undefined</code> if preference is \n\t\t * not defined\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (name in preferences)\n\t\t\t\treturn preferences[name];\n\t\t\t\n\t\t\tif (name in defaults)\n\t\t\t\treturn defaults[name].value;\n\t\t\t\n\t\t\treturn void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma-separated preference value as array of values\n\t\t * @param {String} name\n\t\t * @returns {Array} Returns <code>undefined</code> if preference is \n\t\t * not defined, <code>null</code> if string cannot be converted to array\n\t\t */\n\t\tgetArray: function(name) {\n\t\t\tvar val = this.get(name);\n\t\t\tif (_.isUndefined(val) || val === null || val === '')  {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tval = _.map(val.split(','), require('utils').trim);\n\t\t\tif (!val.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\treturn val;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns comma and colon-separated preference value as dictionary\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetDict: function(name) {\n\t\t\tvar result = {};\n\t\t\t_.each(this.getArray(name), function(val) {\n\t\t\t\tvar parts = val.split(':');\n\t\t\t\tresult[parts[0]] = parts[1];\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns description of preference item\n\t\t * @param {String} name Preference name\n\t\t * @returns {Object}\n\t\t */\n\t\tdescription: function(name) {\n\t\t\treturn name in defaults ? defaults[name].description : void 0;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Completely removes specified preference(s)\n\t\t * @param {String} name Preference name (or array of names)\n\t\t */\n\t\tremove: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t_.each(name, function(key) {\n\t\t\t\tif (key in preferences)\n\t\t\t\t\tdelete preferences[key];\n\t\t\t\t\n\t\t\t\tif (key in defaults)\n\t\t\t\t\tdelete defaults[key];\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns sorted list of all available properties\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn _.map(_.keys(defaults).sort(), function(key) {\n\t\t\t\treturn {\n\t\t\t\t\tname: key,\n\t\t\t\t\tvalue: this.get(key),\n\t\t\t\t\ttype: typeof defaults[key].value,\n\t\t\t\t\tdescription: defaults[key].description\n\t\t\t\t};\n\t\t\t}, this);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Loads user-defined preferences from JSON\n\t\t * @param {Object} json\n\t\t * @returns\n\t\t */\n\t\tload: function(json) {\n\t\t\t_.each(json, function(value, key) {\n\t\t\t\tthis.set(key, value);\n\t\t\t}, this);\n\t\t},\n\n\t\t/**\n\t\t * Returns hash of user-modified preferences\n\t\t * @returns {Object}\n\t\t */\n\t\texportModified: function() {\n\t\t\treturn _.clone(preferences);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Reset to defaults\n\t\t * @returns\n\t\t */\n\t\treset: function() {\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: use empty storage\n\t\t */\n\t\t_startTest: function() {\n\t\t\t_dbgDefaults = defaults;\n\t\t\t_dbgPreferences = preferences;\n\t\t\tdefaults = {};\n\t\t\tpreferences = {};\n\t\t},\n\t\t\n\t\t/**\n\t\t * For unit testing: restore original storage\n\t\t */\n\t\t_stopTest: function() {\n\t\t\tdefaults = _dbgDefaults;\n\t\t\tpreferences = _dbgPreferences;\n\t\t}\n\t};\n});/**\n * Module for handling filters\n * @param {Function} require\n * @param {Underscore} _\n * @author Sergey Chikuyonok (serge.che@gmail.com) <http://chikuyonok.ru>\n */\nemmet.define('filters', function(require, _) {\n\t/** List of registered filters */\n\tvar registeredFilters = {};\n\t\n\t/** Filters that will be applied for unknown syntax */\n\tvar basicFilters = 'html';\n\t\n\tfunction list(filters) {\n\t\tif (!filters)\n\t\t\treturn [];\n\t\t\n\t\tif (_.isString(filters))\n\t\t\treturn filters.split(/[\\|,]/g);\n\t\t\n\t\treturn filters;\n\t}\n\t\n\treturn  {\n\t\t/**\n\t\t * Register new filter\n\t\t * @param {String} name Filter name\n\t\t * @param {Function} fn Filter function\n\t\t */\n\t\tadd: function(name, fn) {\n\t\t\tregisteredFilters[name] = fn;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Apply filters for final output tree\n\t\t * @param {AbbreviationNode} tree Output tree\n\t\t * @param {Array} filters List of filters to apply. Might be a \n\t\t * <code>String</code>\n\t\t * @param {Object} profile Output profile, defined in <i>profile</i> \n\t\t * module. Filters defined it profile are not used, <code>profile</code>\n\t\t * is passed to filter function\n\t\t * @memberOf emmet.filters\n\t\t * @returns {AbbreviationNode}\n\t\t */\n\t\tapply: function(tree, filters, profile) {\n\t\t\tvar utils = require('utils');\n\t\t\tprofile = require('profile').get(profile);\n\t\t\t\n\t\t\t_.each(list(filters), function(filter) {\n\t\t\t\tvar name = utils.trim(filter.toLowerCase());\n\t\t\t\tif (name && name in registeredFilters) {\n\t\t\t\t\ttree = registeredFilters[name](tree, profile);\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\treturn tree;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Composes list of filters that should be applied to a tree, based on \n\t\t * passed data\n\t\t * @param {String} syntax Syntax name ('html', 'css', etc.)\n\t\t * @param {Object} profile Output profile\n\t\t * @param {String} additionalFilters List or pipe-separated\n\t\t * string of additional filters to apply\n\t\t * @returns {Array}\n\t\t */\n\t\tcomposeList: function(syntax, profile, additionalFilters) {\n\t\t\tprofile = require('profile').get(profile);\n\t\t\tvar filters = list(profile.filters || require('resources').findItem(syntax, 'filters') || basicFilters);\n\t\t\t\n\t\t\tif (profile.extraFilters) {\n\t\t\t\tfilters = filters.concat(list(profile.extraFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (additionalFilters) {\n\t\t\t\tfilters = filters.concat(list(additionalFilters));\n\t\t\t}\n\t\t\t\t\n\t\t\tif (!filters || !filters.length) {\n\t\t\t\t// looks like unknown syntax, apply basic filters\n\t\t\t\tfilters = list(basicFilters);\n\t\t\t}\n\t\t\t\t\n\t\t\treturn filters;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts filter list from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Array} Array with cleaned abbreviation and list of \n\t\t * extracted filters\n\t\t */\n\t\textractFromAbbreviation: function(abbr) {\n\t\t\tvar filters = '';\n\t\t\tabbr = abbr.replace(/\\|([\\w\\|\\-]+)$/, function(str, p1){\n\t\t\t\tfilters = p1;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\treturn [abbr, list(filters)];\n\t\t}\n\t};\n});/**\n * Module that contains factories for element types used by Emmet\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('elements', function(require, _) {\n\tvar factories = {};\n\tvar reAttrs = /([\\w\\-:]+)\\s*=\\s*(['\"])(.*?)\\2/g;\n\t\n\tvar result = {\n\t\t/**\n\t\t * Create new element factory\n\t\t * @param {String} name Element identifier\n\t\t * @param {Function} factory Function that produces element of specified \n\t\t * type. The object generated by this factory is automatically \n\t\t * augmented with <code>type</code> property pointing to element\n\t\t * <code>name</code>\n\t\t * @memberOf elements\n\t\t */\n\t\tadd: function(name, factory) {\n\t\t\tvar that = this;\n\t\t\tfactories[name] = function() {\n\t\t\t\tvar elem = factory.apply(that, arguments);\n\t\t\t\tif (elem)\n\t\t\t\t\telem.type = name;\n\t\t\t\t\n\t\t\t\treturn elem;\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns factory for specified name\n\t\t * @param {String} name\n\t\t * @returns {Function}\n\t\t */\n\t\tget: function(name) {\n\t\t\treturn factories[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Creates new element with specified type\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tcreate: function(name) {\n\t\t\tvar args = [].slice.call(arguments, 1);\n\t\t\tvar factory = this.get(name);\n\t\t\treturn factory ? factory.apply(this, args) : null;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is of specified type\n\t\t * @param {Object} elem\n\t\t * @param {String} type\n\t\t * @returns {Boolean}\n\t\t */\n\t\tis: function(elem, type) {\n\t\t\treturn elem && elem.type === type;\n\t\t}\n\t};\n\t\n\t// register resource references\n\tfunction commonFactory(value) {\n\t\treturn {data: value};\n\t}\n\t\n\t/**\n\t * Element factory\n\t * @param {String} elementName Name of output element\n\t * @param {String} attrs Attributes definition. You may also pass\n\t * <code>Array</code> where each contains object with <code>name</code> \n\t * and <code>value</code> properties, or <code>Object</code>\n\t * @param {Boolean} isEmpty Is expanded element should be empty\n\t */\n\tresult.add('element', function(elementName, attrs, isEmpty) {\n\t\tvar ret = {\n\t\t\t/** @memberOf __emmetDataElement */\n\t\t\tname: elementName,\n\t\t\tis_empty: !!isEmpty\n\t\t};\n\t\t\n\t\tif (attrs) {\n\t\t\tret.attributes = [];\n\t\t\tif (_.isArray(attrs)) {\n\t\t\t\tret.attributes = attrs;\n\t\t\t} else if (_.isString(attrs)) {\n\t\t\t\tvar m;\n\t\t\t\twhile (m = reAttrs.exec(attrs)) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: m[1],\n\t\t\t\t\t\tvalue: m[3]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_.each(attrs, function(value, name) {\n\t\t\t\t\tret.attributes.push({\n\t\t\t\t\t\tname: name, \n\t\t\t\t\t\tvalue: value\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t});\n\t\n\tresult.add('snippet', commonFactory);\n\tresult.add('reference', commonFactory);\n\tresult.add('empty', function() {\n\t\treturn {};\n\t});\n\t\n\treturn result;\n});/**\n * Abstract implementation of edit tree interface.\n * Edit tree is a named container of editable name-value child elements, \n * parsed from <code>source</code>. This container provides convenient methods\n * for editing/adding/removing child elements. All these update actions are\n * instantly reflected in the <code>source</code> code with respect of formatting.\n * <br><br>\n * For example, developer can create an edit tree from CSS rule and add or \n * remove properties from itall changes will be immediately reflected in the \n * original source.\n * <br><br>\n * All classes defined in this module should be extended the same way as in\n * Backbone framework: using <code>extend</code> method to create new class and \n * <code>initialize</code> method to define custom class constructor.\n * \n * @example\n * <pre><code>\n * var MyClass = require('editTree').EditElement.extend({\n * \tinitialize: function() {\n * \t\t// constructor code here\n * \t}\n * });\n * \n * var elem = new MyClass(); \n * </code></pre>\n * \n * \n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __editTreeDefine\n */\nemmet.define('editTree', function(require, _, core) {\n\tvar range = require('range').create;\n\t\n\t/**\n\t * Named container of edited source\n\t * @type EditContainer\n\t * @param {String} source\n\t * @param {Object} options\n\t */\n\tfunction EditContainer(source, options) {\n\t\tthis.options = _.extend({offset: 0}, options);\n\t\t/**\n\t\t * Source code of edited structure. All changes in the structure are \n\t\t * immediately reflected into this property\n\t\t */\n\t\tthis.source = source;\n\t\t\n\t\t/** \n\t\t * List of all editable children\n\t\t * @private \n\t\t */\n\t\tthis._children = [];\n\t\t\n\t\t/**\n\t\t * Hash of all positions of container\n\t\t * @private\n\t\t */\n\t\tthis._positions = {\n\t\t\tname: 0\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditContainer.extend = core.extend;\n\t\n\tEditContainer.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Replace substring of tag's source\n\t\t * @param {String} value\n\t\t * @param {Number} start\n\t\t * @param {Number} end\n\t\t * @private\n\t\t */\n\t\t_updateSource: function(value, start, end) {\n\t\t\t// create modification range\n\t\t\tvar r = range(start, _.isUndefined(end) ? 0 : end - start);\n\t\t\tvar delta = value.length - r.length();\n\t\t\t\n\t\t\tvar update = function(obj) {\n\t\t\t\t_.each(obj, function(v, k) {\n\t\t\t\t\tif (v >= r.end)\n\t\t\t\t\t\tobj[k] += delta;\n\t\t\t\t});\n\t\t\t};\n\t\t\t\n\t\t\t// update affected positions of current container\n\t\t\tupdate(this._positions);\n\t\t\t\n\t\t\t// update affected positions of children\n\t\t\t_.each(this.list(), function(item) {\n\t\t\t\tupdate(item._positions);\n\t\t\t});\n\t\t\t\n\t\t\tthis.source = require('utils').replaceSubstring(this.source, value, r);\n\t\t},\n\t\t\t\n\t\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {EditElement} Newly created element\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\t// this is abstract implementation\n\t\t\tvar item = new EditElement(name, value);\n\t\t\tthis._children.push(item);\n\t\t\treturn item;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns attribute object\n\t\t * @param {String} name Attribute name or its index\n\t\t * @returns {EditElement}\n\t\t */\n\t\tget: function(name) {\n\t\t\tif (_.isNumber(name))\n\t\t\t\treturn this.list()[name];\n\t\t\t\n\t\t\tif (_.isString(name))\n\t\t\t\treturn _.find(this.list(), function(prop) {\n\t\t\t\t\treturn prop.name() === name;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all children by name or indexes\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tgetAll: function(name) {\n\t\t\tif (!_.isArray(name))\n\t\t\t\tname = [name];\n\t\t\t\n\t\t\t// split names and indexes\n\t\t\tvar names = [], indexes = [];\n\t\t\t_.each(name, function(item) {\n\t\t\t\tif (_.isString(item))\n\t\t\t\t\tnames.push(item);\n\t\t\t\telse if (_.isNumber(item))\n\t\t\t\t\tindexes.push(item);\n\t\t\t});\n\t\t\t\n\t\t\treturn _.filter(this.list(), function(attribute, i) {\n\t\t\t\treturn _.include(indexes, i) || _.include(names, attribute.name());\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns or updates element value. If such element doesn't exists,\n\t\t * it will be created automatically and added at the end of child list.\n\t\t * @param {String} name Element name or its index\n\t\t * @param {String} value New element value\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(name, value, pos) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element)\n\t\t\t\treturn element.value(value);\n\t\t\t\n\t\t\tif (!_.isUndefined(value)) {\n\t\t\t\t// no such element  create it\n\t\t\t\treturn this.add(name, value, pos);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns all values of child elements found by <code>getAll()</code>\n\t\t * method\n\t\t * @param {Object} name Element name(s) or indexes (<code>String</code>,\n\t\t * <code>Array</code>, <code>Number</code>)\n\t\t * @returns {Array}\n\t\t */\n\t\tvalues: function(name) {\n\t\t\treturn _.map(this.getAll(name), function(element) {\n\t\t\t\treturn element.value();\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remove child element\n\t\t * @param {String} name Property name or its index\n\t\t */\n\t\tremove: function(name) {\n\t\t\tvar element = this.get(name);\n\t\t\tif (element) {\n\t\t\t\tthis._updateSource('', element.fullRange());\n\t\t\t\tthis._children = _.without(this._children, element);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all editable child elements\n\t\t * @returns {Array}\n\t\t */\n\t\tlist: function() {\n\t\t\treturn this._children;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns index of editble child in list\n\t\t * @param {Object} item\n\t\t * @returns {Number}\n\t\t */\n\t\tindexOf: function(item) {\n\t\t\treturn _.indexOf(this.list(), this.get(item));\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets or gets container name\n\t\t * @param {String} val New name. If not passed, current \n\t\t * name is returned\n\t\t * @return {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis._updateSource(val, this._positions.name, this._positions.name + this._name.length);\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns name range object\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of \n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this._positions.name + (isAbsolute ? this.options.offset : 0), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns range of current source\n\t\t * @param {Boolean} isAbsolute\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(isAbsolute ? this.options.offset : 0, this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element that belongs to specified position\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {EditElement}\n\t\t */\n\t\titemFromPosition: function(pos, isAbsolute) {\n\t\t\treturn _.find(this.list(), function(elem) {\n\t\t\t\treturn elem.range(isAbsolute).inside(pos);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns source code of current container \n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.source;\n\t\t}\n\t};\n\t\n\t/**\n\t * @param {EditContainer} parent\n\t * @param {Object} nameToken\n\t * @param {Object} valueToken\n\t */\n\tfunction EditElement(parent, nameToken, valueToken) {\n\t\t/** @type EditContainer */\n\t\tthis.parent = parent;\n\t\t\n\t\tthis._name = nameToken.value;\n\t\tthis._value = valueToken ? valueToken.value : '';\n\t\t\n\t\tthis._positions = {\n\t\t\tname: nameToken.start,\n\t\t\tvalue: valueToken ? valueToken.start : -1\n\t\t};\n\t\t\n\t\tthis.initialize.apply(this, arguments);\n\t}\n\t\n\t/**\n\t * The self-propagating extend function for classes.\n\t * @type Function\n\t */\n\tEditElement.extend = core.extend;\n\t\n\tEditElement.prototype = {\n\t\t/**\n\t\t * Child class constructor\n\t\t */\n\t\tinitialize: function() {},\n\t\t\n\t\t/**\n\t\t * Make position absolute\n\t\t * @private\n\t\t * @param {Number} num\n\t\t * @param {Boolean} isAbsolute\n\t\t * @returns {Boolean}\n\t\t */\n\t\t_pos: function(num, isAbsolute) {\n\t\t\treturn num + (isAbsolute ? this.parent.options.offset : 0);\n\t\t},\n\t\t\t\n\t\t/**\n\t\t * Sets of gets element value\n\t\t * @param {String} val New element value. If not passed, current \n\t\t * value is returned\n\t\t * @returns {String}\n\t\t */\n\t\tvalue: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._value !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.valueRange());\n\t\t\t\tthis._value = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._value;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets element name\n\t\t * @param {String} val New element name. If not passed, current \n\t\t * name is returned\n\t\t * @returns {String}\n\t\t */\n\t\tname: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._name !== (val = String(val))) {\n\t\t\t\tthis.parent._updateSource(val, this.nameRange());\n\t\t\t\tthis._name = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element name token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tnamePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.name, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns position of element value token\n\t\t * @param {Boolean} isAbsolute Return absolute position\n\t\t * @returns {Number}\n\t\t */\n\t\tvaluePosition: function(isAbsolute) {\n\t\t\treturn this._pos(this._positions.value, isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name\n\t\t * @param {Boolean} isAbsolute Return absolute range \n\t\t * @returns {Range}\n\t\t */\n\t\trange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.toString());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full element range, including possible indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\treturn this.range(isAbsolute);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element name range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tnameRange: function(isAbsolute) {\n\t\t\treturn range(this.namePosition(isAbsolute), this.name());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns element value range\n\t\t * @param {Boolean} isAbsolute Return absolute range\n\t\t * @returns {Range}\n\t\t */\n\t\tvalueRange: function(isAbsolute) {\n\t\t\treturn range(this.valuePosition(isAbsolute), this.value());\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns current element string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.value();\n\t\t},\n\t\t\n\t\tvalueOf: function() {\n\t\t\treturn this.toString();\n\t\t}\n\t};\n\t\n\treturn {\n\t\tEditContainer: EditContainer,\n\t\tEditElement: EditElement,\n\t\t\n\t\t/**\n\t\t * Creates token that can be fed to <code>EditElement</code>\n\t\t * @param {Number} start\n\t\t * @param {String} value\n\t\t * @param {String} type\n\t\t * @returns\n\t\t */\n\t\tcreateToken: function(start, value, type) {\n\t\t\tvar obj = {\n\t\t\t\tstart: start || 0,\n\t\t\t\tvalue: value || '',\n\t\t\t\ttype: type\n\t\t\t};\n\t\t\t\n\t\t\tobj.end = obj.start + obj.value.length;\n\t\t\treturn obj;\n\t\t}\n\t};\n});/**\n * CSS EditTree is a module that can parse a CSS rule into a tree with \n * convenient methods for adding, modifying and removing CSS properties. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __cssEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('cssEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: '\\n\\t',\n\t\tstyleSeparator: ': ',\n\t\toffset: 0\n\t};\n\t\n\tvar WHITESPACE_REMOVE_FROM_START = 1;\n\tvar WHITESPACE_REMOVE_FROM_END   = 2;\n\t\n\t/**\n\t * Returns range object\n\t * @param {Number} start\n\t * @param {Number} len \n\t * @returns {Range}\n\t */\n\tfunction range(start, len) {\n\t\treturn require('range').create(start, len);\n\t}\n\t\n\t/**\n\t * Removes whitespace tokens from the array ends\n\t * @param {Array} tokens\n\t * @param {Number} mask Mask indicating from which end whitespace should be \n\t * removed \n\t * @returns {Array}\n\t */\n\tfunction trimWhitespaceTokens(tokens, mask) {\n\t\tmask = mask || (WHITESPACE_REMOVE_FROM_START | WHITESPACE_REMOVE_FROM_END);\n\t\tvar whitespace = ['white', 'line'];\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_END) == WHITESPACE_REMOVE_FROM_END)\n\t\t\twhile (tokens.length && _.include(whitespace, _.last(tokens).type)) {\n\t\t\t\ttokens.pop();\n\t \t\t}\n\t\t\n\t\tif ((mask & WHITESPACE_REMOVE_FROM_START) == WHITESPACE_REMOVE_FROM_START)\n\t\t\twhile (tokens.length && _.include(whitespace, tokens[0].type)) {\n\t\t\t\ttokens.shift();\n\t\t\t}\n\t\t\n\t\treturn tokens;\n\t}\n\t\n\t/**\n\t * Helper function that searches for selector range for <code>CSSEditRule</code>\n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findSelectorRange(it) {\n\t\tvar tokens = [], token;\n \t\tvar start = it.position(), end;\n \t\t\n \t\twhile (token = it.next()) {\n\t\t\tif (token.type == '{')\n\t\t\t\tbreak;\n\t\t\ttokens.push(token);\n\t\t}\n \t\t\n \t\ttrimWhitespaceTokens(tokens);\n \t\t\n \t\tif (tokens.length) {\n \t\t\tstart = tokens[0].start;\n \t\t\tend = _.last(tokens).end;\n \t\t} else {\n \t\t\tend = start;\n \t\t}\n \t\t\n \t\treturn range(start, end - start);\n\t}\n\t\n\t/**\n\t * Helper function that searches for CSS property value range next to\n\t * iterator's current position  \n\t * @param {TokenIterator} it\n\t * @returns {Range}\n\t */\n\tfunction findValueRange(it) {\n\t\t// find value start position\n\t\tvar skipTokens = ['white', 'line', ':'];\n\t\tvar tokens = [], token, start, end;\n\t\t\n\t\tit.nextUntil(function(tok) {\n\t\t\treturn !_.include(skipTokens, this.itemNext().type);\n\t\t});\n\t\t\n\t\tstart = it.current().end;\n\t\t// consume value\n\t\twhile (token = it.next()) {\n\t\t\tif (token.type == '}' || token.type == ';') {\n\t\t\t\t// found value end\n\t\t\t\ttrimWhitespaceTokens(tokens, WHITESPACE_REMOVE_FROM_START \n\t\t\t\t\t\t| (token.type == '}' ? WHITESPACE_REMOVE_FROM_END : 0));\n\t\t\t\t\n\t\t\t\tif (tokens.length) {\n\t\t\t\t\tstart = tokens[0].start;\n\t\t\t\t\tend = _.last(tokens).end;\n\t\t\t\t} else {\n\t\t\t\t\tend = start;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn range(start, end - start);\n\t\t\t}\n\t\t\t\n\t\t\ttokens.push(token);\n\t\t}\n\t\t\n\t\t// reached the end of tokens list\n\t\tif (tokens.length) {\n\t\t\treturn range(tokens[0].start, _.last(tokens).end - tokens[0].start);\n\t\t}\n\t}\n\t\n\t/**\n\t * Finds parts of complex CSS value\n\t * @param {String} str\n\t * @returns {Array} Returns list of <code>Range</code>'s\n\t */\n\tfunction findParts(str) {\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(str);\n\t\tvar ch;\n\t\tvar result = [];\n\t\tvar sep = /[\\s\\u00a0,]/;\n\t\t\n\t\tvar add = function() {\n\t\t\tstream.next();\n\t\t\tresult.push(range(stream.start, stream.current()));\n\t\t\tstream.start = stream.pos;\n\t\t};\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\twhile (ch = stream.next()) {\n\t\t\tif (ch == '\"' || ch == \"'\") {\n\t\t\t\tstream.next();\n\t\t\t\tif (!stream.skipTo(ch)) break;\n\t\t\t\tadd();\n\t\t\t} else if (ch == '(') {\n\t\t\t\t// function found, may have nested function\n\t\t\t\tstream.backUp(1);\n\t\t\t\tif (!stream.skipToPair('(', ')')) break;\n\t\t\t\tstream.backUp(1);\n\t\t\t\tadd();\n\t\t\t} else {\n\t\t\t\tif (sep.test(ch)) {\n\t\t\t\t\tresult.push(range(stream.start, stream.current().length - 1));\n\t\t\t\t\tstream.eatWhile(sep);\n\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tadd();\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * A bit hacky way to identify invalid CSS property definition: when user\n\t * starts writing new abbreviation in CSS rule, he actually creates invalid\n\t * CSS property definition and this method tries to identify such abbreviation\n\t * and prevent it from being added to CSS edit tree \n\t * @param {TokenIterator} it\n\t */\n\tfunction isValidIdentifier(it) {\n//\t\treturn true;\n\t\tvar tokens = it.tokens;\n\t\tfor (var i = it._i + 1, il = tokens.length; i < il; i++) {\n\t\t\tif (tokens[i].type == ':')\n\t\t\t\treturn true;\n\t\t\t\n\t\t\tif (tokens[i].type == 'identifier' || tokens[i].type == 'line')\n\t\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * @class\n\t * @extends EditContainer\n\t */\n\tvar CSSEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\t/** @type TokenIterator */\n\t \t\tvar it = require('tokenIterator').create(\n\t \t\t\t\trequire('cssParser').parse(source));\n\t \t\t\n\t \t\tvar selectorRange = findSelectorRange(it);\n\t \t\tthis._positions.name = selectorRange.start;\n\t \t\tthis._name = selectorRange.substring(source);\n\t \t\t\n\t \t\tif (!it.current() || it.current().type != '{')\n\t \t\t\tthrow 'Invalid CSS rule';\n\t \t\t\n\t \t\tthis._positions.contentStart = it.position() + 1;\n\t \t\t\n\t \t\t// consume properties\n\t \t\tvar propertyRange, valueRange, token;\n\t\t\twhile (token = it.next()) {\n\t\t\t\tif (token.type == 'identifier' && isValidIdentifier(it)) {\n\t\t\t\t\tpropertyRange = range(token);\n\t\t\t\t\tvalueRange = findValueRange(it);\n\t\t\t\t\tvar end = (it.current() && it.current().type == ';') \n\t\t\t\t\t\t? range(it.current())\n\t\t\t\t\t\t: range(valueRange.end, 0);\n\t\t\t\t\tthis._children.push(new CSSEditElement(this,\n\t\t\t\t\t\t\teditTree.createToken(propertyRange.start, propertyRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(valueRange.start, valueRange.substring(source)),\n\t\t\t\t\t\t\teditTree.createToken(end.start, end.substring(source))\n\t\t\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar source = this.source;\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {CSSEditProperty} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t// a small hack here:\n\t\t\t\t// Sometimes users add empty lines before properties to logically\n\t\t\t\t// separate groups of properties. In this case, a blind copy of\n\t\t\t\t// characters between rules may lead to undesired behavior,\n\t\t\t\t// especially when current rule is duplicated or used as a donor\n\t\t\t\t// to create new rule.\n\t\t\t\t// To solve this issue, well take only last newline indentation\n\t\t\t\tvar lines = utils.splitByLines(p.styleBefore);\n\t\t\t\tif (lines.length > 1) {\n\t\t\t\t\tp.styleBefore = '\\n' + _.last(lines);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tp.styleSeparator = source.substring(p.nameRange().end, p.valuePosition());\n\t\t\t\t\n\t\t\t\t// graceful and naive comments removal \n\t\t\t\tp.styleBefore = _.last(p.styleBefore.split('*/'));\n\t\t\t\tp.styleSeparator = p.styleSeparator.replace(/\\/\\*.*?\\*\\//g, '');\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new CSS property \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t * @returns {CSSEditProperty}\n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this._positions.contentStart;\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator');\n\t\t\tvar editTree = require('editTree');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t/** @type CSSEditProperty */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\t// make sure that donor has terminating semicolon\n\t\t\t\tdonor.end(';');\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator');\n\t\t\t}\n\t\t\t\n\t\t\tvar nameToken = editTree.createToken(start + styles.styleBefore.length, name);\n\t\t\tvar valueToken = editTree.createToken(nameToken.end + styles.styleSeparator.length, value);\n\t\t\t\n\t\t\tvar property = new CSSEditElement(this, nameToken, valueToken,\n\t\t\t\t\teditTree.createToken(valueToken.end, ';'));\n\t\t\t\n\t\t\t_.extend(property, styles);\n\t\t\t\n\t\t\t// write new property into the source\n\t\t\tthis._updateSource(property.styleBefore + property.toString(), start);\n\t\t\t\n\t\t\t// insert new property\n\t\t\tthis._children.splice(pos, 0, property);\n\t\t\treturn property;\n\t\t}\n\t});\n\t\n\t/**\n\t * @class\n\t * @type CSSEditElement\n\t * @constructor\n\t */\n\tvar CSSEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(rule, name, value, end) {\n\t\t\tthis.styleBefore = rule.options.styleBefore;\n\t\t\tthis.styleSeparator = rule.options.styleSeparator;\n\t\t\t\n\t\t\tthis._end = end.value;\n\t\t\tthis._positions.end = end.start;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns ranges of complex value parts\n\t\t * @returns {Array} Returns <code>null</code> if value is not complex\n\t\t */\n\t\tvalueParts: function(isAbsolute) {\n\t\t\tvar parts = findParts(this.value());\n\t\t\tif (isAbsolute) {\n\t\t\t\tvar offset = this.valuePosition(true);\n\t\t\t\t_.each(parts, function(p) {\n\t\t\t\t\tp.shift(offset);\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn parts;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Sets of gets property end value (basically, it's a semicolon)\n\t\t * @param {String} val New end value. If not passed, current \n\t\t * value is returned\n\t\t */\n\t\tend: function(val) {\n\t\t\tif (!_.isUndefined(val) && this._end !== val) {\n\t\t\t\tthis.parent._updateSource(val, this._positions.end, this._positions.end + this._end.length);\n\t\t\t\tthis._end = val;\n\t\t\t}\n\t\t\t\n\t\t\treturn this._end;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns item string representation\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator + this.value() + this.end();\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses CSS rule into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.cssEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new CSSEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse CSS rule from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractRule(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching CSS rule or caret outside rule bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts single CSS selector definition from source code\n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {Range}\n\t\t */\n\t\textractRule: function(content, pos, isBackward) {\n\t\t\tvar result = '';\n\t\t\tvar len = content.length;\n\t\t\tvar offset = pos;\n\t\t\tvar stopChars = '{}/\\\\<>\\n\\r';\n\t\t\tvar bracePos = -1, ch;\n\t\t\t\n\t\t\t// search left until we find rule edge\n\t\t\twhile (offset >= 0) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (ch == '}' && !isBackward) {\n\t\t\t\t\toffset++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset--;\n\t\t\t}\n\t\t\t\n\t\t\t// search right for full rule set\n\t\t\twhile (offset < len) {\n\t\t\t\tch = content.charAt(offset);\n\t\t\t\tif (ch == '{') {\n\t\t\t\t\tbracePos = offset;\n\t\t\t\t} else if (ch == '}') {\n\t\t\t\t\tif (bracePos != -1)\n\t\t\t\t\t\tresult = content.substring(bracePos, offset + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\toffset++;\n\t\t\t}\n\t\t\t\n\t\t\tif (result) {\n\t\t\t\t// find CSS selector\n\t\t\t\toffset = bracePos - 1;\n\t\t\t\tvar selector = '';\n\t\t\t\twhile (offset >= 0) {\n\t\t\t\t\tch = content.charAt(offset);\n\t\t\t\t\tif (stopChars.indexOf(ch) != -1) break;\n\t\t\t\t\toffset--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// also trim whitespace\n\t\t\t\tselector = content.substring(offset + 1, bracePos).replace(/^[\\s\\n\\r]+/m, '');\n\t\t\t\treturn require('range').create(bracePos - selector.length, result.length + selector.length);\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t},\n\t\t\n\t\t/**\n\t \t * Removes vendor prefix from CSS property\n\t \t * @param {String} name CSS property\n\t \t * @return {String}\n\t \t */\n\t \tbaseName: function(name) {\n\t \t\treturn name.replace(/^\\s*\\-\\w+\\-/, '');\n\t \t},\n\t \t\n\t \t/**\n\t \t * Finds parts of complex CSS value\n\t \t * @param {String} str\n\t \t * @returns {Array}\n\t \t */\n\t \tfindParts: findParts\n\t};\n});/**\n * XML EditTree is a module that can parse an XML/HTML element into a tree with \n * convenient methods for adding, modifying and removing attributes. These \n * changes can be written back to string with respect of code formatting.\n * \n * @memberOf __xmlEditTreeDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.define('xmlEditTree', function(require, _) {\n\tvar defaultOptions = {\n\t\tstyleBefore: ' ',\n\t\tstyleSeparator: '=',\n\t\tstyleQuote: '\"',\n\t\toffset: 0\n\t};\n\t\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/m;\n\t\n\tvar XMLEditContainer = require('editTree').EditContainer.extend({\n\t\tinitialize: function(source, options) {\n\t\t\t_.defaults(this.options, defaultOptions);\n\t\t\tthis._positions.name = 1;\n\t\t\t\n\t\t\tvar attrToken = null;\n\t\t\tvar tokens = require('xmlParser').parse(source);\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t_.each(tokens, function(token) {\n\t\t\t\ttoken.value = range.create(token).substring(source);\n\t\t\t\tswitch (token.type) {\n\t\t\t\t\tcase 'tag':\n\t\t\t\t\t\tif (/^<[^\\/]+/.test(token.value)) {\n\t\t\t\t\t\t\tthis._name = token.value.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'attribute':\n\t\t\t\t\t\t// add empty attribute\n\t\t\t\t\t\tif (attrToken) {\n\t\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tattrToken = token;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken, token));\n\t\t\t\t\t\tattrToken = null;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}, this);\n\t\t\t\n\t\t\tif (attrToken) {\n\t\t\t\tthis._children.push(new XMLEditElement(this, attrToken));\n\t\t\t}\n\t\t\t\n\t\t\tthis._saveStyle();\n\t\t},\n\t\t\n\t\t/**\n\t\t * Remembers all styles of properties\n\t\t * @private\n\t\t */\n\t\t_saveStyle: function() {\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar source = this.source;\n\t\t\t\n\t\t\t_.each(this.list(), /** @param {EditElement} p */ function(p) {\n\t\t\t\tp.styleBefore = source.substring(start, p.namePosition());\n\t\t\t\t\n\t\t\t\tif (p.valuePosition() !== -1) {\n\t\t\t\t\tp.styleSeparator = source.substring(p.namePosition() + p.name().length, p.valuePosition() - p.styleQuote.length);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstart = p.range().end;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new attribute \n\t\t * @param {String} name Property name\n\t\t * @param {String} value Property value\n\t\t * @param {Number} pos Position at which to insert new property. By \n\t\t * default the property is inserted at the end of rule \n\t\t */\n\t\tadd: function(name, value, pos) {\n\t\t\tvar list = this.list();\n\t\t\tvar start = this.nameRange().end;\n\t\t\tvar editTree = require('editTree');\n\t\t\tvar styles = _.pick(this.options, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t\n\t\t\tif (_.isUndefined(pos))\n\t\t\t\tpos = list.length;\n\t\t\t\n\t\t\t\n\t\t\t/** @type XMLEditAttribute */\n\t\t\tvar donor = list[pos];\n\t\t\tif (donor) {\n\t\t\t\tstart = donor.fullRange().start;\n\t\t\t} else if (donor = list[pos - 1]) {\n\t\t\t\tstart = donor.range().end;\n\t\t\t}\n\t\t\t\n\t\t\tif (donor) {\n\t\t\t\tstyles = _.pick(donor, 'styleBefore', 'styleSeparator', 'styleQuote');\n\t\t\t}\n\t\t\t\n\t\t\tvalue = styles.styleQuote + value + styles.styleQuote;\n\t\t\t\n\t\t\tvar attribute = new XMLEditElement(this, \n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length, name),\n\t\t\t\t\teditTree.createToken(start + styles.styleBefore.length + name.length \n\t\t\t\t\t\t\t+ styles.styleSeparator.length, value)\n\t\t\t\t\t);\n\t\t\t\n\t\t\t_.extend(attribute, styles);\n\t\t\t\n\t\t\t// write new attribute into the source\n\t\t\tthis._updateSource(attribute.styleBefore + attribute.toString(), start);\n\t\t\t\n\t\t\t// insert new attribute\n\t\t\tthis._children.splice(pos, 0, attribute);\n\t\t\treturn attribute;\n\t\t}\n\t});\n\t\n\tvar XMLEditElement = require('editTree').EditElement.extend({\n\t\tinitialize: function(parent, nameToken, valueToken) {\n\t\t\tthis.styleBefore = parent.options.styleBefore;\n\t\t\tthis.styleSeparator = parent.options.styleSeparator;\n\t\t\t\n\t\t\tvar value = '', quote = parent.options.styleQuote;\n\t\t\tif (valueToken) {\n\t\t\t\tvalue = valueToken.value;\n\t\t\t\tquote = value.charAt(0);\n\t\t\t\tif (quote == '\"' || quote == \"'\") {\n\t\t\t\t\tvalue = value.substring(1);\n\t\t\t\t} else {\n\t\t\t\t\tquote = '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (quote && value.charAt(value.length - 1) == quote) {\n\t\t\t\t\tvalue = value.substring(0, value.length - 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthis.styleQuote = quote;\n\t\t\t\n\t\t\tthis._value = value;\n\t\t\tthis._positions.value = valueToken ? valueToken.start + quote.length : -1;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns full rule range, with indentation\n\t\t * @param {Boolean} isAbsolute Return absolute range (with respect of\n\t\t * rule offset)\n\t\t * @returns {Range}\n\t\t */\n\t\tfullRange: function(isAbsolute) {\n\t\t\tvar r = this.range(isAbsolute);\n\t\t\tr.start -= this.styleBefore.length;\n\t\t\treturn r;\n\t\t},\n\t\t\n\t\ttoString: function() {\n\t\t\treturn this.name() + this.styleSeparator\n\t\t\t\t+ this.styleQuote + this.value() + this.styleQuote;\n\t\t}\n\t});\n\t\n\treturn {\n\t\t/**\n\t\t * Parses HTML element into editable tree\n\t\t * @param {String} source\n\t\t * @param {Object} options\n\t\t * @memberOf emmet.htmlEditTree\n\t\t * @returns {EditContainer}\n\t\t */\n\t\tparse: function(source, options) {\n\t\t\treturn new XMLEditContainer(source, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract and parse HTML from specified position in <code>content</code> \n\t\t * @param {String} content CSS source code\n\t\t * @param {Number} pos Character position where to start source code extraction\n\t\t * @returns {XMLEditElement}\n\t\t */\n\t\tparseFromPosition: function(content, pos, isBackward) {\n\t\t\tvar bounds = this.extractTag(content, pos, isBackward);\n\t\t\tif (!bounds || !bounds.inside(pos))\n\t\t\t\t// no matching HTML tag or caret outside tag bounds\n\t\t\t\treturn null;\n\t\t\t\n\t\t\treturn this.parse(bounds.substring(content), {\n\t\t\t\toffset: bounds.start\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts nearest HTML tag range from <code>content</code>, starting at \n\t\t * <code>pos</code> position\n\t\t * @param {String} content\n\t\t * @param {Number} pos\n\t\t * @param {Boolean} isBackward\n\t\t * @returns {Range}\n\t\t */\n\t\textractTag: function(content, pos, isBackward) {\n\t\t\tvar len = content.length, i;\n\t\t\tvar range = require('range');\n\t\t\t\n\t\t\t// max extraction length. I don't think there may be tags larger \n\t\t\t// than 2000 characters length\n\t\t\tvar maxLen = Math.min(2000, len);\n\t\t\t\n\t\t\t/** @type Range */\n\t\t\tvar r = null;\n\t\t\t\n\t\t\tvar match = function(pos) {\n\t\t\t\tvar m;\n\t\t\t\tif (content.charAt(pos) == '<' && (m = content.substr(pos, maxLen).match(startTag)))\n\t\t\t\t\treturn range.create(pos, m[0]);\n\t\t\t};\n\t\t\t\n\t\t\t// lookup backward, in case we are inside tag already\n\t\t\tfor (i = pos; i >= 0; i--) {\n\t\t\t\tif (r = match(i)) break;\n\t\t\t}\n\t\t\t\n\t\t\tif (r && (r.inside(pos) || isBackward))\n\t\t\t\treturn r;\n\t\t\t\n\t\t\tif (!r && isBackward)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\t// search forward\n\t\t\tfor (i = pos; i < len; i++) {\n\t\t\t\tif (r = match(i))\n\t\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t};\n});/**\n * 'Expand abbreviation' editor action: extracts abbreviation from current caret \n * position and replaces it with formatted output. \n * <br><br>\n * This behavior can be overridden with custom handlers which can perform \n * different actions when 'Expand Abbreviation' action is called.\n * For example, a CSS gradient handler that produces vendor-prefixed gradient\n * definitions registers its own expand abbreviation handler.  \n *  \n * @constructor\n * @memberOf __expandAbbreviationActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('expandAbbreviation', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar actions = require('actions');\n\t/**\n\t * 'Expand abbreviation' editor action \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\tactions.add('expand_abbreviation', function(editor, syntax, profile) {\n\t\tvar args = _.toArray(arguments);\n\t\t\n\t\t// normalize incoming arguments\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\targs[1] = info.syntax;\n\t\targs[2] = info.profile;\n\t\t\n\t\treturn handlers.exec(false, args);\n\t});\n\t\n\t/**\n\t * A special version of <code>expandAbbreviation</code> function: if it can't\n\t * find abbreviation, it will place Tab character at caret position\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\tactions.add('expand_abbreviation_with_tab', function(editor, syntax, profile) {\n\t\tvar sel = editor.getSelection();\n\t\tvar indent = require('resources').getVariable('indentation');\n\t\tif (sel) {\n\t\t\t// indent selection\n\t\t\tvar utils = require('utils');\n\t\t\tvar selRange = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = utils.padString(sel, indent);\n\t\t\t\n\t\t\teditor.replaceContent(indent + '${0}', editor.getCaretPos());\n\t\t\tvar replaceRange = require('range').create(editor.getCaretPos(), selRange.length());\n\t\t\teditor.replaceContent(content, replaceRange.start, replaceRange.end, true);\n\t\t\teditor.createSelection(replaceRange.start, replaceRange.start + content.length);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tif (!actions.run('expand_abbreviation', editor, syntax, profile)) {\n\t\t\teditor.replaceContent(indent, editor.getCaretPos());\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n\t\n\t// XXX setup default handler\n\t/**\n\t * Extracts abbreviation from current caret \n\t * position and replaces it with formatted output \n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t * @return {Boolean} Returns <code>true</code> if abbreviation was expanded \n\t * successfully\n\t */\n\thandlers.add(function(editor, syntax, profile) {\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = module.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile, \n\t\t\t\t\trequire('actionUtils').captureContext(editor));\n\t\t\tif (content) {\n\t\t\t\teditor.replaceContent(content, caretPos - abbr.length, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {order: -1});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds custom expand abbreviation handler. The passed function should \n\t\t * return <code>true</code> if it was performed successfully, \n\t\t * <code>false</code> otherwise.\n\t\t * \n\t\t * Added handlers will be called when 'Expand Abbreviation' is called\n\t\t * in order they were added\n\t\t * @memberOf expandAbbreviation\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for abbreviation in editor from current caret position\n\t\t * @param {IEmmetEditor} editor Editor instance\n\t\t * @return {String}\n\t\t */\n\t\tfindAbbreviation: function(editor) {\n\t\t\t/** @type Range */\n\t\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\tvar content = String(editor.getContent());\n\t\t\tif (range.length()) {\n\t\t\t\t// abbreviation is selected by user\n\t\t\t\treturn range.substring(content);\n\t\t\t}\n\t\t\t\n\t\t\t// search for new abbreviation from current caret position\n\t\t\tvar curLine = editor.getCurrentLineRange();\n\t\t\treturn require('actionUtils').extractAbbreviation(content.substring(curLine.start, range.start));\n\t\t}\n\t};\n});/**\n * Action that wraps content with abbreviation. For convenience, action is \n * defined as reusable module\n * @constructor\n * @memberOf __wrapWithAbbreviationDefine\n */\nemmet.define('wrapWithAbbreviation', function(require, _) {\n\t/** Back-references to current module */\n\tvar module = null;\n\t\n\t/**\n\t * Wraps content with abbreviation\n\t * @param {IEmmetEditor} Editor instance\n\t * @param {String} abbr Abbreviation to wrap with\n\t * @param {String} syntax Syntax type (html, css, etc.)\n\t * @param {String} profile Output profile name (html, xml, xhtml)\n\t */\n\trequire('actions').add('wrap_with_abbreviation', function (editor, abbr, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.editorUtils */\n\t\tvar editorUtils = require('editorUtils');\n\t\tabbr = abbr || editor.prompt(\"Enter abbreviation\");\n\t\t\n\t\tif (!abbr) \n\t\t\treturn null;\n\t\t\n\t\tabbr = String(abbr);\n\t\t\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find tag pair\n\t\t\tvar match = require('htmlMatcher').tag(info.content, range.start);\n\t\t\tif (!match) {  // nothing to wrap\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\trange = utils.narrowToNonSpace(info.content, match.range);\n\t\t}\n\t\t\n\t\tvar newContent = utils.escapeText(range.substring(info.content));\n\t\tvar result = module\n\t\t\t.wrap(abbr, editorUtils.unindent(editor, newContent), info.syntax, \n\t\t\t\t\tinfo.profile, require('actionUtils').captureContext(editor));\n\t\t\n\t\tif (result) {\n\t\t\teditor.replaceContent(result, range.start, range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Wraps passed text with abbreviation. Text will be placed inside last\n\t\t * expanded element\n\t\t * @memberOf wrapWithAbbreviation\n\t\t * @param {String} abbr Abbreviation\n\t\t * @param {String} text Text to wrap\n\t\t * @param {String} syntax Document type (html, xml, etc.). Default is 'html'\n\t\t * @param {String} profile Output profile's name. Default is 'plain'\n\t\t * @param {Object} contextNode Context node inside which abbreviation\n\t\t * is wrapped. It will be used as a reference for node name resolvers\n\t\t * @return {String}\n\t\t */\n\t\twrap: function(abbr, text, syntax, profile, contextNode) {\n\t\t\t/** @type emmet.filters */\n\t\t\tvar filters = require('filters');\n\t\t\t/** @type emmet.utils */\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tsyntax = syntax || emmet.defaultSyntax();\n\t\t\tprofile = require('profile').get(profile, syntax);\n\t\t\t\n\t\t\trequire('tabStops').resetTabstopIndex();\n\t\t\t\n\t\t\tvar data = filters.extractFromAbbreviation(abbr);\n\t\t\tvar parsedTree = require('abbreviationParser').parse(data[0], {\n\t\t\t\tsyntax: syntax,\n\t\t\t\tpastedContent: text,\n\t\t\t\tcontextNode: contextNode\n\t\t\t});\n\t\t\tif (parsedTree) {\n\t\t\t\tvar filtersList = filters.composeList(syntax, profile, data[1]);\n\t\t\t\tfilters.apply(parsedTree, filtersList, profile);\n\t\t\t\treturn utils.replaceVariables(parsedTree.toString());\n\t\t\t}\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t};\n});/**\n * Toggles HTML and CSS comments depending on current caret context. Unlike\n * the same action in most editors, this action toggles comment on currently\n * matched itemHTML tag or CSS selectorwhen nothing is selected.\n * \n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __toggleCommentAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Toggle HTML comment on current selection or tag\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleHTMLComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, find matching tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\t\tif (tag) { // found pair\n\t\t\t\trange = tag.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '<!--', '-->', range);\n\t}\n\n\t/**\n\t * Simple CSS commenting\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if comment was toggled\n\t */\n\tfunction toggleCSSComment(editor) {\n\t\t/** @type Range */\n\t\tvar range = require('range').create(editor.getSelectionRange());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\t\n\t\tif (!range.length()) {\n\t\t\t// no selection, try to get current rule\n\t\t\t/** @type CSSRule */\n\t\t\tvar rule = require('cssEditTree').parseFromPosition(info.content, editor.getCaretPos());\n\t\t\tif (rule) {\n\t\t\t\tvar property = cssItemFromPosition(rule, editor.getCaretPos());\n\t\t\t\trange = property \n\t\t\t\t\t? property.range(true) \n\t\t\t\t\t: require('range').create(rule.nameRange(true).start, rule.source);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!range.length()) {\n\t\t\t// still no selection, get current line\n\t\t\trange = require('range').create(editor.getCurrentLineRange());\n\t\t\trequire('utils').narrowToNonSpace(info.content, range);\n\t\t}\n\t\t\n\t\treturn genericCommentToggle(editor, '/*', '*/', range);\n\t}\n\t\n\t/**\n\t * Returns CSS property from <code>rule</code> that matches passed position\n\t * @param {EditContainer} rule\n\t * @param {Number} absPos\n\t * @returns {EditElement}\n\t */\n\tfunction cssItemFromPosition(rule, absPos) {\n\t\t// do not use default EditContainer.itemFromPosition() here, because\n\t\t// we need to make a few assumptions to make CSS commenting more reliable\n\t\tvar relPos = absPos - (rule.options.offset || 0);\n\t\tvar reSafeChar = /^[\\s\\n\\r]/;\n\t\treturn _.find(rule.list(), function(item) {\n\t\t\tif (item.range().end === relPos) {\n\t\t\t\t// at the end of property, but outside of it\n\t\t\t\t// if theres a space character at current position,\n\t\t\t\t// use current property\n\t\t\t\treturn reSafeChar.test(rule.source.charAt(relPos));\n\t\t\t}\n\t\t\t\n\t\t\treturn item.range().inside(relPos);\n\t\t});\n\t}\n\n\t/**\n\t * Search for nearest comment in <code>str</code>, starting from index <code>from</code>\n\t * @param {String} text Where to search\n\t * @param {Number} from Search start index\n\t * @param {String} start_token Comment start string\n\t * @param {String} end_token Comment end string\n\t * @return {Range} Returns null if comment wasn't found\n\t */\n\tfunction searchComment(text, from, startToken, endToken) {\n\t\tvar commentStart = -1;\n\t\tvar commentEnd = -1;\n\t\t\n\t\tvar hasMatch = function(str, start) {\n\t\t\treturn text.substr(start, str.length) == str;\n\t\t};\n\t\t\t\n\t\t// search for comment start\n\t\twhile (from--) {\n\t\t\tif (hasMatch(startToken, from)) {\n\t\t\t\tcommentStart = from;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (commentStart != -1) {\n\t\t\t// search for comment end\n\t\t\tfrom = commentStart;\n\t\t\tvar contentLen = text.length;\n\t\t\twhile (contentLen >= from++) {\n\t\t\t\tif (hasMatch(endToken, from)) {\n\t\t\t\t\tcommentEnd = from + endToken.length;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (commentStart != -1 && commentEnd != -1) \n\t\t\t? require('range').create(commentStart, commentEnd - commentStart) \n\t\t\t: null;\n\t}\n\n\t/**\n\t * Generic comment toggling routine\n\t * @param {IEmmetEditor} editor\n\t * @param {String} commentStart Comment start token\n\t * @param {String} commentEnd Comment end token\n\t * @param {Range} range Selection range\n\t * @return {Boolean}\n\t */\n\tfunction genericCommentToggle(editor, commentStart, commentEnd, range) {\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar content = editorUtils.outputInfo(editor).content;\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar newContent = null;\n\t\t\n\t\tvar utils = require('utils');\n\t\t\t\n\t\t/**\n\t\t * Remove comment markers from string\n\t\t * @param {Sting} str\n\t\t * @return {String}\n\t\t */\n\t\tfunction removeComment(str) {\n\t\t\treturn str\n\t\t\t\t.replace(new RegExp('^' + utils.escapeForRegexp(commentStart) + '\\\\s*'), function(str){\n\t\t\t\t\tcaretPos -= str.length;\n\t\t\t\t\treturn '';\n\t\t\t\t}).replace(new RegExp('\\\\s*' + utils.escapeForRegexp(commentEnd) + '$'), '');\n\t\t}\n\t\t\n\t\t// first, we need to make sure that this substring is not inside \n\t\t// comment\n\t\tvar commentRange = searchComment(content, caretPos, commentStart, commentEnd);\n\t\tif (commentRange && commentRange.overlap(range)) {\n\t\t\t// we're inside comment, remove it\n\t\t\trange = commentRange;\n\t\t\tnewContent = removeComment(range.substring(content));\n\t\t} else {\n\t\t\t// should add comment\n\t\t\t// make sure that there's no comment inside selection\n\t\t\tnewContent = commentStart + ' ' +\n\t\t\t\trange.substring(content)\n\t\t\t\t\t.replace(new RegExp(utils.escapeForRegexp(commentStart) + '\\\\s*|\\\\s*' + utils.escapeForRegexp(commentEnd), 'g'), '') +\n\t\t\t\t' ' + commentEnd;\n\t\t\t\t\n\t\t\t// adjust caret position\n\t\t\tcaretPos += commentStart.length + 1;\n\t\t}\n\n\t\t// replace editor content\n\t\tif (newContent !== null) {\n\t\t\tnewContent = utils.escapeText(newContent);\n\t\t\teditor.setCaretPos(range.start);\n\t\t\teditor.replaceContent(editorUtils.unindent(editor, newContent), range.start, range.end);\n\t\t\teditor.setCaretPos(caretPos);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Toggle comment on current editor's selection or HTML tag/CSS rule\n\t * @param {IEmmetEditor} editor\n\t */\n\trequire('actions').add('toggle_comment', function(editor) {\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tif (info.syntax == 'css') {\n\t\t\t// in case our editor is good enough and can recognize syntax from \n\t\t\t// current token, we have to make sure that cursor is not inside\n\t\t\t// 'style' attribute of html element\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && tag.open.range.inside(caretPos)) {\n\t\t\t\tinfo.syntax = 'html';\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (info.syntax == 'css')\n\t\t\treturn toggleCSSComment(editor);\n\t\t\n\t\treturn toggleHTMLComment(editor);\n\t});\n});/**\n * Move between next/prev edit points. 'Edit points' are places between tags \n * and quotes of empty attributes in html\n * @constructor\n * \n * @memberOf __editPointActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Search for new caret insertion point\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {Number} inc Search increment: -1  search left, 1  search right\n\t * @param {Number} offset Initial offset relative to current caret position\n\t * @return {Number} Returns -1 if insertion point wasn't found\n\t */\n\tfunction findNewEditPoint(editor, inc, offset) {\n\t\tinc = inc || 1;\n\t\toffset = offset || 0;\n\t\t\n\t\tvar curPoint = editor.getCaretPos() + offset;\n\t\tvar content = String(editor.getContent());\n\t\tvar maxLen = content.length;\n\t\tvar nextPoint = -1;\n\t\tvar reEmptyLine = /^\\s+$/;\n\t\t\n\t\tfunction getLine(ix) {\n\t\t\tvar start = ix;\n\t\t\twhile (start >= 0) {\n\t\t\t\tvar c = content.charAt(start);\n\t\t\t\tif (c == '\\n' || c == '\\r')\n\t\t\t\t\tbreak;\n\t\t\t\tstart--;\n\t\t\t}\n\t\t\t\n\t\t\treturn content.substring(start, ix);\n\t\t}\n\t\t\t\n\t\twhile (curPoint <= maxLen && curPoint >= 0) {\n\t\t\tcurPoint += inc;\n\t\t\tvar curChar = content.charAt(curPoint);\n\t\t\tvar nextChar = content.charAt(curPoint + 1);\n\t\t\tvar prevChar = content.charAt(curPoint - 1);\n\t\t\t\t\n\t\t\tswitch (curChar) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\'':\n\t\t\t\t\tif (nextChar == curChar && prevChar == '=') {\n\t\t\t\t\t\t// empty attribute\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '>':\n\t\t\t\t\tif (nextChar == '<') {\n\t\t\t\t\t\t// between tags\n\t\t\t\t\t\tnextPoint = curPoint + 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\\n':\n\t\t\t\tcase '\\r':\n\t\t\t\t\t// empty line\n\t\t\t\t\tif (reEmptyLine.test(getLine(curPoint - 1))) {\n\t\t\t\t\t\tnextPoint = curPoint;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPoint != -1)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn nextPoint;\n\t}\n\t\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\t\n\t/**\n\t * Move caret to previous edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('prev_edit_point', function(editor) {\n\t\tvar curPos = editor.getCaretPos();\n\t\tvar newPoint = findNewEditPoint(editor, -1);\n\t\t\t\n\t\tif (newPoint == curPos)\n\t\t\t// we're still in the same point, try searching from the other place\n\t\t\tnewPoint = findNewEditPoint(editor, -1, -2);\n\t\t\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Previous Edit Point'});\n\t\n\t/**\n\t * Move caret to next edit point\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('next_edit_point', function(editor) {\n\t\tvar newPoint = findNewEditPoint(editor, 1);\n\t\tif (newPoint != -1) {\n\t\t\teditor.setCaretPos(newPoint);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Actions that use stream parsers and tokenizers for traversing:\n * -- Search for next/previous items in HTML\n * -- Search for next/previous items in CSS\n * @constructor\n * @memberOf __selectItemActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar startTag = /^<([\\w\\:\\-]+)((?:\\s+[\\w\\-:]+(?:\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|[^>\\s]+))?)*)\\s*(\\/?)>/;\n\t\n\t/**\n\t * Generic function for searching for items to select\n\t * @param {IEmmetEditor} editor\n\t * @param {Boolean} isBackward Search backward (search forward otherwise)\n\t * @param {Function} extractFn Function that extracts item content\n\t * @param {Function} rangeFn Function that search for next token range\n\t */\n\tfunction findItem(editor, isBackward, extractFn, rangeFn) {\n\t\tvar range = require('range');\n\t\tvar content = require('editorUtils').outputInfo(editor).content;\n\t\t\n\t\tvar contentLength = content.length;\n\t\tvar itemRange, rng;\n\t\t/** @type Range */\n\t\tvar prevRange = range.create(-1, 0);\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\t\n\t\tvar searchPos = sel.start, loop = 100000; // endless loop protection\n\t\twhile (searchPos >= 0 && searchPos < contentLength && --loop > 0) {\n\t\t\tif ( (itemRange = extractFn(content, searchPos, isBackward)) ) {\n\t\t\t\tif (prevRange.equal(itemRange)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprevRange = itemRange.clone();\n\t\t\t\trng = rangeFn(itemRange.substring(content), itemRange.start, sel.clone());\n\t\t\t\t\n\t\t\t\tif (rng) {\n\t\t\t\t\teditor.createSelection(rng.start, rng.end);\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tsearchPos = isBackward ? itemRange.start : itemRange.end - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tsearchPos += isBackward ? -1 : 1;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t// XXX HTML section\n\t\n\t/**\n\t * Find next HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findNextHTMLItem(editor) {\n\t\tvar isFirst = true;\n\t\treturn findItem(editor, false, function(content, searchPos){\n\t\t\tif (isFirst) {\n\t\t\t\tisFirst = false;\n\t\t\t\treturn findOpeningTagFromPosition(content, searchPos);\n\t\t\t} else {\n\t\t\t\treturn getOpeningTagFromPosition(content, searchPos);\n\t\t\t}\n\t\t}, function(tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, false);\n\t\t});\n\t}\n\t\n\t/**\n\t * Find previous HTML item\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction findPrevHTMLItem(editor) {\n\t\treturn findItem(editor, true, getOpeningTagFromPosition, function (tag, offset, selRange) {\n\t\t\treturn getRangeForHTMLItem(tag, offset, selRange, true);\n\t\t});\n\t}\n\t\n\t/**\n\t * Creates possible selection ranges for HTML tag\n\t * @param {String} source Original HTML source for tokens\n\t * @param {Array} tokens List of HTML tokens\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesHTML(source, tokens, offset) {\n\t\toffset = offset || 0;\n\t\tvar range = require('range');\n\t\tvar result = [];\n\t\tvar attrStart = -1, attrName = '', attrValue = '', attrValueRange, tagName;\n\t\t_.each(tokens, function(tok) {\n\t\t\tswitch (tok.type) {\n\t\t\t\tcase 'tag':\n\t\t\t\t\ttagName = source.substring(tok.start, tok.end);\n\t\t\t\t\tif (/^<[\\w\\:\\-]/.test(tagName)) {\n\t\t\t\t\t\t// add tag name\n\t\t\t\t\t\tresult.push(range.create({\n\t\t\t\t\t\t\tstart: tok.start + 1, \n\t\t\t\t\t\t\tend: tok.end\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'attribute':\n\t\t\t\t\tattrStart = tok.start;\n\t\t\t\t\tattrName = source.substring(tok.start, tok.end);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'string':\n\t\t\t\t\t// attribute value\n\t\t\t\t\t// push full attribute first\n\t\t\t\t\t result.push(range.create(attrStart, tok.end - attrStart));\n\t\t\t\t\t \n\t\t\t\t\t attrValueRange = range.create(tok);\n\t\t\t\t\t attrValue = attrValueRange.substring(source);\n\t\t\t\t\t \n\t\t\t\t\t // is this a quoted attribute?\n\t\t\t\t\t if (isQuote(attrValue.charAt(0)))\n\t\t\t\t\t\t attrValueRange.start++;\n\t\t\t\t\t \n\t\t\t\t\t if (isQuote(attrValue.charAt(attrValue.length - 1)))\n\t\t\t\t\t\t attrValueRange.end--;\n\t\t\t\t\t \n\t\t\t\t\t result.push(attrValueRange);\n\t\t\t\t\t \n\t\t\t\t\t if (attrName == 'class') {\n\t\t\t\t\t\t result = result.concat(classNameRanges(attrValueRange.substring(source), attrValueRange.start));\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// offset ranges\n\t\t_.each(result, function(r) {\n\t\t\tr.shift(offset);\n\t\t});\n\t\t\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {        // remove empty\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {   // remove duplicates\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Returns ranges of class names in \"class\" attribute value\n\t * @param {String} className\n\t * @returns {Array}\n\t */\n\tfunction classNameRanges(className, offset) {\n\t\toffset = offset || 0;\n\t\tvar result = [];\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(className);\n\t\tvar range = require('range');\n\t\t\n\t\t// skip whitespace\n\t\tstream.eatSpace();\n\t\tstream.start = stream.pos;\n\t\t\n\t\tvar ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (/[\\s\\u00a0]/.test(ch)) {\n\t\t\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start - 1));\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t}\n\t\t\n\t\tresult.push(range.create(stream.start + offset, stream.pos - stream.start));\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Returns best HTML tag range match for current selection\n\t * @param {String} tag Tag declaration\n\t * @param {Number} offset Tag's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForHTMLItem(tag, offset, selRange, isBackward) {\n\t\tvar ranges = makePossibleRangesHTML(tag, require('xmlParser').parse(tag), offset);\n\t\t\n\t\tif (isBackward)\n\t\t\tranges.reverse();\n\t\t\n\t\t// try to find selected range\n\t\tvar curRange = _.find(ranges, function(r) {\n\t\t\treturn r.equal(selRange);\n\t\t});\n\t\t\n\t\tif (curRange) {\n\t\t\tvar ix = _.indexOf(ranges, curRange);\n\t\t\tif (ix < ranges.length - 1)\n\t\t\t\treturn ranges[ix + 1];\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t// no selected range, find nearest one\n\t\tif (isBackward)\n\t\t\t// search backward\n\t\t\treturn _.find(ranges, function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t});\n\t\t\n\t\t// search forward\n\t\t// to deal with overlapping ranges (like full attribute definition\n\t\t// and attribute value) let's find range under caret first\n\t\tif (!curRange) {\n\t\t\tvar matchedRanges = _.filter(ranges, function(r) {\n\t\t\t\treturn r.inside(selRange.end);\n\t\t\t});\n\t\t\t\n\t\t\tif (matchedRanges.length > 1)\n\t\t\t\treturn matchedRanges[1];\n\t\t}\n\t\t\n\t\t\n\t\treturn _.find(ranges, function(r) {\n\t\t\treturn r.end > selRange.end;\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for opening tag in content, starting at specified position\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction findOpeningTagFromPosition(html, pos) {\n\t\tvar tag;\n\t\twhile (pos >= 0) {\n\t\t\tif (tag = getOpeningTagFromPosition(html, pos))\n\t\t\t\treturn tag;\n\t\t\tpos--;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * @param {String} html Where to search tag\n\t * @param {Number} pos Character index where to start searching\n\t * @return {Range} Returns range if valid opening tag was found,\n\t * <code>null</code> otherwise\n\t */\n\tfunction getOpeningTagFromPosition(html, pos) {\n\t\tvar m;\n\t\tif (html.charAt(pos) == '<' && (m = html.substring(pos, html.length).match(startTag))) {\n\t\t\treturn require('range').create(pos, m[0]);\n\t\t}\n\t}\n\t\n\tfunction isQuote(ch) {\n\t\treturn ch == '\"' || ch == \"'\";\n\t}\n\t\n\t/**\n\t * Makes all possible selection ranges for specified CSS property\n\t * @param {CSSProperty} property\n\t * @returns {Array}\n\t */\n\tfunction makePossibleRangesCSS(property) {\n\t\t// find all possible ranges, sorted by position and size\n\t\tvar valueRange = property.valueRange(true);\n\t\tvar result = [property.range(true), valueRange];\n\t\tvar stringStream = require('stringStream');\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar range = require('range');\n\t\t\n\t\t// locate parts of complex values.\n\t\t// some examples:\n\t\t//  1px solid red: 3 parts\n\t\t//  arial, sans-serif: enumeration, 2 parts\n\t\t//  url(image.png): function value part\n\t\tvar value = property.value();\n\t\t_.each(property.valueParts(), function(r) {\n\t\t\t// add absolute range\n\t\t\tvar clone = r.clone();\n\t\t\tresult.push(clone.shift(valueRange.start));\n\t\t\t\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = stringStream.create(r.substring(value));\n\t\t\tif (stream.match(/^[\\w\\-]+\\(/, true)) {\n\t\t\t\t// we have a function, find values in it.\n\t\t\t\t// but first add function contents\n\t\t\t\tstream.start = stream.pos;\n\t\t\t\tstream.skipToPair('(', ')');\n\t\t\t\tvar fnBody = stream.current();\n\t\t\t\tresult.push(range.create(clone.start + stream.start, fnBody));\n\t\t\t\t\n\t\t\t\t// find parts\n\t\t\t\t_.each(cssEditTree.findParts(fnBody), function(part) {\n\t\t\t\t\tresult.push(range.create(clone.start + stream.start + part.start, part.substring(fnBody)));\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\t\n\t\t// optimize result: remove empty ranges and duplicates\n\t\treturn _.chain(result)\n\t\t\t.filter(function(item) {\n\t\t\t\treturn !!item.length();\n\t\t\t})\n\t\t\t.uniq(false, function(item) {\n\t\t\t\treturn item.toString();\n\t\t\t})\n\t\t\t.value();\n\t}\n\t\n\t/**\n\t * Tries to find matched CSS property and nearest range for selection\n\t * @param {CSSRule} rule\n\t * @param {Range} selRange\n\t * @param {Boolean} isBackward\n\t * @returns {Range}\n\t */\n\tfunction matchedRangeForCSSProperty(rule, selRange, isBackward) {\n\t\t/** @type CSSProperty */\n\t\tvar property = null;\n\t\tvar possibleRanges, curRange = null, ix;\n\t\tvar list = rule.list();\n\t\tvar searchFn, nearestItemFn;\n\t\t\n\t\tif (isBackward) {\n\t\t\tlist.reverse();\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).start <= selRange.start;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.start < selRange.start;\n\t\t\t};\n\t\t} else {\n\t\t\tsearchFn = function(p) {\n\t\t\t\treturn p.range(true).end >= selRange.end;\n\t\t\t};\n\t\t\tnearestItemFn = function(r) {\n\t\t\t\treturn r.end > selRange.start;\n\t\t\t};\n\t\t}\n\t\t\n\t\t// search for nearest to selection CSS property\n\t\twhile (property = _.find(list, searchFn)) {\n\t\t\tpossibleRanges = makePossibleRangesCSS(property);\n\t\t\tif (isBackward)\n\t\t\t\tpossibleRanges.reverse();\n\t\t\t\n\t\t\t// check if any possible range is already selected\n\t\t\tcurRange = _.find(possibleRanges, function(r) {\n\t\t\t\treturn r.equal(selRange);\n\t\t\t});\n\t\t\t\n\t\t\tif (!curRange) {\n\t\t\t\t// no selection, select nearest item\n\t\t\t\tvar matchedRanges = _.filter(possibleRanges, function(r) {\n\t\t\t\t\treturn r.inside(selRange.end);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (matchedRanges.length > 1) {\n\t\t\t\t\tcurRange = matchedRanges[1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (curRange = _.find(possibleRanges, nearestItemFn))\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tix = _.indexOf(possibleRanges, curRange);\n\t\t\t\tif (ix != possibleRanges.length - 1) {\n\t\t\t\t\tcurRange = possibleRanges[ix + 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tcurRange = null;\n\t\t\tselRange.start = selRange.end = isBackward \n\t\t\t\t? property.range(true).start - 1\n\t\t\t\t: property.range(true).end + 1;\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\tfunction findNextCSSItem(editor) {\n\t\treturn findItem(editor, false, require('cssEditTree').extractRule, getRangeForNextItemInCSS);\n\t}\n\t\n\tfunction findPrevCSSItem(editor) {\n\t\treturn findItem(editor, true, require('cssEditTree').extractRule, getRangeForPrevItemInCSS);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS after current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if next item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForNextItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\t// check if selector is matched\n\t\tvar range = tree.nameRange(true);\n\t\tif (selRange.end < range.end) {\n\t\t\treturn range;\n\t\t}\n\t\t\n\t\treturn matchedRangeForCSSProperty(tree, selRange, false);\n\t}\n\t\n\t/**\n\t * Returns range for item to be selected in CSS before current caret \n\t * (selection) position\n\t * @param {String} rule CSS rule declaration\n\t * @param {Number} offset Rule's position index inside content\n\t * @param {Range} selRange Selection range\n\t * @return {Range} Returns range if previous item was found, <code>null</code> otherwise\n\t */\n\tfunction getRangeForPrevItemInCSS(rule, offset, selRange) {\n\t\tvar tree = require('cssEditTree').parse(rule, {\n\t\t\toffset: offset\n\t\t});\n\t\t\n\t\tvar curRange = matchedRangeForCSSProperty(tree, selRange, true);\n\t\t\n\t\tif (!curRange) {\n\t\t\t// no matched property, try to match selector\n\t\t\tvar range = tree.nameRange(true);\n\t\t\tif (selRange.start > range.start) {\n\t\t\t\treturn range;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn curRange;\n\t}\n\t\n\t// XXX register actions\n\tvar actions = require('actions');\n\tactions.add('select_next_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findNextCSSItem(editor);\n\t\telse\n\t\t\treturn findNextHTMLItem(editor);\n\t});\n\t\n\tactions.add('select_previous_item', function(editor){\n\t\tif (editor.getSyntax() == 'css')\n\t\t\treturn findPrevCSSItem(editor);\n\t\telse\n\t\t\treturn findPrevHTMLItem(editor);\n\t});\n});/**\n * HTML pair matching (balancing) actions\n * @constructor\n * @memberOf __matchPairActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type emmet.actions */\n\tvar actions = require('actions');\n\tvar matcher = require('htmlMatcher');\n\tvar lastMatch = null;\n\t\n\t/**\n\t * Find and select HTML tag pair\n\t * @param {IEmmetEditor} editor Editor instance\n\t * @param {String} direction Direction of pair matching: 'in' or 'out'. \n\t * Default is 'out'\n\t */\n\tfunction matchPair(editor, direction) {\n\t\tdirection = String((direction || 'out').toLowerCase());\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\tvar range = require('range');\n\t\t/** @type Range */\n\t\tvar sel = range.create(editor.getSelectionRange());\n\t\tvar content = info.content;\n\t\t\n\t\t// validate previous match\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\tlastMatch = null;\n\t\t}\n\t\t\n\t\tif (lastMatch && sel.length()) {\n\t\t\tif (direction == 'in') {\n\t\t\t\t// user has previously selected tag and wants to move inward\n\t\t\t\tif (lastMatch.type == 'tag' && !lastMatch.close) {\n\t\t\t\t\t// unary tag was selected, can't move inward\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\tif (lastMatch.range.equal(lastMatch.outerRange)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar narrowed = require('utils').narrowToNonSpace(content, lastMatch.innerRange);\n\t\t\t\t\t\tlastMatch = matcher.find(content, narrowed.start + 1);\n\t\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.outerRange.equal(sel)) {\n\t\t\t\t\t\t\tlastMatch.range = lastMatch.innerRange;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (\n\t\t\t\t\t\t!lastMatch.innerRange.equal(lastMatch.outerRange) \n\t\t\t\t\t\t&& lastMatch.range.equal(lastMatch.innerRange) \n\t\t\t\t\t\t&& sel.equal(lastMatch.range)) {\n\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t} else {\n\t\t\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t\t\t\tif (lastMatch && lastMatch.range.equal(sel) && lastMatch.innerRange.equal(sel)) {\n\t\t\t\t\t\tlastMatch.range = lastMatch.outerRange;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlastMatch = matcher.find(content, sel.start);\n\t\t}\n\t\t\n\t\tif (lastMatch && !lastMatch.range.equal(sel)) {\n\t\t\teditor.createSelection(lastMatch.range.start, lastMatch.range.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tlastMatch = null;\n\t\treturn false;\n\t}\n\t\n\tactions.add('match_pair', matchPair, {hidden: true});\n\tactions.add('match_pair_inward', function(editor){\n\t\treturn matchPair(editor, 'in');\n\t}, {label: 'HTML/Match Pair Tag (inward)'});\n\n\tactions.add('match_pair_outward', function(editor){\n\t\treturn matchPair(editor, 'out');\n\t}, {label: 'HTML/Match Pair Tag (outward)'});\n\t\n\t/**\n\t * Moves caret to matching opening or closing tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tactions.add('matching_pair', function(editor) {\n\t\tvar content = String(editor.getContent());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tif (content.charAt(caretPos) == '<') \n\t\t\t// looks like caret is outside of tag pair  \n\t\t\tcaretPos++;\n\t\t\t\n\t\tvar tag = matcher.tag(content, caretPos);\n\t\tif (tag && tag.close) { // exclude unary tags\n\t\t\tif (tag.open.range.inside(caretPos)) {\n\t\t\t\teditor.setCaretPos(tag.close.range.start);\n\t\t\t} else {\n\t\t\t\teditor.setCaretPos(tag.open.range.start);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Go To Matching Tag Pair'});\n});/**\n * Gracefully removes tag under cursor\n * \n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('remove_tag', function(editor) {\n\t\tvar utils = require('utils');\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\t\n\t\t// search for tag\n\t\tvar tag = require('htmlMatcher').tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\tif (!tag.close) {\n\t\t\t\t// simply remove unary tag\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder(), tag.range.start, tag.range.end);\n\t\t\t} else {\n\t\t\t\t// remove tag and its newlines\n\t\t\t\t/** @type Range */\n\t\t\t\tvar tagContentRange = utils.narrowToNonSpace(info.content, tag.innerRange);\n\t\t\t\t/** @type Range */\n\t\t\t\tvar startLineBounds = utils.findNewlineBounds(info.content, tagContentRange.start);\n\t\t\t\tvar startLinePad = utils.getLinePadding(startLineBounds.substring(info.content));\n\t\t\t\tvar tagContent = tagContentRange.substring(info.content);\n\t\t\t\t\n\t\t\t\ttagContent = utils.unindentString(tagContent, startLinePad);\n\t\t\t\teditor.replaceContent(utils.getCaretPlaceholder() + utils.escapeText(tagContent), tag.outerRange.start, tag.outerRange.end);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Remove Tag'});\n});\n/**\n * Splits or joins tag, e.g. transforms it into a short notation and vice versa:<br>\n * &lt;div&gt;&lt;/div&gt;  &lt;div /&gt; : join<br>\n * &lt;div /&gt;  &lt;div&gt;&lt;/div&gt; : split\n * @param {Function} require\n * @param {Underscore} _\n * @memberOf __splitJoinTagAction\n * @constructor\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {Object} profile\n\t * @param {Object} tag\n\t */\n\tfunction joinTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\t// empty closing slash is a nonsense for this action\n\t\tvar slash = profile.selfClosing() || ' /';\n\t\tvar content = tag.open.range.substring(tag.source).replace(/\\s*>$/, slash + '>');\n\t\t\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// update caret position\n\t\tif (content.length + tag.outerRange.start < caretPos) {\n\t\t\tcaretPos = content.length + tag.outerRange.start;\n\t\t}\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\tfunction splitTag(editor, profile, tag) {\n\t\t/** @type emmet.utils */\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar nl = utils.getNewline();\n\t\tvar pad = require('resources').getVariable('indentation');\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\t// define tag content depending on profile\n\t\tvar tagContent = (profile.tag_nl === true) ? nl + pad + nl : '';\n\t\tvar content = tag.outerContent().replace(/\\s*\\/>$/, '>');\n\t\tcaretPos = tag.outerRange.start + content.length;\n\t\tcontent += tagContent + '</' + tag.open.name + '>';\n\t\t\n\t\tcontent = utils.escapeText(content);\n\t\teditor.replaceContent(content, tag.outerRange.start, tag.outerRange.end);\n\t\teditor.setCaretPos(caretPos);\n\t\treturn true;\n\t}\n\t\n\trequire('actions').add('split_join_tag', function(editor, profileName) {\n\t\tvar matcher = require('htmlMatcher');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor, null, profileName);\n\t\tvar profile = require('profile').get(info.profile);\n\t\t\n\t\t// find tag at current position\n\t\tvar tag = matcher.tag(info.content, editor.getCaretPos());\n\t\tif (tag) {\n\t\t\treturn tag.close \n\t\t\t\t? joinTag(editor, profile, tag) \n\t\t\t\t: splitTag(editor, profile, tag);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'HTML/Split\\\\Join Tag Declaration'});\n});/**\n * Reflect CSS value: takes rule's value under caret and pastes it for the same \n * rules with vendor prefixes\n * @constructor\n * @memberOf __reflectCSSActionDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('reflectCSSValue', function(require, _) {\n\t/**\n\t * @type HandlerList List of registered handlers\n\t */\n\tvar handlers = require('handlerList').create();\n\t\n\trequire('actions').add('reflect_css_value', function(editor) {\n\t\tif (editor.getSyntax() != 'css') return false;\n\t\t\n\t\treturn require('actionUtils').compoundUpdate(editor, doCSSReflection(editor));\n\t}, {label: 'CSS/Reflect Value'});\n\t\n\tfunction doCSSReflection(editor) {\n\t\t/** @type emmet.cssEditTree */\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar outputInfo = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\n\t\tvar cssRule = cssEditTree.parseFromPosition(outputInfo.content, caretPos);\n\t\tif (!cssRule) return;\n\t\t\n\t\tvar property = cssRule.itemFromPosition(caretPos, true);\n\t\t// no property under cursor, nothing to reflect\n\t\tif (!property) return;\n\t\t\n\t\tvar oldRule = cssRule.source;\n\t\tvar offset = cssRule.options.offset;\n\t\tvar caretDelta = caretPos - offset - property.range().start;\n\t\t\n\t\thandlers.exec(false, [property]);\n\t\t\n\t\tif (oldRule !== cssRule.source) {\n\t\t\treturn {\n\t\t\t\tdata:  cssRule.source,\n\t\t\t\tstart: offset,\n\t\t\t\tend:   offset + oldRule.length,\n\t\t\t\tcaret: offset + property.range().start + caretDelta\n\t\t\t};\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns regexp that should match reflected CSS property names\n\t * @param {String} name Current CSS property name\n\t * @return {RegExp}\n\t */\n\tfunction getReflectedCSSName(name) {\n\t\tname = require('cssEditTree').baseName(name);\n\t\tvar vendorPrefix = '^(?:\\\\-\\\\w+\\\\-)?', m;\n\t\t\n\t\tif (name == 'opacity' || name == 'filter') {\n\t\t\treturn new RegExp(vendorPrefix + '(?:opacity|filter)$');\n\t\t} else if (m = name.match(/^border-radius-(top|bottom)(left|right)/)) {\n\t\t\t// Mozilla-style border radius\n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-' + m[1] + '-' + m[2] + '-radius)$');\n\t\t} else if (m = name.match(/^border-(top|bottom)-(left|right)-radius/)) { \n\t\t\treturn new RegExp(vendorPrefix + '(?:' + name + '|border-radius-' + m[1] + m[2] + ')$');\n\t\t}\n\t\t\n\t\treturn new RegExp(vendorPrefix + name + '$');\n\t}\n\t\n\t/**\n\t * Reflects value from <code>donor</code> into <code>receiver</code>\n\t * @param {CSSProperty} donor Donor CSS property from which value should\n\t * be reflected\n\t * @param {CSSProperty} receiver Property that should receive reflected \n\t * value from donor\n\t */\n\tfunction reflectValue(donor, receiver) {\n\t\tvar value = getReflectedValue(donor.name(), donor.value(), \n\t\t\t\treceiver.name(), receiver.value());\n\t\t\n\t\treceiver.value(value);\n\t}\n\t\n\t/**\n\t * Returns value that should be reflected for <code>refName</code> CSS property\n\t * from <code>curName</code> property. This function is used for special cases,\n\t * when the same result must be achieved with different properties for different\n\t * browsers. For example: opcity:0.5;  filter:alpha(opacity=50);<br><br>\n\t * \n\t * This function does value conversion between different CSS properties\n\t * \n\t * @param {String} curName Current CSS property name\n\t * @param {String} curValue Current CSS property value\n\t * @param {String} refName Receiver CSS property's name \n\t * @param {String} refValue Receiver CSS property's value\n\t * @return {String} New value for receiver property\n\t */\n\tfunction getReflectedValue(curName, curValue, refName, refValue) {\n\t\tvar cssEditTree = require('cssEditTree');\n\t\tvar utils = require('utils');\n\t\tcurName = cssEditTree.baseName(curName);\n\t\trefName = cssEditTree.baseName(refName);\n\t\t\n\t\tif (curName == 'opacity' && refName == 'filter') {\n\t\t\treturn refValue.replace(/opacity=[^)]*/i, 'opacity=' + Math.floor(parseFloat(curValue) * 100));\n\t\t} else if (curName == 'filter' && refName == 'opacity') {\n\t\t\tvar m = curValue.match(/opacity=([^)]*)/i);\n\t\t\treturn m ? utils.prettifyNumber(parseInt(m[1]) / 100) : refValue;\n\t\t}\n\t\t\n\t\treturn curValue;\n\t}\n\t\n\t// XXX add default handler\n\thandlers.add(function(property) {\n\t\tvar reName = getReflectedCSSName(property.name());\n\t\t_.each(property.parent.list(), function(p) {\n\t\t\tif (reName.test(p.name())) {\n\t\t\t\treflectValue(property, p);\n\t\t\t}\n\t\t});\n\t}, {order: -1});\n\t\n\treturn {\n\t\t/**\n\t\t * Adds custom reflect handler. The passed function will receive matched\n\t\t * CSS property (as <code>CSSEditElement</code> object) and should\n\t\t * return <code>true</code> if it was performed successfully (handled \n\t\t * reflection), <code>false</code> otherwise.\n\t\t * @param {Function} fn\n\t\t * @param {Object} options\n\t\t */\n\t\taddHandler: function(fn, options) {\n\t\t\thandlers.add(fn, options);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes registered handler\n\t\t * @returns\n\t\t */\n\t\tremoveHandler: function(fn) {\n\t\t\thandlers.remove(fn, options);\n\t\t}\n\t};\n});/**\n * Evaluates simple math expression under caret\n * @param {Function} require\n * @param {Underscore} _ \n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('evaluate_math_expression', function(editor) {\n\t\tvar actionUtils = require('actionUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar content = String(editor.getContent());\n\t\tvar chars = '.+-*/\\\\';\n\t\t\n\t\t/** @type Range */\n\t\tvar sel = require('range').create(editor.getSelectionRange());\n\t\tif (!sel.length()) {\n\t\t\tsel = actionUtils.findExpressionBounds(editor, function(ch) {\n\t\t\t\treturn utils.isNumeric(ch) || chars.indexOf(ch) != -1;\n\t\t\t});\n\t\t}\n\t\t\n\t\tif (sel && sel.length()) {\n\t\t\tvar expr = sel.substring(content);\n\t\t\t\n\t\t\t// replace integral division: 11\\2 => Math.round(11/2) \n\t\t\texpr = expr.replace(/([\\d\\.\\-]+)\\\\([\\d\\.\\-]+)/g, 'Math.round($1/$2)');\n\t\t\t\n\t\t\ttry {\n\t\t\t\tvar result = utils.prettifyNumber(new Function('return ' + expr)());\n\t\t\t\teditor.replaceContent(result, sel.start, sel.end);\n\t\t\t\teditor.setCaretPos(sel.start + result.length);\n\t\t\t\treturn true;\n\t\t\t} catch (e) {}\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Numbers/Evaluate Math Expression'});\n});\n/**\n * Increment/decrement number under cursor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Extract number from current caret position of the <code>editor</code> and\n\t * increment it by <code>step</code>\n\t * @param {IEmmetEditor} editor\n\t * @param {Number} step Increment step (may be negative)\n\t */\n\tfunction incrementNumber(editor, step) {\n\t\tvar utils = require('utils');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar hasSign = false;\n\t\tvar hasDecimal = false;\n\t\t\t\n\t\tvar r = actionUtils.findExpressionBounds(editor, function(ch, pos, content) {\n\t\t\tif (utils.isNumeric(ch))\n\t\t\t\treturn true;\n\t\t\tif (ch == '.') {\n\t\t\t\t// make sure that next character is numeric too\n\t\t\t\tif (!utils.isNumeric(content.charAt(pos + 1)))\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\treturn hasDecimal ? false : hasDecimal = true;\n\t\t\t}\n\t\t\tif (ch == '-')\n\t\t\t\treturn hasSign ? false : hasSign = true;\n\t\t\t\t\n\t\t\treturn false;\n\t\t});\n\t\t\t\n\t\tif (r && r.length()) {\n\t\t\tvar strNum = r.substring(String(editor.getContent()));\n\t\t\tvar num = parseFloat(strNum);\n\t\t\tif (!_.isNaN(num)) {\n\t\t\t\tnum = utils.prettifyNumber(num + step);\n\t\t\t\t\n\t\t\t\t// do we have zero-padded number?\n\t\t\t\tif (/^(\\-?)0+[1-9]/.test(strNum)) {\n\t\t\t\t\tvar minus = '';\n\t\t\t\t\tif (RegExp.$1) {\n\t\t\t\t\t\tminus = '-';\n\t\t\t\t\t\tnum = num.substring(1);\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tvar parts = num.split('.');\n\t\t\t\t\tparts[0] = utils.zeroPadString(parts[0], intLength(strNum));\n\t\t\t\t\tnum = minus + parts.join('.');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(num, r.start, r.end);\n\t\t\t\teditor.createSelection(r.start, r.start + num.length);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns length of integer part of number\n\t * @param {String} num\n\t */\n\tfunction intLength(num) {\n\t\tnum = num.replace(/^\\-/, '');\n\t\tif (~num.indexOf('.')) {\n\t\t\treturn num.split('.')[0].length;\n\t\t}\n\t\t\n\t\treturn num.length;\n\t}\n\t\n\tvar actions = require('actions');\n\t_.each([1, -1, 10, -10, 0.1, -0.1], function(num) {\n\t\tvar prefix = num > 0 ? 'increment' : 'decrement';\n\t\t\n\t\tactions.add(prefix + '_number_by_' + String(Math.abs(num)).replace('.', '').substring(0, 2), function(editor) {\n\t\t\treturn incrementNumber(editor, num);\n\t\t}, {label: 'Numbers/' + prefix.charAt(0).toUpperCase() + prefix.substring(1) + ' number by ' + Math.abs(num)});\n\t});\n});/**\n * Actions to insert line breaks. Some simple editors (like browser's \n * &lt;textarea&gt;, for example) do not provide such simple things\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar actions = require('actions');\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\t// setup default preferences\n\tprefs.define('css.closeBraceIndentation', '\\n',\n\t\t\t'Indentation before closing brace of CSS rule. Some users prefere ' \n\t\t\t+ 'indented closing brace of CSS rule for better readability. '\n\t\t\t+ 'This preferences value will be automatically inserted before '\n\t\t\t+ 'closing brace when user adds newline in newly created CSS rule '\n\t\t\t+ '(e.g. when Insert formatted linebreak action will be performed ' \n\t\t\t+ 'in CSS file). If youre such user, you may want to write put a value ' \n\t\t\t+ 'like <code>\\\\n\\\\t</code> in this preference.');\n\t\n\t/**\n\t * Inserts newline character with proper indentation in specific positions only.\n\t * @param {IEmmetEditor} editor\n\t * @return {Boolean} Returns <code>true</code> if line break was inserted \n\t */\n\tactions.add('insert_formatted_line_break_only', function(editor) {\n\t\tvar utils = require('utils');\n\t\t/** @type emmet.resources */\n\t\tvar res = require('resources');\n\t\t\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar caretPos = editor.getCaretPos();\n\t\tvar nl = utils.getNewline();\n\t\t\n\t\tif (_.include(['html', 'xml', 'xsl'], info.syntax)) {\n\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t// let's see if we're breaking newly created tag\n\t\t\tvar tag = require('htmlMatcher').tag(info.content, caretPos);\n\t\t\tif (tag && !tag.innerRange.length()) {\n\t\t\t\teditor.replaceContent(nl + pad + utils.getCaretPlaceholder() + nl, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (info.syntax == 'css') {\n\t\t\t/** @type String */\n\t\t\tvar content = info.content;\n\t\t\tif (caretPos && content.charAt(caretPos - 1) == '{') {\n\t\t\t\tvar append = prefs.get('css.closeBraceIndentation');\n\t\t\t\tvar pad = res.getVariable('indentation');\n\t\t\t\t\n\t\t\t\tvar hasCloseBrace = content.charAt(caretPos) == '}';\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\t// do we really need special formatting here?\n\t\t\t\t\t// check if this is really a newly created rule,\n\t\t\t\t\t// look ahead for a closing brace\n\t\t\t\t\tfor (var i = caretPos, il = content.length, ch; i < il; i++) {\n\t\t\t\t\t\tch = content.charAt(i);\n\t\t\t\t\t\tif (ch == '{') {\n\t\t\t\t\t\t\t// ok, this is a new rule without closing brace\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (ch == '}') {\n\t\t\t\t\t\t\t// not a new rule, just add indentation\n\t\t\t\t\t\t\tappend = '';\n\t\t\t\t\t\t\thasCloseBrace = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!hasCloseBrace) {\n\t\t\t\t\tappend += '}';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// defining rule set\n\t\t\t\tvar insValue = nl + pad + utils.getCaretPlaceholder() + append;\n\t\t\t\teditor.replaceContent(insValue, caretPos);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\treturn false;\n\t}, {hidden: true});\n\t\n\t/**\n\t * Inserts newline character with proper indentation. This action is used in\n\t * editors that doesn't have indentation control (like textarea element) to \n\t * provide proper indentation\n\t * @param {IEmmetEditor} editor Editor instance\n\t */\n\tactions.add('insert_formatted_line_break', function(editor) {\n\t\tif (!actions.run('insert_formatted_line_break_only', editor)) {\n\t\t\tvar utils = require('utils');\n\t\t\t\n\t\t\tvar curPadding = require('editorUtils').getCurrentLinePadding(editor);\n\t\t\tvar content = String(editor.getContent());\n\t\t\tvar caretPos = editor.getCaretPos();\n\t\t\tvar len = content.length;\n\t\t\tvar nl = utils.getNewline();\n\t\t\t\t\n\t\t\t// check out next line padding\n\t\t\tvar lineRange = editor.getCurrentLineRange();\n\t\t\tvar nextPadding = '';\n\t\t\t\t\n\t\t\tfor (var i = lineRange.end + 1, ch; i < len; i++) {\n\t\t\t\tch = content.charAt(i);\n\t\t\t\tif (ch == ' ' || ch == '\\t')\n\t\t\t\t\tnextPadding += ch;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (nextPadding.length > curPadding.length)\n\t\t\t\teditor.replaceContent(nl + nextPadding, caretPos, caretPos, true);\n\t\t\telse\n\t\t\t\teditor.replaceContent(nl, caretPos);\n\t\t}\n\t\t\n\t\treturn true;\n\t}, {hidden: true});\n});/**\n * Merges selected lines or lines between XHTML tag pairs\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('merge_lines', function(editor) {\n\t\tvar matcher = require('htmlMatcher');\n\t\tvar utils = require('utils');\n\t\tvar editorUtils = require('editorUtils');\n\t\tvar info = editorUtils.outputInfo(editor);\n\t\t\n\t\t/** @type Range */\n\t\tvar selection = require('range').create(editor.getSelectionRange());\n\t\tif (!selection.length()) {\n\t\t\t// find matching tag\n\t\t\tvar pair = matcher.find(info.content, editor.getCaretPos());\n\t\t\tif (pair) {\n\t\t\t\tselection = pair.outerRange;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (selection.length()) {\n\t\t\t// got range, merge lines\n\t\t\tvar text =  selection.substring(info.content);\n\t\t\tvar lines = utils.splitByLines(text);\n\t\t\t\n\t\t\tfor (var i = 1; i < lines.length; i++) {\n\t\t\t\tlines[i] = lines[i].replace(/^\\s+/, '');\n\t\t\t}\n\t\t\t\n\t\t\ttext = lines.join('').replace(/\\s{2,}/, ' ');\n\t\t\tvar textLen = text.length;\n\t\t\ttext = utils.escapeText(text);\n\t\t\teditor.replaceContent(text, selection.start, selection.end);\n\t\t\teditor.createSelection(selection.start, selection.start + textLen);\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n});/**\n * Encodes/decodes image under cursor to/from base64\n * @param {IEmmetEditor} editor\n * @since 0.65\n * \n * @memberOf __base64ActionDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('actions').add('encode_decode_data_url', function(editor) {\n\t\tvar data = String(editor.getSelection());\n\t\tvar caretPos = editor.getCaretPos();\n\t\t\t\n\t\tif (!data) {\n\t\t\t// no selection, try to find image bounds from current caret position\n\t\t\tvar text = String(editor.getContent()),  m;\n\t\t\twhile (caretPos-- >= 0) {\n\t\t\t\tif (startsWith('src=', text, caretPos)) { // found <img src=\"\">\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(src=([\"'])?)([^'\"<>\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (startsWith('url(', text, caretPos)) { // found CSS url() pattern\n\t\t\t\t\tif (m = text.substr(caretPos).match(/^(url\\((['\"])?)([^'\"\\)\\s]+)\\1?/)) {\n\t\t\t\t\t\tdata = m[3];\n\t\t\t\t\t\tcaretPos += m[1].length;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (data) {\n\t\t\tif (startsWith('data:', data))\n\t\t\t\treturn decodeFromBase64(editor, data, caretPos);\n\t\t\telse\n\t\t\t\treturn encodeToBase64(editor, data, caretPos);\n\t\t}\n\t\t\n\t\treturn false;\n\t}, {label: 'Encode\\\\Decode data:URL image'});\n\t\n\t/**\n\t * Test if <code>text</code> starts with <code>token</code> at <code>pos</code>\n\t * position. If <code>pos</code> is omitted, search from beginning of text \n\t * @param {String} token Token to test\n\t * @param {String} text Where to search\n\t * @param {Number} pos Position where to start search\n\t * @return {Boolean}\n\t * @since 0.65\n\t */\n\tfunction startsWith(token, text, pos) {\n\t\tpos = pos || 0;\n\t\treturn text.charAt(pos) == token.charAt(0) && text.substr(pos, token.length) == token;\n\t}\n\t\n\t/**\n\t * Encodes image to base64\n\t * \n\t * @param {IEmmetEditor} editor\n\t * @param {String} imgPath Path to image\n\t * @param {Number} pos Caret position where image is located in the editor\n\t * @return {Boolean}\n\t */\n\tfunction encodeToBase64(editor, imgPath, pos) {\n\t\tvar file = require('file');\n\t\tvar actionUtils = require('actionUtils');\n\t\t\n\t\tvar editorFile = editor.getFilePath();\n\t\tvar defaultMimeType = 'application/octet-stream';\n\t\t\t\n\t\tif (editorFile === null) {\n\t\t\tthrow \"You should save your file before using this action\";\n\t\t}\n\t\t\n\t\t// locate real image path\n\t\tvar realImgPath = file.locateFile(editorFile, imgPath);\n\t\tif (realImgPath === null) {\n\t\t\tthrow \"Can't find \" + imgPath + ' file';\n\t\t}\n\t\t\n\t\tfile.read(realImgPath, function(err, content) {\n\t\t\tif (err) {\n\t\t\t\tthrow 'Unable to read ' + realImgPath + ': ' + err;\n\t\t\t}\n\t\t\t\n\t\t\tvar b64 = require('base64').encode(String(content));\n\t\t\tif (!b64) {\n\t\t\t\tthrow \"Can't encode file content to base64\";\n\t\t\t}\n\t\t\t\n\t\t\tb64 = 'data:' + (actionUtils.mimeTypes[String(file.getExt(realImgPath))] || defaultMimeType) +\n\t\t\t\t';base64,' + b64;\n\t\t\t\t\n\t\t\teditor.replaceContent('$0' + b64, pos, pos + imgPath.length);\n\t\t});\n\t\t\n\t\t\n\t\treturn true;\n\t}\n\n\t/**\n\t * Decodes base64 string back to file.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} data Base64-encoded file content\n\t * @param {Number} pos Caret position where image is located in the editor\n\t */\n\tfunction decodeFromBase64(editor, data, pos) {\n\t\t// ask user to enter path to file\n\t\tvar filePath = String(editor.prompt('Enter path to file (absolute or relative)'));\n\t\tif (!filePath)\n\t\t\treturn false;\n\t\t\t\n\t\tvar file = require('file');\n\t\tvar absPath = file.createPath(editor.getFilePath(), filePath);\n\t\tif (!absPath) {\n\t\t\tthrow \"Can't save file\";\n\t\t}\n\t\t\n\t\tfile.save(absPath, require('base64').decode( data.replace(/^data\\:.+?;.+?,/, '') ));\n\t\teditor.replaceContent('$0' + filePath, pos, pos + data.length);\n\t\treturn true;\n\t}\n});\n/**\n * Automatically updates image size attributes in HTML's &lt;img&gt; element or\n * CSS rule\n * @param {Function} require\n * @param {Underscore} _\n * @constructor\n * @memberOf __updateImageSizeAction\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Updates image size of &lt;img src=\"\"&gt; tag\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeHTML(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar xmlElem = require('xmlEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (xmlElem && (xmlElem.name() || '').toLowerCase() == 'img') {\n\t\t\tgetImageSizeForSource(editor, xmlElem.value('src'), function(size) {\n\t\t\t\tif (size) {\n\t\t\t\t\tvar compoundData = xmlElem.range(true);\n\t\t\t\t\txmlElem.value('width', size.width);\n\t\t\t\t\txmlElem.value('height', size.height, xmlElem.indexOf('width') + 1);\n\t\t\t\t\t\n\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\tdata: xmlElem.toString(),\n\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\t/**\n\t * Updates image size of CSS property\n\t * @param {IEmmetEditor} editor\n\t */\n\tfunction updateImageSizeCSS(editor) {\n\t\tvar offset = editor.getCaretPos();\n\t\t\n\t\t// find tag from current caret position\n\t\tvar info = require('editorUtils').outputInfo(editor);\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(info.content, offset, true);\n\t\tif (cssRule) {\n\t\t\t// check if there is property with image under caret\n\t\t\tvar prop = cssRule.itemFromPosition(offset, true), m;\n\t\t\tif (prop && (m = /url\\(([\"']?)(.+?)\\1\\)/i.exec(prop.value() || ''))) {\n\t\t\t\tgetImageSizeForSource(editor, m[2], function(size) {\n\t\t\t\t\tif (size) {\n\t\t\t\t\t\tvar compoundData = cssRule.range(true);\n\t\t\t\t\t\tcssRule.value('width', size.width + 'px');\n\t\t\t\t\t\tcssRule.value('height', size.height + 'px', cssRule.indexOf('width') + 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\trequire('actionUtils').compoundUpdate(editor, _.extend(compoundData, {\n\t\t\t\t\t\t\tdata: cssRule.toString(),\n\t\t\t\t\t\t\tcaret: offset\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Returns image dimensions for source\n\t * @param {IEmmetEditor} editor\n\t * @param {String} src Image source (path or data:url)\n\t */\n\tfunction getImageSizeForSource(editor, src, callback) {\n\t\tvar fileContent;\n\t\tvar au = require('actionUtils');\n\t\tif (src) {\n\t\t\t// check if it is data:url\n\t\t\tif (/^data:/.test(src)) {\n\t\t\t\tfileContent = require('base64').decode( src.replace(/^data\\:.+?;.+?,/, '') );\n\t\t\t\treturn callback(au.getImageSize(fileContent));\n\t\t\t}\n\t\t\t\n\t\t\tvar file = require('file');\n\t\t\tvar absPath = file.locateFile(editor.getFilePath(), src);\n\t\t\tif (absPath === null) {\n\t\t\t\tthrow \"Can't find \" + src + ' file';\n\t\t\t}\n\t\t\t\n\t\t\tfile.read(absPath, function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tthrow 'Unable to read ' + absPath + ': ' + err;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcontent = String(content);\n\t\t\t\tcallback(au.getImageSize(content));\n\t\t\t});\n\t\t}\n\t}\n\t\n\trequire('actions').add('update_image_size', function(editor) {\n\t\t// this action will definitely wont work in SASS dialect,\n\t\t// but may work in SCSS or LESS\n\t\tif (_.include(['css', 'less', 'scss'], String(editor.getSyntax()))) {\n\t\t\tupdateImageSizeCSS(editor);\n\t\t} else {\n\t\t\tupdateImageSizeHTML(editor);\n\t\t}\n\t\t\n\t\treturn true;\n\t});\n});/**\n * Resolver for fast CSS typing. Handles abbreviations with the following \n * notation:<br>\n * \n * <code>(-vendor prefix)?property(value)*(!)?</code>\n * \n * <br><br>\n * <b>Abbreviation handling</b><br>\n * \n * By default, Emmet searches for matching snippet definition for provided abbreviation.\n * If snippet wasn't found, Emmet automatically generates element with \n * abbreviation's name. For example, <code>foo</code> abbreviation will generate\n * <code>&lt;foo&gt;&lt;/foo&gt;</code> output.\n * <br><br>\n * This module will capture all expanded properties and upgrade them with values, \n * vendor prefixes and !important declarations. All unmatched abbreviations will \n * be automatically transformed into <code>property-name: ${1}</code> snippets. \n * \n * <b>Vendor prefixes<b><br>\n * \n * If CSS-property is preceded with dash, resolver should output property with\n * all <i>known</i> vendor prefixes. For example, if <code>brad</code> \n * abbreviation generates <code>border-radius: ${value};</code> snippet,\n * the <code>-brad</code> abbreviation should generate:\n * <pre><code>\n * -webkit-border-radius: ${value};\n * -moz-border-radius: ${value};\n * border-radius: ${value};\n * </code></pre>\n * Note that <i>o</i> and <i>ms</i> prefixes are omitted since Opera and IE \n * supports unprefixed property.<br><br>\n * \n * Users can also provide an explicit list of one-character prefixes for any\n * CSS property. For example, <code>-wm-float</code> will produce\n * \n * <pre><code>\n * -webkit-float: ${1};\n * -moz-float: ${1};\n * float: ${1};\n * </code></pre>\n * \n * Although this example looks pointless, users can use this feature to write\n * cutting-edge properties implemented by browser vendors recently.  \n * \n * @constructor\n * @memberOf __cssResolverDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssResolver', function(require, _) {\n\t/** Back-reference to module */\n\tvar module = null;\n\t\n\tvar prefixObj = {\n\t\t/** Real vendor prefix name */\n\t\tprefix: 'emmet',\n\t\t\n\t\t/** \n\t\t * Indicates this prefix is obsolete and should't be used when user \n\t\t * wants to generate all-prefixed properties\n\t\t */\n\t\tobsolete: false,\n\t\t\n\t\t/**\n\t\t * Returns prefixed CSS property name\n\t\t * @param {String} name Unprefixed CSS property\n\t\t */\n\t\ttransformName: function(name) {\n\t\t\treturn '-' + this.prefix + '-' + name;\n\t\t},\n\t\t\n\t\t/**\n\t\t * List of unprefixed CSS properties that supported by \n\t\t * current prefix. This list is used to generate all-prefixed property\n\t\t * @returns {Array} \n\t\t */\n\t\tproperties: function() {\n\t\t\treturn getProperties('css.' + this.prefix + 'Properties') || [];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if given property is supported by current prefix\n\t\t * @param name\n\t\t */\n\t\tsupports: function(name) {\n\t\t\treturn _.include(this.properties(), name);\n\t\t}\n\t};\n\t\n\t\n\t/** \n\t * List of registered one-character prefixes. Key is a one-character prefix, \n\t * value is an <code>prefixObj</code> object\n\t */\n\tvar vendorPrefixes = {};\n\t\n\tvar defaultValue = '${1};';\n\t\n\t// XXX module preferences\n\tvar prefs = require('preferences');\n\tprefs.define('css.valueSeparator', ': ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations.');\n\tprefs.define('css.propertyEnd', ';',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations.');\n\t\n\tprefs.define('stylus.valueSeparator', ' ',\n\t\t\t'Defines a symbol that should be placed between CSS property and ' \n\t\t\t+ 'value when expanding CSS abbreviations in Stylus dialect.');\n\tprefs.define('stylus.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in Stylus dialect.');\n\t\n\tprefs.define('sass.propertyEnd', '',\n\t\t\t'Defines a symbol that should be placed at the end of CSS property  ' \n\t\t\t+ 'when expanding CSS abbreviations in SASS dialect.');\n\t\n\tprefs.define('css.autoInsertVendorPrefixes', true,\n\t\t\t'Automatically generate vendor-prefixed copies of expanded CSS ' \n\t\t\t+ 'property. By default, Emmet will generate vendor-prefixed '\n\t\t\t+ 'properties only when you put dash before abbreviation ' \n\t\t\t+ '(e.g. <code>-bxsh</code>). With this option enabled, you dont ' \n\t\t\t+ 'need dashes before abbreviations: Emmet will produce ' \n\t\t\t+ 'vendor-prefixed properties for you.');\n\t\n\tvar descTemplate = _.template('A comma-separated list of CSS properties that may have ' \n\t\t+ '<code><%= vendor %></code> vendor prefix. This list is used to generate '\n\t\t+ 'a list of prefixed properties when expanding <code>-property</code> '\n\t\t+ 'abbreviations. Empty list means that all possible CSS values may ' \n\t\t+ 'have <code><%= vendor %></code> prefix.');\n\t\n\tvar descAddonTemplate = _.template('A comma-separated list of <em>additional</em> CSS properties ' \n\t\t\t+ 'for <code>css.<%= vendor %>Preperties</code> preference. ' \n\t\t\t+ 'You should use this list if you want to add or remove a few CSS ' \n\t\t\t+ 'properties to original set. To add a new property, simply write its name, '\n\t\t\t+ 'to remove it, precede property with hyphen.<br>'\n\t\t\t+ 'For example, to add <em>foo</em> property and remove <em>border-radius</em> one, '\n\t\t\t+ 'the preference value will look like this: <code>foo, -border-radius</code>.');\n\t\n\t// properties list is created from cssFeatures.html file\n\tvar props = {\n\t\t'webkit': 'animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-clip, background-composite, background-origin, background-size, border-fit, border-horizontal-spacing, border-image, border-vertical-spacing, box-align, box-direction, box-flex, box-flex-group, box-lines, box-ordinal-group, box-orient, box-pack, box-reflect, box-shadow, color-correction, column-break-after, column-break-before, column-break-inside, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-span, column-width, dashboard-region, font-smoothing, highlight, hyphenate-character, hyphenate-limit-after, hyphenate-limit-before, hyphens, line-box-contain, line-break, line-clamp, locale, margin-before-collapse, margin-after-collapse, marquee-direction, marquee-increment, marquee-repetition, marquee-style, mask-attachment, mask-box-image, mask-box-image-outset, mask-box-image-repeat, mask-box-image-slice, mask-box-image-source, mask-box-image-width, mask-clip, mask-composite, mask-image, mask-origin, mask-position, mask-repeat, mask-size, nbsp-mode, perspective, perspective-origin, rtl-ordering, text-combine, text-decorations-in-effect, text-emphasis-color, text-emphasis-position, text-emphasis-style, text-fill-color, text-orientation, text-security, text-stroke-color, text-stroke-width, transform, transition, transform-origin, transform-style, transition-delay, transition-duration, transition-property, transition-timing-function, user-drag, user-modify, user-select, writing-mode, svg-shadow, box-sizing, border-radius',\n\t\t'moz': 'animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, appearance, backface-visibility, background-inline-policy, binding, border-bottom-colors, border-image, border-left-colors, border-right-colors, border-top-colors, box-align, box-direction, box-flex, box-ordinal-group, box-orient, box-pack, box-shadow, box-sizing, column-count, column-gap, column-rule-color, column-rule-style, column-rule-width, column-width, float-edge, font-feature-settings, font-language-override, force-broken-image-icon, hyphens, image-region, orient, outline-radius-bottomleft, outline-radius-bottomright, outline-radius-topleft, outline-radius-topright, perspective, perspective-origin, stack-sizing, tab-size, text-blink, text-decoration-color, text-decoration-line, text-decoration-style, text-size-adjust, transform, transform-origin, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-focus, user-input, user-modify, user-select, window-shadow, background-clip, border-radius',\n\t\t'ms': 'accelerator, backface-visibility, background-position-x, background-position-y, behavior, block-progression, box-align, box-direction, box-flex, box-line-progression, box-lines, box-ordinal-group, box-orient, box-pack, content-zoom-boundary, content-zoom-boundary-max, content-zoom-boundary-min, content-zoom-chaining, content-zoom-snap, content-zoom-snap-points, content-zoom-snap-type, content-zooming, filter, flow-from, flow-into, font-feature-settings, grid-column, grid-column-align, grid-column-span, grid-columns, grid-layer, grid-row, grid-row-align, grid-row-span, grid-rows, high-contrast-adjust, hyphenate-limit-chars, hyphenate-limit-lines, hyphenate-limit-zone, hyphens, ime-mode, interpolation-mode, layout-flow, layout-grid, layout-grid-char, layout-grid-line, layout-grid-mode, layout-grid-type, line-break, overflow-style, perspective, perspective-origin, perspective-origin-x, perspective-origin-y, scroll-boundary, scroll-boundary-bottom, scroll-boundary-left, scroll-boundary-right, scroll-boundary-top, scroll-chaining, scroll-rails, scroll-snap-points-x, scroll-snap-points-y, scroll-snap-type, scroll-snap-x, scroll-snap-y, scrollbar-arrow-color, scrollbar-base-color, scrollbar-darkshadow-color, scrollbar-face-color, scrollbar-highlight-color, scrollbar-shadow-color, scrollbar-track-color, text-align-last, text-autospace, text-justify, text-kashida-space, text-overflow, text-size-adjust, text-underline-position, touch-action, transform, transform-origin, transform-origin-x, transform-origin-y, transform-origin-z, transform-style, transition, transition-delay, transition-duration, transition-property, transition-timing-function, user-select, word-break, word-wrap, wrap-flow, wrap-margin, wrap-through, writing-mode',\n\t\t'o': 'dashboard-region, animation, animation-delay, animation-direction, animation-duration, animation-fill-mode, animation-iteration-count, animation-name, animation-play-state, animation-timing-function, border-image, link, link-source, object-fit, object-position, tab-size, table-baseline, transform, transform-origin, transition, transition-delay, transition-duration, transition-property, transition-timing-function, accesskey, input-format, input-required, marquee-dir, marquee-loop, marquee-speed, marquee-style'\n\t};\n\t\n\t_.each(props, function(v, k) {\n\t\tprefs.define('css.' + k + 'Properties', v, descTemplate({vendor: k}));\n\t\tprefs.define('css.' + k + 'PropertiesAddon', '', descAddonTemplate({vendor: k}));\n\t});\n\t\n\tprefs.define('css.unitlessProperties', 'z-index, line-height, opacity, font-weight, zoom', \n\t\t\t'The list of properties whose values must not contain units.');\n\t\n\tprefs.define('css.intUnit', 'px', 'Default unit for integer values');\n\tprefs.define('css.floatUnit', 'em', 'Default unit for float values');\n\t\n\tprefs.define('css.keywords', 'auto, inherit', \n\t\t\t'A comma-separated list of valid keywords that can be used in CSS abbreviations.');\n\t\n\tprefs.define('css.keywordAliases', 'a:auto, i:inherit, s:solid, da:dashed, do:dotted, t:transparent', \n\t\t\t'A comma-separated list of keyword aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:keyword_name</code>.');\n\t\n\tprefs.define('css.unitAliases', 'e:em, p:%, x:ex, r:rem', \n\t\t\t'A comma-separated list of unit aliases, used in CSS abbreviation. '\n\t\t\t+ 'Each alias should be defined as <code>alias:unit_value</code>.');\n\t\n\tprefs.define('css.color.short', true, \n\t\t\t'Should color values like <code>#ffffff</code> be shortened to '\n\t\t\t+ '<code>#fff</code> after abbreviation with color was expanded.');\n\t\n\tprefs.define('css.color.case', 'keep', \n\t\t\t'Letter case of color values generated by abbreviations with color '\n\t\t\t+ '(like <code>c#0</code>). Possible values are <code>upper</code>, '\n\t\t\t+ '<code>lower</code> and <code>keep</code>.');\n\t\n\tprefs.define('css.fuzzySearch', true, \n\t\t\t'Enable fuzzy search among CSS snippet names. When enabled, every ' \n\t\t\t+ '<em>unknown</em> snippet will be scored against available snippet '\n\t\t\t+ 'names (not values or CSS properties!). The match with best score '\n\t\t\t+ 'will be used to resolve snippet value. For example, with this ' \n\t\t\t+ 'preference enabled, the following abbreviations are equal: '\n\t\t\t+ '<code>ov:h</code> == <code>ov-h</code> == <code>o-h</code> == '\n\t\t\t+ '<code>oh</code>');\n\t\n\tprefs.define('css.fuzzySearchMinScore', 0.3, \n\t\t\t'The minium score (from 0 to 1) that fuzzy-matched abbreviation should ' \n\t\t\t+ 'achive. Lower values may produce many false-positive matches, '\n\t\t\t+ 'higher values may reduce possible matches.');\n\t\n\tprefs.define('css.alignVendor', false, \n\t\t\t'If set to <code>true</code>, all generated vendor-prefixed properties ' \n\t\t\t+ 'will be aligned by real property name.');\n\t\n\t\n\tfunction isNumeric(ch) {\n\t\tvar code = ch && ch.charCodeAt(0);\n\t\treturn (ch && ch == '.' || (code > 47 && code < 58));\n\t}\n\t\n\t/**\n\t * Check if provided snippet contains only one CSS property and value.\n\t * @param {String} snippet\n\t * @returns {Boolean}\n\t */\n\tfunction isSingleProperty(snippet) {\n\t\tvar utils = require('utils');\n\t\tsnippet = utils.trim(snippet);\n\t\t\n\t\t// check if it doesn't contain a comment and a newline\n\t\tif (~snippet.indexOf('/*') || /[\\n\\r]/.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// check if it's a valid snippet definition\n\t\tif (!/^[a-z0-9\\-]+\\s*\\:/i.test(snippet)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tsnippet = require('tabStops').processText(snippet, {\n\t\t\treplaceCarets: true,\n\t\t\ttabstop: function() {\n\t\t\t\treturn 'value';\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn snippet.split(':').length == 2;\n\t}\n\t\n\t/**\n\t * Normalizes abbreviated value to final CSS one\n\t * @param {String} value\n\t * @returns {String}\n\t */\n\tfunction normalizeValue(value) {\n\t\tif (value.charAt(0) == '-' && !/^\\-[\\.\\d]/.test(value)) {\n\t\t\tvalue = value.replace(/^\\-+/, '');\n\t\t}\n\t\t\n\t\tif (value.charAt(0) == '#') {\n\t\t\treturn normalizeHexColor(value);\n\t\t}\n\t\t\n\t\treturn getKeyword(value);\n\t}\n\t\n\tfunction normalizeHexColor(value) {\n\t\tvar hex = value.replace(/^#+/, '') || '0';\n\t\tif (hex.toLowerCase() == 't') {\n\t\t\treturn 'transparent';\n\t\t}\n\t\t\n\t\tvar repeat = require('utils').repeatString;\n\t\tvar color = null;\n\t\tswitch (hex.length) {\n\t\t\tcase 1:\n\t\t\t\tcolor = repeat(hex, 6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcolor = repeat(hex, 3);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcolor = hex.charAt(0) + hex.charAt(0) + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcolor = hex + hex.substr(0, 2);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tcolor = hex + hex.charAt(0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcolor = hex.substr(0, 6);\n\t\t}\n\t\t\n\t\t// color must be shortened?\n\t\tif (prefs.get('css.color.short')) {\n\t\t\tvar p = color.split('');\n\t\t\tif (p[0] == p[1] && p[2] == p[3] && p[4] == p[5]) {\n\t\t\t\tcolor = p[0] + p[2] + p[4];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// should transform case?\n\t\tswitch (prefs.get('css.color.case')) {\n\t\t\tcase 'upper':\n\t\t\t\tcolor = color.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase 'lower':\n\t\t\t\tcolor = color.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn '#' + color;\n\t}\n\t\n\tfunction getKeyword(name) {\n\t\tvar aliases = prefs.getDict('css.keywordAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction getUnit(name) {\n\t\tvar aliases = prefs.getDict('css.unitAliases');\n\t\treturn name in aliases ? aliases[name] : name;\n\t}\n\t\n\tfunction isValidKeyword(keyword) {\n\t\treturn _.include(prefs.getArray('css.keywords'), getKeyword(keyword));\n\t}\n\t\n\t/**\n\t * Check if passed CSS property support specified vendor prefix \n\t * @param {String} property\n\t * @param {String} prefix\n\t */\n\tfunction hasPrefix(property, prefix) {\n\t\tvar info = vendorPrefixes[prefix];\n\t\t\n\t\tif (!info)\n\t\t\tinfo = _.find(vendorPrefixes, function(data) {\n\t\t\t\treturn data.prefix == prefix;\n\t\t\t});\n\t\t\n\t\treturn info && info.supports(property);\n\t}\n\t\n\t/**\n\t * Search for a list of supported prefixes for CSS property. This list\n\t * is used to generate all-prefixed snippet\n\t * @param {String} property CSS property name\n\t * @returns {Array}\n\t */\n\tfunction findPrefixes(property, noAutofill) {\n\t\tvar result = [];\n\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\tif (hasPrefix(property, prefix)) {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (!result.length && !noAutofill) {\n\t\t\t// add all non-obsolete prefixes\n\t\t\t_.each(vendorPrefixes, function(obj, prefix) {\n\t\t\t\tif (!obj.obsolete)\n\t\t\t\t\tresult.push(prefix);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tfunction addPrefix(name, obj) {\n\t\tif (_.isString(obj))\n\t\t\tobj = {prefix: obj};\n\t\t\n\t\tvendorPrefixes[name] = _.extend({}, prefixObj, obj);\n\t}\n\t\n\tfunction getSyntaxPreference(name, syntax) {\n\t\tif (syntax) {\n\t\t\tvar val = prefs.get(syntax + '.' + name);\n\t\t\tif (!_.isUndefined(val))\n\t\t\t\treturn val;\n\t\t}\n\t\t\n\t\treturn prefs.get('css.' + name);\n\t}\n\t\n\t/**\n\t * Format CSS property according to current syntax dialect\n\t * @param {String} property\n\t * @param {String} syntax\n\t * @returns {String}\n\t */\n\tfunction formatProperty(property, syntax) {\n\t\tvar ix = property.indexOf(':');\n\t\tproperty = property.substring(0, ix).replace(/\\s+$/, '') \n\t\t\t+ getSyntaxPreference('valueSeparator', syntax)\n\t\t\t+ require('utils').trim(property.substring(ix + 1));\n\t\t\n\t\treturn property.replace(/\\s*;\\s*$/, getSyntaxPreference('propertyEnd', syntax));\n\t}\n\t\n\t/**\n\t * Transforms snippet value if required. For example, this transformation\n\t * may add <i>!important</i> declaration to CSS property\n\t * @param {String} snippet\n\t * @param {Boolean} isImportant\n\t * @returns {String}\n\t */\n\tfunction transformSnippet(snippet, isImportant, syntax) {\n\t\tif (!_.isString(snippet))\n\t\t\tsnippet = snippet.data;\n\t\t\n\t\tif (!isSingleProperty(snippet))\n\t\t\treturn snippet;\n\t\t\n\t\tif (isImportant) {\n\t\t\tif (~snippet.indexOf(';')) {\n\t\t\t\tsnippet = snippet.split(';').join(' !important;');\n\t\t\t} else {\n\t\t\t\tsnippet += ' !important';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn formatProperty(snippet, syntax);\n\t}\n\t\n\t/**\n\t * Helper function that parses comma-separated list of elements into array\n\t * @param {String} list\n\t * @returns {Array}\n\t */\n\tfunction parseList(list) {\n\t\tvar result = _.map((list || '').split(','), require('utils').trim);\n\t\treturn result.length ? result : null;\n\t}\n\t\n\tfunction getProperties(key) {\n\t\tvar list = prefs.getArray(key);\n\t\t_.each(prefs.getArray(key + 'Addon'), function(prop) {\n\t\t\tif (prop.charAt(0) == '-') {\n\t\t\t\tlist = _.without(list, prop.substr(1));\n\t\t\t} else {\n\t\t\t\tif (prop.charAt(0) == '+')\n\t\t\t\t\tprop = prop.substr(1);\n\t\t\t\t\n\t\t\t\tlist.push(prop);\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn list;\n\t}\n\t\n\t\n\t// TODO refactor, this looks awkward now\n\taddPrefix('w', {\n\t\tprefix: 'webkit'\n\t});\n\taddPrefix('m', {\n\t\tprefix: 'moz'\n\t});\n\taddPrefix('s', {\n\t\tprefix: 'ms'\n\t});\n\taddPrefix('o', {\n\t\tprefix: 'o'\n\t});\n\t\n\t// I think nobody uses it\n//\taddPrefix('k', {\n//\t\tprefix: 'khtml',\n//\t\tobsolete: true\n//\t});\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus'];\n\t\n\t/**\n\t * XXX register resolver\n\t * @param {TreeNode} node\n\t * @param {String} syntax\n\t */\n\trequire('resources').addResolver(function(node, syntax) {\n\t\tif (_.include(cssSyntaxes, syntax) && node.isElement()) {\n\t\t\treturn module.expandToSnippet(node.abbreviation, syntax);\n\t\t}\n\t\t\n\t\treturn null;\n\t});\n\t\n\tvar ea = require('expandAbbreviation');\n\t/**\n\t * For CSS-like syntaxes, we need to handle a special use case. Some editors\n\t * (like Sublime Text 2) may insert semicolons automatically when user types\n\t * abbreviation. After expansion, user receives a double semicolon. This\n\t * handler automatically removes semicolon from generated content in such cases.\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\tea.addHandler(function(editor, syntax, profile) {\n\t\tif (!_.include(cssSyntaxes, syntax)) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tvar caretPos = editor.getSelectionRange().end;\n\t\tvar abbr = ea.findAbbreviation(editor);\n\t\t\t\n\t\tif (abbr) {\n\t\t\tvar content = emmet.expandAbbreviation(abbr, syntax, profile);\n\t\t\tif (content) {\n\t\t\t\tvar replaceFrom = caretPos - abbr.length;\n\t\t\t\tvar replaceTo = caretPos;\n\t\t\t\tif (editor.getContent().charAt(caretPos) == ';' && content.charAt(content.length - 1) == ';') {\n\t\t\t\t\treplaceTo++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\teditor.replaceContent(content, replaceFrom, replaceTo);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Adds vendor prefix\n\t\t * @param {String} name One-character prefix name\n\t\t * @param {Object} obj Object describing vendor prefix\n\t\t * @memberOf cssResolver\n\t\t */\n\t\taddPrefix: addPrefix,\n\t\t\n\t\t/**\n\t\t * Check if passed CSS property supports specified vendor prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t */\n\t\tsupportsPrefix: hasPrefix,\n\t\t\n\t\t/**\n\t\t * Returns prefixed version of passed CSS property, only if this\n\t\t * property supports such prefix\n\t\t * @param {String} property\n\t\t * @param {String} prefix\n\t\t * @returns\n\t\t */\n\t\tprefixed: function(property, prefix) {\n\t\t\treturn hasPrefix(property, prefix) \n\t\t\t\t? '-' + prefix + '-' + property \n\t\t\t\t: property;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns list of all registered vendor prefixes\n\t\t * @returns {Array}\n\t\t */\n\t\tlistPrefixes: function() {\n\t\t\treturn _.map(vendorPrefixes, function(obj) {\n\t\t\t\treturn obj.prefix;\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns object describing vendor prefix\n\t\t * @param {String} name\n\t\t * @returns {Object}\n\t\t */\n\t\tgetPrefix: function(name) {\n\t\t\treturn vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes prefix object\n\t\t * @param {String} name\n\t\t */\n\t\tremovePrefix: function(name) {\n\t\t\tif (name in vendorPrefixes)\n\t\t\t\tdelete vendorPrefixes[name];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extract vendor prefixes from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of prefixes and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractPrefixes: function(abbr) {\n\t\t\tif (abbr.charAt(0) != '-') {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tprefixes: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\t// abbreviation may either contain sequence of one-character prefixes\n\t\t\t// or just dash, meaning that user wants to produce all possible\n\t\t\t// prefixed properties\n\t\t\tvar i = 1, il = abbr.length, ch;\n\t\t\tvar prefixes = [];\n\t\t\t\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (ch == '-') {\n\t\t\t\t\t// end-sequence character found, stop searching\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (ch in vendorPrefixes) {\n\t\t\t\t\tprefixes.push(ch);\n\t\t\t\t} else {\n\t\t\t\t\t// no prefix found, meaning user want to produce all\n\t\t\t\t\t// vendor-prefixed properties\n\t\t\t\t\tprefixes.length = 0;\n\t\t\t\t\ti = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// reached end of abbreviation and no property name left\n\t\t\tif (i == il -1) {\n\t\t\t\ti = 1;\n\t\t\t\tprefixes.length = 1;\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(i),\n\t\t\t\tprefixes: prefixes.length ? prefixes : 'all'\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Search for value substring in abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {String} Value substring\n\t\t */\n\t\tfindValuesInAbbreviation: function(abbr, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\t\n\t\t\tvar i = 0, il = abbr.length, value = '', ch;\n\t\t\twhile (i < il) {\n\t\t\t\tch = abbr.charAt(i);\n\t\t\t\tif (isNumeric(ch) || ch == '#' || (ch == '-' && isNumeric(abbr.charAt(i + 1)))) {\n\t\t\t\t\tvalue = abbr.substring(i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t\n\t\t\t// try to find keywords in abbreviation\n\t\t\tvar property = abbr.substring(0, abbr.length - value.length);\n\t\t\tvar res = require('resources');\n\t\t\tvar keywords = [];\n\t\t\t// try to extract some commonly-used properties\n\t\t\twhile (~property.indexOf('-') && !res.findSnippet(syntax, property)) {\n\t\t\t\tvar parts = property.split('-');\n\t\t\t\tvar lastPart = parts.pop();\n\t\t\t\tif (!isValidKeyword(lastPart)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tkeywords.unshift(lastPart);\n\t\t\t\tproperty = parts.join('-');\n\t\t\t}\n\t\t\t\n\t\t\treturn keywords.join('-') + value;\n\t\t},\n\t\t\n\t\tparseValues: function(str) {\n\t\t\t/** @type StringStream */\n\t\t\tvar stream = require('stringStream').create(str);\n\t\t\tvar values = [];\n\t\t\tvar ch = null;\n\t\t\t\n\t\t\twhile (ch = stream.next()) {\n\t\t\t\tif (ch == '#') {\n\t\t\t\t\tstream.match(/^t|[0-9a-f]+/i, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else if (ch == '-') {\n\t\t\t\t\tif (isValidKeyword(_.last(values)) || \n\t\t\t\t\t\t\t( stream.start && isNumeric(str.charAt(stream.start - 1)) )\n\t\t\t\t\t\t) {\n\t\t\t\t\t\tstream.start = stream.pos;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstream.match(/^\\-?[0-9]*(\\.[0-9]+)?[a-z%\\.]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t} else {\n\t\t\t\t\tstream.match(/^[0-9]*(\\.[0-9]*)?[a-z%]*/, true);\n\t\t\t\t\tvalues.push(stream.current());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstream.start = stream.pos;\n\t\t\t}\n\t\t\t\n\t\t\treturn _.map(_.compact(values), normalizeValue);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Extracts values from abbreviation\n\t\t * @param {String} abbr\n\t\t * @returns {Object} Object containing array of values and clean \n\t\t * abbreviation name\n\t\t */\n\t\textractValues: function(abbr) {\n\t\t\t// search for value start\n\t\t\tvar abbrValues = this.findValuesInAbbreviation(abbr);\n\t\t\tif (!abbrValues) {\n\t\t\t\treturn {\n\t\t\t\t\tproperty: abbr,\n\t\t\t\t\tvalues: null\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\treturn {\n\t\t\t\tproperty: abbr.substring(0, abbr.length - abbrValues.length).replace(/-$/, ''),\n\t\t\t\tvalues: this.parseValues(abbrValues)\n\t\t\t};\n\t\t},\n\t\t\n\t\t/**\n\t\t * Normalizes value, defined in abbreviation.\n\t\t * @param {String} value\n\t\t * @param {String} property\n\t\t * @returns {String}\n\t\t */\n\t\tnormalizeValue: function(value, property) {\n\t\t\tproperty = (property || '').toLowerCase();\n\t\t\tvar unitlessProps = prefs.getArray('css.unitlessProperties');\n\t\t\treturn value.replace(/^(\\-?[0-9\\.]+)([a-z]*)$/, function(str, val, unit) {\n\t\t\t\tif (!unit && (val == '0' || _.include(unitlessProps, property)))\n\t\t\t\t\treturn val;\n\t\t\t\t\n\t\t\t\tif (!unit)\n\t\t\t\t\treturn val.replace(/\\.$/, '') + prefs.get(~val.indexOf('.') ? 'css.floatUnit' : 'css.intUnit');\n\t\t\t\t\n\t\t\t\treturn val + getUnit(unit);\n\t\t\t});\n\t\t},\n\t\t\n\t\t/**\n\t\t * Expands abbreviation into a snippet\n\t\t * @param {String} abbr Abbreviation name to expand\n\t\t * @param {String} value Abbreviation value\n\t\t * @param {String} syntax Currect syntax or dialect. Default is 'css'\n\t\t * @returns {Object} Array of CSS properties and values or predefined\n\t\t * snippet (string or element)\n\t\t */\n\t\texpand: function(abbr, value, syntax) {\n\t\t\tsyntax = syntax || 'css';\n\t\t\tvar resources = require('resources');\n\t\t\tvar autoInsertPrefixes = prefs.get('css.autoInsertVendorPrefixes');\n\t\t\t\n\t\t\t// check if snippet should be transformed to !important\n\t\t\tvar isImportant;\n\t\t\tif (isImportant = /^(.+)\\!$/.test(abbr)) {\n\t\t\t\tabbr = RegExp.$1;\n\t\t\t}\n\t\t\t\n\t\t\t// check if we have abbreviated resource\n\t\t\tvar snippet = resources.findSnippet(syntax, abbr);\n\t\t\tif (snippet && !autoInsertPrefixes) {\n\t\t\t\treturn transformSnippet(snippet, isImportant, syntax);\n\t\t\t}\n\t\t\t\n\t\t\t// no abbreviated resource, parse abbreviation\n\t\t\tvar prefixData = this.extractPrefixes(abbr);\n\t\t\tvar valuesData = this.extractValues(prefixData.property);\n\t\t\tvar abbrData = _.extend(prefixData, valuesData);\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = resources.findSnippet(syntax, abbrData.property);\n\t\t\t} else {\n\t\t\t\tabbrData.values = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\t\t// lets try fuzzy search\n\t\t\t\tsnippet = resources.fuzzyFindSnippet(syntax, abbrData.property, parseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t\t}\n\t\t\t\n\t\t\tif (!snippet) {\n\t\t\t\tsnippet = abbrData.property + ':' + defaultValue;\n\t\t\t} else if (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\tif (!isSingleProperty(snippet)) {\n\t\t\t\treturn snippet;\n\t\t\t}\n\t\t\t\n\t\t\tvar snippetObj = this.splitSnippet(snippet);\n\t\t\tvar result = [];\n\t\t\tif (!value && abbrData.values) {\n\t\t\t\tvalue = _.map(abbrData.values, function(val) {\n\t\t\t\t\treturn this.normalizeValue(val, snippetObj.name);\n\t\t\t\t}, this).join(' ') + ';';\n\t\t\t}\n\t\t\t\n\t\t\tsnippetObj.value = value || snippetObj.value;\n\t\t\t\n\t\t\tvar prefixes = abbrData.prefixes == 'all' || (!abbrData.prefixes && autoInsertPrefixes) \n\t\t\t\t? findPrefixes(snippetObj.name, autoInsertPrefixes && abbrData.prefixes != 'all')\n\t\t\t\t: abbrData.prefixes;\n\t\t\t\t\n\t\t\t\t\n\t\t\tvar names = [], propName;\n\t\t\t_.each(prefixes, function(p) {\n\t\t\t\tif (p in vendorPrefixes) {\n\t\t\t\t\tpropName = vendorPrefixes[p].transformName(snippetObj.name);\n\t\t\t\t\tnames.push(propName);\n\t\t\t\t\tresult.push(transformSnippet(propName + ':' + snippetObj.value,\n\t\t\t\t\t\t\tisImportant, syntax));\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t// put the original property\n\t\t\tresult.push(transformSnippet(snippetObj.name + ':' + snippetObj.value, isImportant, syntax));\n\t\t\tnames.push(snippetObj.name);\n\t\t\t\n\t\t\tif (prefs.get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(names);\n\t\t\t\tresult = _.map(result, function(prop, i) {\n\t\t\t\t\treturn pads[i] + prop;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Same as <code>expand</code> method but transforms output into \n\t\t * Emmet snippet\n\t\t * @param {String} abbr\n\t\t * @param {String} syntax\n\t\t * @returns {String}\n\t\t */\n\t\texpandToSnippet: function(abbr, syntax) {\n\t\t\tvar snippet = this.expand(abbr, null, syntax);\n\t\t\tif (_.isArray(snippet)) {\n\t\t\t\treturn snippet.join('\\n');\n\t\t\t}\n\t\t\t\n\t\t\tif (!_.isString(snippet))\n\t\t\t\treturn snippet.data;\n\t\t\t\n\t\t\treturn String(snippet);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Split snippet into a CSS property-value pair\n\t\t * @param {String} snippet\n\t\t */\n\t\tsplitSnippet: function(snippet) {\n\t\t\tvar utils = require('utils');\n\t\t\tsnippet = utils.trim(snippet);\n\t\t\tif (snippet.indexOf(':') == -1) {\n\t\t\t\treturn {\n\t\t\t\t\tname: snippet,\n\t\t\t\t\tvalue: defaultValue\n\t\t\t\t};\n\t\t\t}\n\t\t\t\n\t\t\tvar pair = snippet.split(':');\n\t\t\t\n\t\t\treturn {\n\t\t\t\tname: utils.trim(pair.shift()),\n\t\t\t\t// replace ${0} tabstop to produce valid vendor-prefixed values\n\t\t\t\t// where possible\n\t\t\t\tvalue: utils.trim(pair.join(':')).replace(/^(\\$\\{0\\}|\\$0)(\\s*;?)$/, '${1}$2')\n\t\t\t};\n\t\t},\n\t\t\n\t\tgetSyntaxPreference: getSyntaxPreference,\n\t\ttransformSnippet: transformSnippet\n\t};\n});\n/**\n * 'Expand Abbreviation' handler that parses gradient definition from under \n * cursor and updates CSS rule with vendor-prefixed values.\n * \n * @memberOf __cssGradientHandlerDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('cssGradient', function(require, _) {\n\tvar defaultLinearDirections = ['top', 'to bottom', '0deg'];\n\t/** Back-reference to current module */\n\tvar module = null;\n\t\n\tvar cssSyntaxes = ['css', 'less', 'sass', 'scss', 'stylus', 'styl'];\n\t\n\tvar reDeg = /\\d+deg/i;\n\tvar reKeyword = /top|bottom|left|right/i;\n\t\n\t// XXX define preferences\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('css.gradient.prefixes', 'webkit, moz, o',\n\t\t\t'A comma-separated list of vendor-prefixes for which values should ' \n\t\t\t+ 'be generated.');\n\t\n\tprefs.define('css.gradient.oldWebkit', true,\n\t\t\t'Generate gradient definition for old Webkit implementations');\n\t\n\tprefs.define('css.gradient.omitDefaultDirection', true,\n\t\t'Do not output default direction definition in generated gradients.');\n\t\n\tprefs.define('css.gradient.defaultProperty', 'background-image',\n\t\t'When gradient expanded outside CSS value context, it will produce '\n\t\t\t+ 'properties with this name.');\n\t\n\tprefs.define('css.gradient.fallback', false,\n\t\t\t'With this option enabled, CSS gradient generator will produce '\n\t\t\t+ '<code>background-color</code> property with gradient first color '\n\t\t\t+ 'as fallback for old browsers.');\n\t\n\tfunction normalizeSpace(str) {\n\t\treturn require('utils').trim(str).replace(/\\s+/g, ' ');\n\t}\n\t\n\t/**\n\t * Parses linear gradient definition\n\t * @param {String}\n\t */\n\tfunction parseLinearGradient(gradient) {\n\t\tvar direction = defaultLinearDirections[0];\n\t\t\n\t\t// extract tokens\n\t\t/** @type StringStream */\n\t\tvar stream = require('stringStream').create(require('utils').trim(gradient));\n\t\tvar colorStops = [], ch;\n\t\twhile (ch = stream.next()) {\n\t\t\tif (stream.peek() == ',') {\n\t\t\t\tcolorStops.push(stream.current());\n\t\t\t\tstream.next();\n\t\t\t\tstream.eatSpace();\n\t\t\t\tstream.start = stream.pos;\n\t\t\t} else if (ch == '(') { // color definition, like 'rgb(0,0,0)'\n\t\t\t\tstream.skipTo(')');\n\t\t\t}\n\t\t}\n\t\t\n\t\t// add last token\n\t\tcolorStops.push(stream.current());\n\t\tcolorStops = _.compact(_.map(colorStops, normalizeSpace));\n\t\t\n\t\tif (!colorStops.length)\n\t\t\treturn null;\n\t\t\n\t\t// let's see if the first color stop is actually a direction\n\t\tif (reDeg.test(colorStops[0]) || reKeyword.test(colorStops[0])) {\n\t\t\tdirection = colorStops.shift();\n\t\t}\n\t\t\n\t\treturn {\n\t\t\ttype: 'linear',\n\t\t\tdirection: direction,\n\t\t\tcolorStops: _.map(colorStops, parseColorStop)\n\t\t};\n\t}\n\t\n\t/**\n\t * Parses color stop definition\n\t * @param {String} colorStop\n\t * @returns {Object}\n\t */\n\tfunction parseColorStop(colorStop) {\n\t\tcolorStop = normalizeSpace(colorStop);\n\t\t\n\t\t// find color declaration\n\t\t// first, try complex color declaration, like rgb(0,0,0)\n\t\tvar color = null;\n\t\tcolorStop = colorStop.replace(/^(\\w+\\(.+?\\))\\s*/, function(str, c) {\n\t\t\tcolor = c;\n\t\t\treturn '';\n\t\t});\n\t\t\n\t\tif (!color) {\n\t\t\t// try simple declaration, like yellow, #fco, #ffffff, etc.\n\t\t\tvar parts = colorStop.split(' ');\n\t\t\tcolor = parts[0];\n\t\t\tcolorStop = parts[1] || '';\n\t\t}\n\t\t\n\t\tvar result = {\n\t\t\tcolor: color\n\t\t};\n\t\t\n\t\tif (colorStop) {\n\t\t\t// there's position in color stop definition\n\t\t\tcolorStop.replace(/^(\\-?[\\d\\.]+)([a-z%]+)?$/, function(str, pos, unit) {\n\t\t\t\tresult.position = pos;\n\t\t\t\tif (~pos.indexOf('.')) {\n\t\t\t\t\tunit = '';\n\t\t\t\t} else if (!unit) {\n\t\t\t\t\tunit = '%';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (unit)\n\t\t\t\t\tresult.unit = unit;\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Resolves property name (abbreviation): searches for snippet definition in \n\t * 'resources' and returns new name of matched property\n\t */\n\tfunction resolvePropertyName(name, syntax) {\n\t\tvar res = require('resources');\n\t\tvar prefs = require('preferences');\n\t\tvar snippet = res.findSnippet(syntax, name);\n\t\t\n\t\tif (!snippet && prefs.get('css.fuzzySearch')) {\n\t\t\tsnippet = res.fuzzyFindSnippet(syntax, name, \n\t\t\t\t\tparseFloat(prefs.get('css.fuzzySearchMinScore')));\n\t\t}\n\t\t\n\t\tif (snippet) {\n\t\t\tif (!_.isString(snippet)) {\n\t\t\t\tsnippet = snippet.data;\n\t\t\t}\n\t\t\t\n\t\t\treturn require('cssResolver').splitSnippet(snippet).name;\n\t\t}\n\t}\n\t\n\t/**\n\t * Fills-out implied positions in color-stops. This function is useful for\n\t * old Webkit gradient definitions\n\t */\n\tfunction fillImpliedPositions(colorStops) {\n\t\tvar from = 0;\n\t\t\n\t\t_.each(colorStops, function(cs, i) {\n\t\t\t// make sure that first and last positions are defined\n\t\t\tif (!i)\n\t\t\t\treturn cs.position = cs.position || 0;\n\t\t\t\n\t\t\tif (i == colorStops.length - 1 && !('position' in cs))\n\t\t\t\tcs.position = 1;\n\t\t\t\n\t\t\tif ('position' in cs) {\n\t\t\t\tvar start = colorStops[from].position || 0;\n\t\t\t\tvar step = (cs.position - start) / (i - from);\n\t\t\t\t_.each(colorStops.slice(from, i), function(cs2, j) {\n\t\t\t\t\tcs2.position = start + step * j;\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tfrom = i;\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Returns textual version of direction expressed in degrees\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction textualDirection(direction) {\n\t\tvar angle = parseFloat(direction);\n\t\t\n\t\tif(!_.isNaN(angle)) {\n\t\t\tswitch(angle % 360) {\n\t\t\t\tcase 0:   return 'left';\n\t\t\t\tcase 90:  return 'bottom';\n\t\t\t\tcase 180: return 'right';\n\t\t\t\tcase 240: return 'top';\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn direction;\n\t}\n\t\n\t/**\n\t * Creates direction definition for old Webkit gradients\n\t * @param {String} direction\n\t * @returns {String}\n\t */\n\tfunction oldWebkitDirection(direction) {\n\t\tdirection = textualDirection(direction);\n\t\t\n\t\tif(reDeg.test(direction))\n\t\t\tthrow \"The direction is an angle that cant be converted.\";\n\t\t\n\t\tvar v = function(pos) {\n\t\t\treturn ~direction.indexOf(pos) ? '100%' : '0';\n\t\t};\n\t\t\n\t\treturn v('right') + ' ' + v('bottom') + ', ' + v('left') + ' ' + v('top');\n\t}\n\t\n\tfunction getPrefixedNames(name) {\n\t\tvar prefixes = prefs.getArray('css.gradient.prefixes');\n\t\tvar names = prefixes \n\t\t\t? _.map(prefixes, function(p) {\n\t\t\t\treturn '-' + p + '-' + name;\n\t\t\t}) \n\t\t\t: [];\n\t\t\n\t\tnames.push(name);\n\t\t\n\t\treturn names;\n\t}\n\t\n\t/**\n\t * Returns list of CSS properties with gradient\n\t * @param {Object} gradient\n\t * @param {String} propertyName Original CSS property name\n\t * @returns {Array}\n\t */\n\tfunction getPropertiesForGradient(gradient, propertyName) {\n\t\tvar props = [];\n\t\tvar css = require('cssResolver');\n\t\t\n\t\tif (prefs.get('css.gradient.fallback') && ~propertyName.toLowerCase().indexOf('background')) {\n\t\t\tprops.push({\n\t\t\t\tname: 'background-color',\n\t\t\t\tvalue: '${1:' + gradient.colorStops[0].color + '}'\n\t\t\t});\n\t\t}\n\t\t\n\t\t_.each(prefs.getArray('css.gradient.prefixes'), function(prefix) {\n\t\t\tvar name = css.prefixed(propertyName, prefix);\n\t\t\tif (prefix == 'webkit' && prefs.get('css.gradient.oldWebkit')) {\n\t\t\t\ttry {\n\t\t\t\t\tprops.push({\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\tvalue: module.oldWebkitLinearGradient(gradient)\n\t\t\t\t\t});\n\t\t\t\t} catch(e) {}\n\t\t\t}\n\t\t\t\n\t\t\tprops.push({\n\t\t\t\tname: name,\n\t\t\t\tvalue: module.toString(gradient, prefix)\n\t\t\t});\n\t\t});\n\t\t\n\t\treturn props.sort(function(a, b) {\n\t\t\treturn b.name.length - a.name.length;\n\t\t});\n\t}\n\t\n\t/**\n\t * Pastes gradient definition into CSS rule with correct vendor-prefixes\n\t * @param {EditElement} property Matched CSS property\n\t * @param {Object} gradient Parsed gradient\n\t * @param {Range} valueRange If passed, only this range within property \n\t * value will be replaced with gradient. Otherwise, full value will be \n\t * replaced\n\t */\n\tfunction pasteGradient(property, gradient, valueRange) {\n\t\tvar rule = property.parent;\n\t\tvar utils = require('utils');\n\t\tvar alignVendor = require('preferences').get('css.alignVendor');\n\t\t\n\t\t// we may have aligned gradient definitions: find the smallest value\n\t\t// separator\n\t\tvar sep = property.styleSeparator;\n\t\tvar before = property.styleBefore;\n\t\t\n\t\t// first, remove all properties within CSS rule with the same name and\n\t\t// gradient definition\n\t\t_.each(rule.getAll(getPrefixedNames(property.name())), function(item) {\n\t\t\tif (item != property && /gradient/i.test(item.value())) {\n\t\t\t\tif (item.styleSeparator.length < sep.length) {\n\t\t\t\t\tsep = item.styleSeparator;\n\t\t\t\t}\n\t\t\t\tif (item.styleBefore.length < before.length) {\n\t\t\t\t\tbefore = item.styleBefore;\n\t\t\t\t}\n\t\t\t\trule.remove(item);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (alignVendor) {\n\t\t\t// update prefix\n\t\t\tif (before != property.styleBefore) {\n\t\t\t\tvar fullRange = property.fullRange();\n\t\t\t\trule._updateSource(before, fullRange.start, fullRange.start + property.styleBefore.length);\n\t\t\t\tproperty.styleBefore = before;\n\t\t\t}\n\t\t\t\n\t\t\t// update separator value\n\t\t\tif (sep != property.styleSeparator) {\n\t\t\t\trule._updateSource(sep, property.nameRange().end, property.valueRange().start);\n\t\t\t\tproperty.styleSeparator = sep;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar value = property.value();\n\t\tif (!valueRange)\n\t\t\tvalueRange = require('range').create(0, property.value());\n\t\t\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, valueRange);\n\t\t};\n\t\t\n\t\t// put vanilla-clean gradient definition into current rule\n\t\tproperty.value(val(module.toString(gradient)) + '${2}');\n\t\t\n\t\t// create list of properties to insert\n\t\tvar propsToInsert = getPropertiesForGradient(gradient, property.name());\n\t\t\n\t\t// align prefixed values\n\t\tif (alignVendor) {\n\t\t\tvar values = _.pluck(propsToInsert, 'value');\n\t\t\tvar names = _.pluck(propsToInsert, 'name');\n\t\t\tvalues.push(property.value());\n\t\t\tnames.push(property.name());\n\t\t\t\n\t\t\tvar valuePads = utils.getStringsPads(_.map(values, function(v) {\n\t\t\t\treturn v.substring(0, v.indexOf('('));\n\t\t\t}));\n\t\t\t\n\t\t\tvar namePads = utils.getStringsPads(names);\n\t\t\tproperty.name(_.last(namePads) + property.name());\n\t\t\t\n\t\t\t_.each(propsToInsert, function(prop, i) {\n\t\t\t\tprop.name = namePads[i] + prop.name;\n\t\t\t\tprop.value = valuePads[i] + prop.value;\n\t\t\t});\n\t\t\t\n\t\t\tproperty.value(_.last(valuePads) + property.value());\n\t\t}\n\t\t\n\t\t// put vendor-prefixed definitions before current rule\n\t\t_.each(propsToInsert, function(prop) {\n\t\t\trule.add(prop.name, prop.value, rule.indexOf(property));\n\t\t});\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS property value\n\t */\n\tfunction findGradient(cssProp) {\n\t\tvar value = cssProp.value();\n\t\tvar gradient = null;\n\t\tvar matchedPart = _.find(cssProp.valueParts(), function(part) {\n\t\t\treturn gradient = module.parse(part.substring(value));\n\t\t});\n\t\t\n\t\tif (matchedPart && gradient) {\n\t\t\treturn {\n\t\t\t\tgradient: gradient,\n\t\t\t\tvalueRange: matchedPart\n\t\t\t};\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Tries to expand gradient outside CSS value \n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t */\n\tfunction expandGradientOutsideValue(editor, syntax) {\n\t\tvar propertyName = prefs.get('css.gradient.defaultProperty');\n\t\t\n\t\tif (!propertyName)\n\t\t\treturn false;\n\t\t\n\t\t// assuming that gradient definition is written on new line,\n\t\t// do a simplified parsing\n\t\tvar content = String(editor.getContent());\n\t\t/** @type Range */\n\t\tvar lineRange = require('range').create(editor.getCurrentLineRange());\n\t\t\n\t\t// get line content and adjust range with padding\n\t\tvar line = lineRange.substring(content)\n\t\t\t.replace(/^\\s+/, function(pad) {\n\t\t\t\tlineRange.start += pad.length;\n\t\t\t\treturn '';\n\t\t\t})\n\t\t\t.replace(/\\s+$/, function(pad) {\n\t\t\t\tlineRange.end -= pad.length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\n\t\tvar css = require('cssResolver');\n\t\tvar gradient = module.parse(line);\n\t\tif (gradient) {\n\t\t\tvar props = getPropertiesForGradient(gradient, propertyName);\n\t\t\tprops.push({\n\t\t\t\tname: propertyName,\n\t\t\t\tvalue: module.toString(gradient) + '${2}'\n\t\t\t});\n\t\t\t\n\t\t\tvar sep = css.getSyntaxPreference('valueSeparator', syntax);\n\t\t\tvar end = css.getSyntaxPreference('propertyEnd', syntax);\n\t\t\t\n\t\t\tif (require('preferences').get('css.alignVendor')) {\n\t\t\t\tvar pads = require('utils').getStringsPads(_.map(props, function(prop) {\n\t\t\t\t\treturn prop.value.substring(0, prop.value.indexOf('('));\n\t\t\t\t}));\n\t\t\t\t_.each(props, function(prop, i) {\n\t\t\t\t\tprop.value = pads[i] + prop.value;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t\tprops = _.map(props, function(item) {\n\t\t\t\treturn item.name + sep + item.value + end;\n\t\t\t});\n\t\t\t\n\t\t\teditor.replaceContent(props.join('\\n'), lineRange.start, lineRange.end);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Search for gradient definition inside CSS value under cursor\n\t * @param {String} content\n\t * @param {Number} pos\n\t * @returns {Object}\n\t */\n\tfunction findGradientFromPosition(content, pos) {\n\t\tvar cssProp = null;\n\t\t/** @type EditContainer */\n\t\tvar cssRule = require('cssEditTree').parseFromPosition(content, pos, true);\n\t\t\n\t\tif (cssRule) {\n\t\t\tcssProp = cssRule.itemFromPosition(pos, true);\n\t\t\tif (!cssProp) {\n\t\t\t\t// in case user just started writing CSS property\n\t\t\t\t// and didn't include semicolontry another approach\n\t\t\t\tcssProp = _.find(cssRule.list(), function(elem) {\n\t\t\t\t\treturn elem.range(true).end == pos;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn {\n\t\t\trule: cssRule,\n\t\t\tproperty: cssProp\n\t\t};\n\t}\n\t\n\t// XXX register expand abbreviation handler\n\t/**\n\t * @param {IEmmetEditor} editor\n\t * @param {String} syntax\n\t * @param {String} profile\n\t */\n\trequire('expandAbbreviation').addHandler(function(editor, syntax, profile) {\n\t\tvar info = require('editorUtils').outputInfo(editor, syntax, profile);\n\t\tif (!_.include(cssSyntaxes, info.syntax))\n\t\t\treturn false;\n\t\t\n\t\t// let's see if we are expanding gradient definition\n\t\tvar caret = editor.getCaretPos();\n\t\tvar content = info.content;\n\t\tvar css = findGradientFromPosition(content, caret);\n\t\t\n\t\tif (css.property) {\n\t\t\t// make sure that caret is inside property value with gradient \n\t\t\t// definition\n\t\t\tvar g = findGradient(css.property);\n\t\t\tif (g) {\n\t\t\t\tvar ruleStart = css.rule.options.offset || 0;\n\t\t\t\tvar ruleEnd = ruleStart + css.rule.toString().length;\n\t\t\t\t\n\t\t\t\t// Handle special case:\n\t\t\t\t// user wrote gradient definition between existing CSS \n\t\t\t\t// properties and did not finished it with semicolon.\n\t\t\t\t// In this case, we have semicolon right after gradient \n\t\t\t\t// definition and re-parse rule again\n\t\t\t\tif (/[\\n\\r]/.test(css.property.value())) {\n\t\t\t\t\t// insert semicolon at the end of gradient definition\n\t\t\t\t\tvar insertPos = css.property.valueRange(true).start + g.valueRange.end;\n\t\t\t\t\tcontent = require('utils').replaceSubstring(content, ';', insertPos);\n\t\t\t\t\tvar newCss = findGradientFromPosition(content, caret);\n\t\t\t\t\tif (newCss.property) {\n\t\t\t\t\t\tg = findGradient(newCss.property);\n\t\t\t\t\t\tcss = newCss;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// make sure current property has terminating semicolon\n\t\t\t\tcss.property.end(';');\n\t\t\t\t\n\t\t\t\t// resolve CSS property name\n\t\t\t\tvar resolvedName = resolvePropertyName(css.property.name(), syntax);\n\t\t\t\tif (resolvedName) {\n\t\t\t\t\tcss.property.name(resolvedName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpasteGradient(css.property, g.gradient, g.valueRange);\n\t\t\t\teditor.replaceContent(css.rule.toString(), ruleStart, ruleEnd, true);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn expandGradientOutsideValue(editor, syntax);\n\t});\n\t\n\t// XXX register \"Reflect CSS Value\" action delegate\n\t/**\n\t * @param {EditElement} property\n\t */\n\trequire('reflectCSSValue').addHandler(function(property) {\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar g = findGradient(property);\n\t\tif (!g)\n\t\t\treturn false;\n\t\t\n\t\tvar value = property.value();\n\t\tvar val = function(v) {\n\t\t\treturn utils.replaceSubstring(value, v, g.valueRange);\n\t\t};\n\t\t\n\t\t// reflect value for properties with the same name\n\t\t_.each(property.parent.getAll(getPrefixedNames(property.name())), function(prop) {\n\t\t\tif (prop === property)\n\t\t\t\treturn;\n\t\t\t\n\t\t\t// check if property value starts with gradient definition\n\t\t\tvar m = prop.value().match(/^\\s*(\\-([a-z]+)\\-)?linear\\-gradient/);\n\t\t\tif (m) {\n\t\t\t\tprop.value(val(module.toString(g.gradient, m[2] || '')));\n\t\t\t} else if (m = prop.value().match(/\\s*\\-webkit\\-gradient/)) {\n\t\t\t\t// old webkit gradient definition\n\t\t\t\tprop.value(val(module.oldWebkitLinearGradient(g.gradient)));\n\t\t\t}\n\t\t});\n\t\t\n\t\treturn true;\n\t});\n\t\n\treturn module = {\n\t\t/**\n\t\t * Parses gradient definition\n\t\t * @param {String} gradient\n\t\t * @returns {Object}\n\t\t */\n\t\tparse: function(gradient) {\n\t\t\tvar result = null;\n\t\t\trequire('utils').trim(gradient).replace(/^([\\w\\-]+)\\((.+?)\\)$/, function(str, type, definition) {\n\t\t\t\t// remove vendor prefix\n\t\t\t\ttype = type.toLowerCase().replace(/^\\-[a-z]+\\-/, '');\n\t\t\t\tif (type == 'linear-gradient' || type == 'lg') {\n\t\t\t\t\tresult = parseLinearGradient(definition);\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn str;\n\t\t\t});\n\t\t\t\n\t\t\treturn result;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Produces linear gradient definition used in early Webkit \n\t\t * implementations\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @returns {String}\n\t\t */\n\t\toldWebkitLinearGradient: function(gradient) {\n\t\t\tif (_.isString(gradient))\n\t\t\t\tgradient = this.parse(gradient);\n\t\t\t\n\t\t\tif (!gradient)\n\t\t\t\treturn null;\n\t\t\t\n\t\t\tvar colorStops = _.map(gradient.colorStops, _.clone);\n\t\t\t\n\t\t\t// normalize color-stops position\n\t\t\t_.each(colorStops, function(cs) {\n\t\t\t\tif (!('position' in cs)) // implied position\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tif (~cs.position.indexOf('.') || cs.unit == '%') {\n\t\t\t\t\tcs.position = parseFloat(cs.position) / (cs.unit == '%' ? 100 : 1);\n\t\t\t\t} else {\n\t\t\t\t\tthrow \"Can't convert color stop '\" + (cs.position + (cs.unit || '')) + \"'\";\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tfillImpliedPositions(colorStops);\n\t\t\t\n\t\t\t// transform color-stops into string representation\n\t\t\tcolorStops = _.map(colorStops, function(cs, i) {\n\t\t\t\tif (!cs.position && !i)\n\t\t\t\t\treturn 'from(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\tif (cs.position == 1 && i == colorStops.length - 1)\n\t\t\t\t\treturn 'to(' + cs.color + ')';\n\t\t\t\t\n\t\t\t\treturn 'color-stop(' + (cs.position.toFixed(2).replace(/\\.?0+$/, '')) + ', ' + cs.color + ')';\n\t\t\t});\n\t\t\t\n\t\t\treturn '-webkit-gradient(linear, ' \n\t\t\t\t+ oldWebkitDirection(gradient.direction)\n\t\t\t\t+ ', '\n\t\t\t\t+ colorStops.join(', ')\n\t\t\t\t+ ')';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns string representation of parsed gradient\n\t\t * @param {Object} gradient Parsed gradient\n\t\t * @param {String} prefix Vendor prefix\n\t\t * @returns {String}\n\t\t */\n\t\ttoString: function(gradient, prefix) {\n\t\t\tif (gradient.type == 'linear') {\n\t\t\t\tvar fn = (prefix ? '-' + prefix + '-' : '') + 'linear-gradient';\n\t\t\t\t\n\t\t\t\t// transform color-stops\n\t\t\t\tvar colorStops = _.map(gradient.colorStops, function(cs) {\n\t\t\t\t\treturn cs.color + ('position' in cs \n\t\t\t\t\t\t\t? ' ' + cs.position + (cs.unit || '')\n\t\t\t\t\t\t\t: '');\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (gradient.direction \n\t\t\t\t\t\t&& (!prefs.get('css.gradient.omitDefaultDirection') \n\t\t\t\t\t\t|| !_.include(defaultLinearDirections, gradient.direction))) {\n\t\t\t\t\tcolorStops.unshift(gradient.direction);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn fn + '(' + colorStops.join(', ') + ')';\n\t\t\t}\n\t\t}\n\t};\n});/**\n * Module adds support for generators: a regexp-based abbreviation resolver \n * that can produce custom output.\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/** @type HandlerList */\n\tvar generators = require('handlerList').create();\n\tvar resources = require('resources');\n\t\n\t_.extend(resources, {\n\t\t/**\n\t\t * Add generator. A generator function <code>fn</code> will be called \n\t\t * only if current abbreviation matches <code>regexp</code> regular \n\t\t * expression and this function should return <code>null</code> if\n\t\t * abbreviation cannot be resolved\n\t\t * @param {RegExp} regexp Regular expression for abbreviation element name\n\t\t * @param {Function} fn Resolver function\n\t\t * @param {Object} options Options list as described in \n\t\t * {@link HandlerList#add()} method\n\t\t */\n\t\taddGenerator: function(regexp, fn, options) {\n\t\t\tif (_.isString(regexp))\n\t\t\t\tregexp = new RegExp(regexp);\n\t\t\t\n\t\t\tgenerators.add(function(node, syntax) {\n\t\t\t\tvar m;\n\t\t\t\tif ((m = regexp.exec(node.name()))) {\n\t\t\t\t\treturn fn(m, node, syntax);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn null;\n\t\t\t}, options);\n\t\t}\n\t});\n\t\n\tresources.addResolver(function(node, syntax) {\n\t\treturn generators.exec(null, _.toArray(arguments));\n\t});\n});/**\n * Module for resolving tag names: returns best matched tag name for child\n * element based on passed parent's tag name. Also provides utility function\n * for element type detection (inline, block-level, empty)\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.define('tagName', function(require, _) {\n\tvar elementTypes = {\n//\t\tempty: 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command'.split(','),\n\t\tempty: [],\n\t\tblockLevel: 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6'.split(','),\n\t\tinlineLevel: 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'.split(',')\n\t};\n\t\n\tvar elementMap = {\n\t\t'p': 'span',\n\t\t'ul': 'li',\n\t\t'ol': 'li',\n\t\t'table': 'tr',\n\t\t'tr': 'td',\n\t\t'tbody': 'tr',\n\t\t'thead': 'tr',\n\t\t'tfoot': 'tr',\n\t\t'colgroup': 'col',\n\t\t'select': 'option',\n\t\t'optgroup': 'option',\n\t\t'audio': 'source',\n\t\t'video': 'source',\n\t\t'object': 'param',\n\t\t'map': 'area'\n\t};\n\t\n\treturn {\n\t\t/**\n\t\t * Returns best matched child element name for passed parent's\n\t\t * tag name\n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t * @memberOf tagName\n\t\t */\n\t\tresolve: function(name) {\n\t\t\tname = (name || '').toLowerCase();\n\t\t\t\n\t\t\tif (name in elementMap)\n\t\t\t\treturn this.getMapping(name);\n\t\t\t\n\t\t\tif (this.isInlineLevel(name))\n\t\t\t\treturn 'span';\n\t\t\t\n\t\t\treturn 'div';\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns mapped child element name for passed parent's name \n\t\t * @param {String} name\n\t\t * @returns {String}\n\t\t */\n\t\tgetMapping: function(name) {\n\t\t\treturn elementMap[name.toLowerCase()];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element name belongs to inline-level element\n\t\t * @param {String} name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisInlineLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'inlineLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element belongs to block-level element.\n\t\t * For better matching of unknown elements (for XML, for example), \n\t\t * you should use <code>!this.isInlineLevel(name)</code>\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisBlockLevel: function(name) {\n\t\t\treturn this.isTypeOf(name, 'blockLevel');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Check if passed element is void (i.e. should not have closing tag).\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisEmptyElement: function(name) {\n\t\t\treturn this.isTypeOf(name, 'empty');\n\t\t},\n\t\t\n\t\t/**\n\t\t * Generic function for testing if element name belongs to specified\n\t\t * elements collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} type Collection name\n\t\t * @returns {Boolean}\n\t\t */\n\t\tisTypeOf: function(name, type) {\n\t\t\treturn _.include(elementTypes[type], name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new parentchild mapping\n\t\t * @param {String} parent\n\t\t * @param {String} child\n\t\t */\n\t\taddMapping: function(parent, child) {\n\t\t\telementMap[parent] = child;\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes parent-child mapping\n\t\t */\n\t\tremoveMapping: function(parent) {\n\t\t\tif (parent in elementMap)\n\t\t\t\tdelete elementMap[parent];\n\t\t},\n\t\t\n\t\t/**\n\t\t * Adds new element into collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t */\n\t\taddElementToCollection: function(name, collection) {\n\t\t\tif (!elementTypes[collection])\n\t\t\t\telementTypes[collection] = [];\n\t\t\t\n\t\t\tvar col = this.getCollection(collection);\n\t\t\tif (!_.include(col, name))\n\t\t\t\tcol.push(name);\n\t\t},\n\t\t\n\t\t/**\n\t\t * Removes element name from specified collection\n\t\t * @param {String} name Element name\n\t\t * @param {String} collection Collection name\n\t\t * @returns\n\t\t */\n\t\tremoveElementFromCollection: function(name, collection) {\n\t\t\tif (collection in elementTypes) {\n\t\t\t\telementTypes[collection] = _.without(this.getCollection(collection), name);\n\t\t\t}\n\t\t},\n\t\t\n\t\t/**\n\t\t * Returns elements name collection\n\t\t * @param {String} name Collection name\n\t\t * @returns {Array}\n\t\t */\n\t\tgetCollection: function(name) {\n\t\t\treturn elementTypes[name];\n\t\t}\n\t};\n});/**\n * Filter for aiding of writing elements with complex class names as described\n * in Yandex's BEM (Block, Element, Modifier) methodology. This filter will\n * automatically inherit block and element names from parent elements and insert\n * them into child element classes\n * @memberOf __bemFilterDefine\n * @constructor\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar prefs = require('preferences');\n\tprefs.define('bem.elementSeparator', '__', 'Class names element separator.');\n\tprefs.define('bem.modifierSeparator', '_', 'Class names modifier separator.');\n\tprefs.define('bem.shortElementPrefix', '-', \n\t\t\t'Symbol for describing short block-element notation. Class names '\n\t\t\t+ 'prefixed with this symbol will be treated as element name for parents '\n\t\t\t+ 'block name. Each symbol instance traverses one level up in parsed ' \n\t\t\t+ 'tree for block name lookup. Empty value will disable short notation.');\n\t\n\tvar shouldRunHtmlFilter = false;\n\t\n\tfunction getSeparators() {\n\t\treturn {\n\t\t\telement: prefs.get('bem.elementSeparator'),\n\t\t\tmodifier: prefs.get('bem.modifierSeparator')\n\t\t};\n\t}\n\t\n\t/**\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction bemParse(item) {\n\t\tif (require('abbreviationUtils').isSnippet(item))\n\t\t\treturn item;\n\t\t\n\t\t// save BEM stuff in cache for faster lookups\n\t\titem.__bem = {\n\t\t\tblock: '',\n\t\t\telement: '',\n\t\t\tmodifier: ''\n\t\t};\n\t\t\n\t\tvar classNames = normalizeClassName(item.attribute('class')).split(' ');\n\t\t\n\t\t// guess best match for block name\n\t\tvar reBlockName = /^[a-z]\\-/i;\n\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\treturn reBlockName.test(name);\n\t\t});\n\t\t\n\t\t// guessing doesn't worked, pick first class name as block name\n\t\tif (!item.__bem.block) {\n\t\t\treBlockName = /^[a-z]/i;\n\t\t\titem.__bem.block = _.find(classNames, function(name) {\n\t\t\t\treturn reBlockName.test(name);\n\t\t\t}) || '';\n\t\t}\n\t\t\n\t\tclassNames = _.chain(classNames)\n\t\t\t.map(function(name) {return processClassName(name, item);})\n\t\t\t.flatten()\n\t\t\t.uniq()\n\t\t\t.value()\n\t\t\t.join(' ');\n\t\t\n\t\tif (classNames)\n\t\t\titem.attribute('class', classNames);\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * @param {String} className\n\t * @returns {String}\n\t */\n\tfunction normalizeClassName(className) {\n\t\tvar utils = require('utils');\n\t\tclassName = (' ' + (className || '') + ' ').replace(/\\s+/g, ' ');\n\t\t\n\t\tvar shortSymbol = prefs.get('bem.shortElementPrefix');\n\t\tif (shortSymbol) {\n\t\t\tvar re = new RegExp('\\\\s(' + utils.escapeForRegexp(shortSymbol) + '+)', 'g');\n\t\t\tclassName = className.replace(re, function(str, p1) {\n\t\t\t\treturn ' ' + utils.repeatString(getSeparators().element, p1.length);\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn utils.trim(className);\n\t}\n\t\n\t/**\n\t * Processes class name\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @returns Processed class name. May return <code>Array</code> of\n\t * class names \n\t */\n\tfunction processClassName(name, item) {\n\t\tname = transformClassName(name, item, 'element');\n\t\tname = transformClassName(name, item, 'modifier');\n\t\t\n\t\t// expand class name\n\t\t// possible values:\n\t\t// * block__element\n\t\t// * block__element_modifier\n\t\t// * block__element_modifier1_modifier2\n\t\t// * block_modifier\n\t\tvar block = '', element = '', modifier = '';\n\t\tvar separators = getSeparators();\n\t\tif (~name.indexOf(separators.element)) {\n\t\t\tvar blockElem = name.split(separators.element);\n\t\t\tvar elemModifiers = blockElem[1].split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockElem[0];\n\t\t\telement = elemModifiers.shift();\n\t\t\tmodifier = elemModifiers.join(separators.modifier);\n\t\t} else if (~name.indexOf(separators.modifier)) {\n\t\t\tvar blockModifiers = name.split(separators.modifier);\n\t\t\t\n\t\t\tblock = blockModifiers.shift();\n\t\t\tmodifier = blockModifiers.join(separators.modifier);\n\t\t}\n\t\t\n\t\tif (block || element || modifier) {\n\t\t\tif (!block) {\n\t\t\t\tblock = item.__bem.block;\n\t\t\t}\n\t\t\t\n\t\t\t// inherit parent bem element, if exists\n//\t\t\tif (item.parent && item.parent.__bem && item.parent.__bem.element)\n//\t\t\t\telement = item.parent.__bem.element + separators.element + element;\n\t\t\t\n\t\t\t// produce multiple classes\n\t\t\tvar prefix = block;\n\t\t\tvar result = [];\n\t\t\t\n\t\t\tif (element) {\n\t\t\t\tprefix += separators.element + element;\n\t\t\t\tresult.push(prefix);\n\t\t\t} else {\n\t\t\t\tresult.push(prefix);\n\t\t\t}\n\t\t\t\n\t\t\tif (modifier) {\n\t\t\t\tresult.push(prefix + separators.modifier + modifier);\n\t\t\t}\n\t\t\t\n\t\t\titem.__bem.block = block;\n\t\t\titem.__bem.element = element;\n\t\t\titem.__bem.modifier = modifier;\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\t// ...otherwise, return processed or original class name\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Low-level function to transform user-typed class name into full BEM class\n\t * @param {String} name Class name item to process\n\t * @param {AbbreviationNode} item Host node for provided class name\n\t * @param {String} entityType Type of entity to be tried to transform \n\t * ('element' or 'modifier')\n\t * @returns {String} Processed class name or original one if it can't be\n\t * transformed\n\t */\n\tfunction transformClassName(name, item, entityType) {\n\t\tvar separators = getSeparators();\n\t\tvar reSep = new RegExp('^(' + separators[entityType] + ')+', 'g');\n\t\tif (reSep.test(name)) {\n\t\t\tvar depth = 0; // parent lookup depth\n\t\t\tvar cleanName = name.replace(reSep, function(str, p1) {\n\t\t\t\tdepth = str.length / separators[entityType].length;\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\t\n\t\t\t// find donor element\n\t\t\tvar donor = item;\n\t\t\twhile (donor.parent && depth--) {\n\t\t\t\tdonor = donor.parent;\n\t\t\t}\n\t\t\t\n\t\t\tif (!donor || !donor.__bem)\n\t\t\t\tdonor = item;\n\t\t\t\n\t\t\tif (donor && donor.__bem) {\n\t\t\t\tvar prefix = donor.__bem.block;\n\t\t\t\t\n\t\t\t\t// decide if we should inherit element name\n//\t\t\t\tif (entityType == 'element') {\n//\t\t\t\t\tvar curElem = cleanName.split(separators.modifier, 1)[0];\n//\t\t\t\t\tif (donor.__bem.element && donor.__bem.element != curElem)\n//\t\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n//\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (entityType == 'modifier' &&  donor.__bem.element)\n\t\t\t\t\tprefix += separators.element + donor.__bem.element;\n\t\t\t\t\n\t\t\t\treturn prefix + separators[entityType] + cleanName;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn name;\n\t}\n\t\n\t/**\n\t * Recursive function for processing tags, which extends class names \n\t * according to BEM specs: http://bem.github.com/bem-method/pages/beginning/beginning.ru.html\n\t * <br><br>\n\t * It does several things:<br>\n\t * <ul>\n\t * <li>Expands complex class name (according to BEM symbol semantics):\n\t * .block__elem_modifier  .block.block__elem.block__elem_modifier\n\t * </li>\n\t * <li>Inherits block name on child elements: \n\t * .b-block > .__el > .__el  .b-block > .b-block__el > .b-block__el__el\n\t * </li>\n\t * <li>Treats first dash symbol as '__'</li>\n\t * <li>Double underscore (or typographic '') is also treated as an element \n\t * level lookup, e.g. ____el will search for element definition in parents \n\t * parent element:\n\t * .b-block > .__el1 > .____el2  .b-block > .b-block__el1 > .b-block__el2\n\t * </li>\n\t * </ul>\n\t * \n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t */\n\tfunction process(tree, profile) {\n\t\tif (tree.name)\n\t\t\tbemParse(tree, profile);\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tprocess(item, profile);\n\t\t\tif (!abbrUtils.isSnippet(item) && item.start)\n\t\t\t\tshouldRunHtmlFilter = true;\n\t\t});\n\t\t\n\t\treturn tree;\n\t};\n\t\n\trequire('filters').add('bem', function(tree, profile) {\n\t\tshouldRunHtmlFilter = false;\n\t\ttree = process(tree, profile);\n\t\t// in case 'bem' filter is applied after 'html' filter: run it again\n\t\t// to update output\n\t\tif (shouldRunHtmlFilter) {\n\t\t\ttree = require('filters').apply(tree, 'html', profile);\n\t\t}\n\t\t\n\t\treturn tree;\n\t});\n});\n\n/**\n * Comment important tags (with 'id' and 'class' attributes)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __commentFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t// define some preferences\n\t/** @type emmet.preferences */\n\tvar prefs = require('preferences');\n\t\n\tprefs.define('filter.commentAfter', \n\t\t\t'\\n<!-- /<%= attr(\"id\", \"#\") %><%= attr(\"class\", \".\") %> -->',\n\t\t\t'A definition of comment that should be placed <i>after</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. This definition '\n\t\t\t+ 'is an ERB-style template passed to <code>_.template()</code> '\n\t\t\t+ 'function (see Underscore.js docs for details). In template context, '\n\t\t\t+ 'the following properties and functions are availabe:\\n'\n\t\t\t+ '<ul>'\n\t\t\t\n\t\t\t+ '<li><code>attr(name, before, after)</code>  a function that outputs' \n\t\t\t+ 'specified attribute value concatenated with <code>before</code> ' \n\t\t\t+ 'and <code>after</code> strings. If attribute doesn\\'t exists, the ' \n\t\t\t+ 'empty string will be returned.</li>'\n\t\t\t\n\t\t\t+ '<li><code>node</code>  current node (instance of <code>AbbreviationNode</code>)</li>'\n\t\t\t\n\t\t\t+ '<li><code>name</code>  name of current tag</li>'\n\t\t\t\n\t\t\t+ '<li><code>padding</code>  current string padding, can be used ' \n\t\t\t+ 'for formatting</li>'\n\t\t\t\n\t\t\t+'</ul>');\n\t\n\tprefs.define('filter.commentBefore', \n\t\t\t'',\n\t\t\t'A definition of comment that should be placed <i>before</i> matched '\n\t\t\t+ 'element when <code>comment</code> filter is applied. '\n\t\t\t+ 'For more info, read description of <code>filter.commentAfter</code> '\n\t\t\t+ 'property');\n\t\n\tprefs.define('filter.commentTrigger', 'id, class',\n\t\t\t'A comma-separated list of attribute names that should exist in abbreviatoin '\n\t\t\t+ 'where comment should be added. If you wish to add comment for '\n\t\t\t+ 'every element, set this option to <code>*</code>');\n\t\n\t/**\n\t * Add comments to tag\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction addComments(node, templateBefore, templateAfter) {\n\t\tvar utils = require('utils');\n\t\t\n\t\t// check if comments should be added\n\t\tvar trigger = prefs.get('filter.commentTrigger');\n\t\tif (trigger != '*') {\n\t\t\tvar shouldAdd = _.find(trigger.split(','), function(name) {\n\t\t\t\treturn !!node.attribute(utils.trim(name));\n\t\t\t});\n\t\t\tif (!shouldAdd) return;\n\t\t}\n\t\t\n\t\tvar ctx = {\n\t\t\tnode: node,\n\t\t\tname: node.name(),\n\t\t\tpadding: node.parent ? node.parent.padding : '',\n\t\t\tattr: function(name, before, after) {\n\t\t\t\tvar attr = node.attribute(name);\n\t\t\t\tif (attr) {\n\t\t\t\t\treturn (before || '') + attr + (after || '');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturn '';\n\t\t\t}\n\t\t};\n\t\t\n\t\tvar nodeBefore = utils.normalizeNewline(templateBefore ? templateBefore(ctx) : '');\n\t\tvar nodeAfter = utils.normalizeNewline(templateAfter ? templateAfter(ctx) : '');\n\t\t\n\t\tnode.start = node.start.replace(/</, nodeBefore + '<');\n\t\tnode.end = node.end.replace(/>/, '>' + nodeAfter);\n\t}\n\t\n\tfunction process(tree, before, after) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isBlock(item))\n\t\t\t\taddComments(item, before, after);\n\t\t\t\n\t\t\tprocess(item, before, after);\n\t\t});\n\t\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('c', function(tree) {\n\t\tvar templateBefore = _.template(prefs.get('filter.commentBefore'));\n\t\tvar templateAfter = _.template(prefs.get('filter.commentAfter'));\n\t\t\n\t\treturn process(tree, templateBefore, templateAfter);\n\t});\n});\n/**\n * Filter for escaping unsafe XML characters: <, >, &\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n */\nemmet.exec(function(require, _) {\n\tvar charMap = {\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t'&': '&amp;'\n\t};\n\t\n\tfunction escapeChars(str) {\n\t\treturn str.replace(/([<>&])/g, function(str, p1){\n\t\t\treturn charMap[p1];\n\t\t});\n\t}\n\t\n\trequire('filters').add('e', function process(tree) {\n\t\t_.each(tree.children, function(item) {\n\t\t\titem.start = escapeChars(item.start);\n\t\t\titem.end = escapeChars(item.end);\n\t\t\titem.content = escapeChars(item.content);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Generic formatting filter: creates proper indentation for each tree node,\n * placing \"%s\" placeholder where the actual output should be. You can use\n * this filter to preformat tree and then replace %s placeholder to whatever you\n * need. This filter should't be called directly from editor as a part \n * of abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __formatFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _){\n\tvar placeholder = '%s';\n\t\n\t/** @type preferences */\n\tvar prefs = require('preferences');\n\tprefs.define('format.noIndentTags', 'html', \n\t\t\t'A comma-separated list of tag names that should not get inner indentation.');\n\t\n\tprefs.define('format.forceIndentationForTags', 'body', \n\t\t'A comma-separated list of tag names that should <em>always</em> get inner indentation.');\n\t\n\t/**\n\t * Get indentation for given node\n\t * @param {AbbreviationNode} node\n\t * @returns {String}\n\t */\n\tfunction getIndentation(node) {\n\t\tif (_.include(prefs.getArray('format.noIndentTags') || [], node.name())) {\n\t\t\treturn '';\n\t\t}\n\t\t\n\t\treturn require('resources').getVariable('indentation');\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && require('abbreviationUtils').hasBlockChildren(item.parent);\n\t}\n\t\n\t/**\n\t * Test if passed item is very first child in parsed tree\n\t * @param {AbbreviationNode} item\n\t */\n\tfunction isVeryFirstChild(item) {\n\t\treturn item.parent && !item.parent.parent && !item.index();\n\t}\n\t\n\t/**\n\t * Check if a newline should be added before element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldAddLineBreak(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tif (profile.tag_nl === true || abbrUtils.isBlock(node))\n\t\t\treturn true;\n\t\t\n\t\tif (!node.parent || !profile.inline_break)\n\t\t\treturn false;\n\t\t\n\t\t// check if there are required amount of adjacent inline element\n\t\treturn shouldFormatInline(node.parent, profile);\n}\n\t\n\t/**\n\t * Need to add newline because <code>item</code> has too many inline children\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction shouldBreakChild(node, profile) {\n\t\t// we need to test only one child element, because \n\t\t// hasBlockChildren() method will do the rest\n\t\treturn node.children.length && shouldAddLineBreak(node.children[0], profile);\n\t}\n\t\n\tfunction shouldFormatInline(node, profile) {\n\t\tvar nodeCount = 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\treturn !!_.find(node.children, function(child) {\n\t\t\tif (child.isTextNode() || !abbrUtils.isInline(child))\n\t\t\t\tnodeCount = 0;\n\t\t\telse if (abbrUtils.isInline(child))\n\t\t\t\tnodeCount++;\n\t\t\t\n\t\t\tif (nodeCount >= profile.inline_break)\n\t\t\t\treturn true;\n\t\t});\n\t}\n\t\n\tfunction isRoot(item) {\n\t\treturn !item.parent;\n\t}\n\t\n\t/**\n\t * Processes element with matched resource of type <code>snippet</code>\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processSnippet(item, profile, level) {\n\t\titem.start = item.end = '';\n\t\tif (!isVeryFirstChild(item) && profile.tag_nl !== false && shouldAddLineBreak(item, profile)) {\n\t\t\t// check if were not inside inline element\n\t\t\tif (isRoot(item.parent) || !require('abbreviationUtils').isInline(item.parent)) {\n\t\t\t\titem.start = require('utils').getNewline() + item.start;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Check if we should add line breaks inside inline element\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t * @return {Boolean}\n\t */\n\tfunction shouldBreakInsideInline(node, profile) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar hasBlockElems = _.any(node.children, function(child) {\n\t\t\tif (abbrUtils.isSnippet(child))\n\t\t\t\treturn false;\n\t\t\t\n\t\t\treturn !abbrUtils.isInline(child);\n\t\t});\n\t\t\n\t\tif (!hasBlockElems) {\n\t\t\treturn shouldFormatInline(node, profile);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\titem.start = item.end = placeholder;\n\t\tvar utils = require('utils');\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar nl = utils.getNewline();\n\t\tvar indent = getIndentation(item);\n\t\t\t\n\t\t// formatting output\n\t\tif (profile.tag_nl !== false) {\n\t\t\tvar forceNl = profile.tag_nl === true && (profile.tag_nl_leaf || item.children.length);\n\t\t\tif (!forceNl) {\n\t\t\t\tforceNl = _.include(prefs.getArray('format.forceIndentationForTags') || [], item.name());\n\t\t\t}\n\t\t\t\n\t\t\t// formatting block-level elements\n\t\t\tif (!item.isTextNode()) {\n\t\t\t\tif (shouldAddLineBreak(item, profile)) {\n\t\t\t\t\t// - do not indent the very first element\n\t\t\t\t\t// - do not indent first child of a snippet\n\t\t\t\t\tif (!isVeryFirstChild(item) && (!abbrUtils.isSnippet(item.parent) || item.index()))\n\t\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasBlockChildren(item) || shouldBreakChild(item, profile) || (forceNl && !isUnary))\n\t\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t\t\t\n\t\t\t\t\tif (abbrUtils.hasTagsInContent(item) || (forceNl && !item.children.length && !isUnary))\n\t\t\t\t\t\titem.start += nl + indent;\n\t\t\t\t} else if (abbrUtils.isInline(item) && hasBlockSibling(item) && !isVeryFirstChild(item)) {\n\t\t\t\t\titem.start = nl + item.start;\n\t\t\t\t} else if (abbrUtils.isInline(item) && shouldBreakInsideInline(item, profile)) {\n\t\t\t\t\titem.end = nl + item.end;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\titem.padding = indent;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('_format', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (abbrUtils.isSnippet(item))\n\t\t\t\tprocessSnippet(item, profile, level);\n\t\t\telse\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter for producing HAML code from abbreviation.\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __hamlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar childToken = '${child}';\n\t\n\tfunction transformClassName(className) {\n\t\treturn require('utils').trim(className).replace(/\\s+/g, '.');\n\t}\n\t\n\t/**\n\t * Creates HAML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} tag\n\t * @param {Object} profile\n\t */\n\tfunction makeAttributesString(tag, profile) {\n\t\tvar attrs = '';\n\t\tvar otherAttrs = [];\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\t_.each(tag.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\tswitch (attrName.toLowerCase()) {\n\t\t\t\t// use short notation for ID and CLASS attributes\n\t\t\t\tcase 'id':\n\t\t\t\t\tattrs += '#' + (a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'class':\n\t\t\t\t\tattrs += '.' + transformClassName(a.value || cursor);\n\t\t\t\t\tbreak;\n\t\t\t\t// process other attributes\n\t\t\t\tdefault:\n\t\t\t\t\totherAttrs.push(':' +attrName + ' => ' + attrQuote + (a.value || cursor) + attrQuote);\n\t\t\t}\n\t\t});\n\t\t\n\t\tif (otherAttrs.length)\n\t\t\tattrs += '{' + otherAttrs.join(', ') + '}';\n\t\t\n\t\treturn attrs;\n\t}\n\t\n\t/**\n\t * Test if passed node has block-level sibling element\n\t * @param {AbbreviationNode} item\n\t * @return {Boolean}\n\t */\n\tfunction hasBlockSibling(item) {\n\t\treturn item.parent && item.parent.hasBlockChildren();\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent)\n\t\t\t// looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile);\n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar selfClosing = profile.self_closing_tag && isUnary ? '/' : '';\n\t\tvar start= '';\n\t\t\t\n\t\t// define tag name\n\t\tvar tagName = '%' + profile.tagName(item.name());\n\t\tif (tagName.toLowerCase() == '%div' && attrs && attrs.indexOf('{') == -1)\n\t\t\t// omit div tag\n\t\t\ttagName = '';\n\t\t\t\n\t\titem.end = '';\n\t\tstart = tagName + attrs + selfClosing + ' ';\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\t\n\t\tif (!item.children.length && !isUnary)\n\t\t\titem.start += cursor;\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('haml', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Filter that produces HTML tree\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __htmlFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\t/**\n\t * Creates HTML attributes string from tag according to profile settings\n\t * @param {AbbreviationNode} node\n\t * @param {OutputProfile} profile\n\t */\n\tfunction makeAttributesString(node, profile) {\n\t\tvar attrQuote = profile.attributeQuote();\n\t\tvar cursor = profile.cursor();\n\t\t\n\t\treturn _.map(node.attributeList(), function(a) {\n\t\t\tvar attrName = profile.attributeName(a.name);\n\t\t\treturn ' ' + attrName + '=' + attrQuote + (a.value || cursor) + attrQuote;\n\t\t}).join('');\n\t}\n\t\n\t/**\n\t * Processes element with <code>tag</code> type\n\t * @param {AbbreviationNode} item\n\t * @param {OutputProfile} profile\n\t * @param {Number} level Depth level\n\t */\n\tfunction processTag(item, profile, level) {\n\t\tif (!item.parent) // looks like it's root element\n\t\t\treturn item;\n\t\t\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\tvar utils = require('utils');\n\t\t\n\t\tvar attrs = makeAttributesString(item, profile); \n\t\tvar cursor = profile.cursor();\n\t\tvar isUnary = abbrUtils.isUnary(item);\n\t\tvar start= '';\n\t\tvar end = '';\n\t\t\t\n\t\t// define opening and closing tags\n\t\tif (!item.isTextNode()) {\n\t\t\tvar tagName = profile.tagName(item.name());\n\t\t\tif (isUnary) {\n\t\t\t\tstart = '<' + tagName + attrs + profile.selfClosing() + '>';\n\t\t\t\titem.end = '';\n\t\t\t} else {\n\t\t\t\tstart = '<' + tagName + attrs + '>';\n\t\t\t\tend = '</' + tagName + '>';\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar placeholder = '%s';\n\t\t// We can't just replace placeholder with new value because\n\t\t// JavaScript will treat double $ character as a single one, assuming\n\t\t// we're using RegExp literal.\n\t\titem.start = utils.replaceSubstring(item.start, start, item.start.indexOf(placeholder), placeholder);\n\t\titem.end = utils.replaceSubstring(item.end, end, item.end.indexOf(placeholder), placeholder);\n\t\t\n\t\t// should we put caret placeholder after opening tag?\n\t\tif (\n\t\t\t\t!item.children.length \n\t\t\t\t&& !isUnary \n\t\t\t\t&& !~item.content.indexOf(cursor)\n\t\t\t\t&& !require('tabStops').extract(item.content).tabstops.length\n\t\t\t) {\n\t\t\titem.start += cursor;\n\t\t}\n\t\t\n\t\treturn item;\n\t}\n\t\n\t/**\n\t * Processes simplified tree, making it suitable for output as HTML structure\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} profile\n\t * @param {Number} level Depth level\n\t */\n\trequire('filters').add('html', function process(tree, profile, level) {\n\t\tlevel = level || 0;\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\tif (!level) {\n\t\t\ttree = require('filters').apply(tree, '_format', profile);\n\t\t}\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item))\n\t\t\t\tprocessTag(item, profile, level);\n\t\t\t\n\t\t\tprocess(item, profile, level + 1);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * Output abbreviation on a single line (i.e. no line breaks)\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * @constructor\n * @memberOf __singleLineFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar rePad = /^\\s+/;\n\tvar reNl = /[\\n\\r]/g;\n\t\n\trequire('filters').add('s', function process(tree, profile, level) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)) {\n\t\t\t\t// remove padding from item \n\t\t\t\titem.start = item.start.replace(rePad, '');\n\t\t\t\titem.end = item.end.replace(rePad, '');\n\t\t\t}\n\t\t\t\n\t\t\t// remove newlines \n\t\t\titem.start = item.start.replace(reNl, '');\n\t\t\titem.end = item.end.replace(reNl, '');\n\t\t\titem.content = item.content.replace(reNl, '');\n\t\t\t\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});\n/**\n * Trim filter: removes characters at the beginning of the text\n * content that indicates lists: numbers, #, *, -, etc.\n * \n * Useful for wrapping lists with abbreviation.\n * \n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __trimFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\trequire('preferences').define('filter.trimRegexp', '[\\\\s|\\\\u00a0]*[\\\\d|#|\\\\-|\\*|\\\\u2022]+\\\\.?\\\\s*',\n\t\t\t'Regular expression used to remove list markers (numbers, dashes, ' \n\t\t\t+ 'bullets, etc.) in <code>t</code> (trim) filter. The trim filter '\n\t\t\t+ 'is useful for wrapping with abbreviation lists, pased from other ' \n\t\t\t+ 'documents (for example, Word documents).');\n\t\n\tfunction process(tree, re) {\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (item.content)\n\t\t\t\titem.content = item.content.replace(re, '');\n\t\t\t\n\t\t\tprocess(item, re);\n\t\t});\n\t\t\n\t\treturn tree;\n\t}\n\t\n\trequire('filters').add('t', function(tree) {\n\t\tvar re = new RegExp(require('preferences').get('filter.trimRegexp'));\n\t\treturn process(tree, re);\n\t});\n});\n/**\n * Filter for trimming \"select\" attributes from some tags that contains\n * child elements\n * @author Sergey Chikuyonok (serge.che@gmail.com)\n * @link http://chikuyonok.ru\n * \n * @constructor\n * @memberOf __xslFilterDefine\n * @param {Function} require\n * @param {Underscore} _\n */\nemmet.exec(function(require, _) {\n\tvar tags = {\n\t\t'xsl:variable': 1,\n\t\t'xsl:with-param': 1\n\t};\n\t\n\t/**\n\t * Removes \"select\" attribute from node\n\t * @param {AbbreviationNode} node\n\t */\n\tfunction trimAttribute(node) {\n\t\tnode.start = node.start.replace(/\\s+select\\s*=\\s*(['\"]).*?\\1/, '');\n\t}\n\t\n\trequire('filters').add('xsl', function process(tree) {\n\t\tvar abbrUtils = require('abbreviationUtils');\n\t\t_.each(tree.children, function(item) {\n\t\t\tif (!abbrUtils.isSnippet(item)\n\t\t\t\t\t&& (item.name() || '').toLowerCase() in tags \n\t\t\t\t\t&& item.children.length)\n\t\t\t\ttrimAttribute(item);\n\t\t\tprocess(item);\n\t\t});\n\t\t\n\t\treturn tree;\n\t});\n});/**\n * \"Lorem ipsum\" text generator. Matches <code>lipsum(num)?</code> or \n * <code>lorem(num)?</code> abbreviation.\n * This code is based on Django's contribution: \n * https://code.djangoproject.com/browser/django/trunk/django/contrib/webdesign/lorem_ipsum.py\n * <br><br>\n * Examples to test:<br>\n * <code>lipsum</code>  generates 30 words text.<br>\n * <code>lipsum*6</code>  generates 6 paragraphs (autowrapped with &lt;p&gt; element) of text.<br>\n * <code>ol>lipsum10*5</code>  generates ordered list with 5 list items (autowrapped with &lt;li&gt; tag)\n * with text of 10 words on each line<br>\n * <code>span*3>lipsum20</code>  generates 3 paragraphs of 20-words text, each wrapped with &lt;span&gt; element .\n * Each paragraph phrase is unique   \n * @param {Function} require\n * @param {Underscore} _ \n * @constructor\n * @memberOf __loremIpsumGeneratorDefine\n */\nemmet.define('lorem', function(require, _) {\n\tvar langs = {\n\t\ten: {\n\t\t\tcommon: ['lorem', 'ipsum', 'dolor', 'sit', 'amet', 'consectetur', 'adipisicing', 'elit'],\n\t\t\twords: ['exercitationem', 'perferendis', 'perspiciatis', 'laborum', 'eveniet',\n\t             'sunt', 'iure', 'nam', 'nobis', 'eum', 'cum', 'officiis', 'excepturi',\n\t             'odio', 'consectetur', 'quasi', 'aut', 'quisquam', 'vel', 'eligendi',\n\t             'itaque', 'non', 'odit', 'tempore', 'quaerat', 'dignissimos',\n\t             'facilis', 'neque', 'nihil', 'expedita', 'vitae', 'vero', 'ipsum',\n\t             'nisi', 'animi', 'cumque', 'pariatur', 'velit', 'modi', 'natus',\n\t             'iusto', 'eaque', 'sequi', 'illo', 'sed', 'ex', 'et', 'voluptatibus',\n\t             'tempora', 'veritatis', 'ratione', 'assumenda', 'incidunt', 'nostrum',\n\t             'placeat', 'aliquid', 'fuga', 'provident', 'praesentium', 'rem',\n\t             'necessitatibus', 'suscipit', 'adipisci', 'quidem', 'possimus',\n\t             'voluptas', 'debitis', 'sint', 'accusantium', 'unde', 'sapiente',\n\t             'voluptate', 'qui', 'aspernatur', 'laudantium', 'soluta', 'amet',\n\t             'quo', 'aliquam', 'saepe', 'culpa', 'libero', 'ipsa', 'dicta',\n\t             'reiciendis', 'nesciunt', 'doloribus', 'autem', 'impedit', 'minima',\n\t             'maiores', 'repudiandae', 'ipsam', 'obcaecati', 'ullam', 'enim',\n\t             'totam', 'delectus', 'ducimus', 'quis', 'voluptates', 'dolores',\n\t             'molestiae', 'harum', 'dolorem', 'quia', 'voluptatem', 'molestias',\n\t             'magni', 'distinctio', 'omnis', 'illum', 'dolorum', 'voluptatum', 'ea',\n\t             'quas', 'quam', 'corporis', 'quae', 'blanditiis', 'atque', 'deserunt',\n\t             'laboriosam', 'earum', 'consequuntur', 'hic', 'cupiditate',\n\t             'quibusdam', 'accusamus', 'ut', 'rerum', 'error', 'minus', 'eius',\n\t             'ab', 'ad', 'nemo', 'fugit', 'officia', 'at', 'in', 'id', 'quos',\n\t             'reprehenderit', 'numquam', 'iste', 'fugiat', 'sit', 'inventore',\n\t             'beatae', 'repellendus', 'magnam', 'recusandae', 'quod', 'explicabo',\n\t             'doloremque', 'aperiam', 'consequatur', 'asperiores', 'commodi',\n\t             'optio', 'dolor', 'labore', 'temporibus', 'repellat', 'veniam',\n\t             'architecto', 'est', 'esse', 'mollitia', 'nulla', 'a', 'similique',\n\t             'eos', 'alias', 'dolore', 'tenetur', 'deleniti', 'porro', 'facere',\n\t             'maxime', 'corrupti']\n\t\t},\n\t\tru: {\n\t\t\tcommon: ['-', '', '', '', ' ', '', ' ', '', '', ''],\n\t\t\twords: ['', ' ', '', '', '', ' ', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', ' ', '', '','', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '','', '', '', 'lorem', 'ipsum', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '',  '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', \n\t\t            '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', \n\t\t            '', '', '', '', '', '', '', '']\n\t\t}\n\t};\n\n\tvar prefs = require('preferences');\n\tprefs.define('lorem.defaultLang', 'en');\n\n\t/**\n\t * @param {AbbreviationNode} tree\n\t * @param {Object} options\n\t */\n\trequire('abbreviationParser').addPreprocessor(function(tree, options) {\n\t\tvar re = /^(?:lorem|lipsum)([a-z]{2})?(\\d*)$/i, match;\n\t\t\n\t\t/** @param {AbbreviationNode} node */\n\t\ttree.findAll(function(node) {\n\t\t\tif (node._name && (match = node._name.match(re))) {\n\t\t\t\tvar wordCound = match[2] || 30;\n\t\t\t\tvar lang = match[1] || prefs.get('lorem.defaultLang') || 'en';\n\t\t\t\t\n\t\t\t\t// force node name resolving if node should be repeated\n\t\t\t\t// or contains attributes. In this case, node should be outputed\n\t\t\t\t// as tag, otherwise as text-only node\n\t\t\t\tnode._name = '';\n\t\t\t\tnode.data('forceNameResolving', node.isRepeating() || node.attributeList().length);\n\t\t\t\tnode.data('pasteOverwrites', true);\n\t\t\t\tnode.data('paste', function(i, content) {\n\t\t\t\t\treturn paragraph(lang, wordCound, !i);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\t\n\t/**\n\t * Returns random integer between <code>from</code> and <code>to</code> values\n\t * @param {Number} from\n\t * @param {Number} to\n\t * @returns {Number}\n\t */\n\tfunction randint(from, to) {\n\t\treturn Math.round(Math.random() * (to - from) + from);\n\t}\n\t\n\t/**\n\t * @param {Array} arr\n\t * @param {Number} count\n\t * @returns {Array}\n\t */\n\tfunction sample(arr, count) {\n\t\tvar len = arr.length;\n\t\tvar iterations = Math.min(len, count);\n\t\tvar result = [];\n\t\twhile (result.length < iterations) {\n\t\t\tvar randIx = randint(0, len - 1);\n\t\t\tif (!_.include(result, randIx))\n\t\t\t\tresult.push(randIx);\n\t\t}\n\t\t\n\t\treturn _.map(result, function(ix) {\n\t\t\treturn arr[ix];\n\t\t});\n\t}\n\t\n\tfunction choice(val) {\n\t\tif (_.isString(val))\n\t\t\treturn val.charAt(randint(0, val.length - 1));\n\t\t\n\t\treturn val[randint(0, val.length - 1)];\n\t}\n\t\n\tfunction sentence(words, end) {\n\t\tif (words.length) {\n\t\t\twords[0] = words[0].charAt(0).toUpperCase() + words[0].substring(1);\n\t\t}\n\t\t\n\t\treturn words.join(' ') + (end || choice('?!...')); // more dots that question marks\n\t}\n\t\n\t/**\n\t * Insert commas at randomly selected words. This function modifies values\n\t * inside <code>words</code> array \n\t * @param {Array} words\n\t */\n\tfunction insertCommas(words) {\n\t\tvar len = words.length;\n\t\tvar totalCommas = 0;\n\t\t\n\t\tif (len > 3 && len <= 6) {\n\t\t\ttotalCommas = randint(0, 1);\n\t\t} else if (len > 6 && len <= 12) {\n\t\t\ttotalCommas = randint(0, 2);\n\t\t} else {\n\t\t\ttotalCommas = randint(1, 4);\n\t\t}\n\n\t\t_.each(_.range(totalCommas), function(ix) {\n\t\t\tif (ix < words.length - 1) {\n\t\t\t\twords[ix] += ',';\n\t\t\t}\n\t\t});\n\t}\n\t\n\t/**\n\t * Generate a paragraph of \"Lorem ipsum\" text\n\t * @param {Number} wordCount Words count in paragraph\n\t * @param {Boolean} startWithCommon Should paragraph start with common \n\t * \"lorem ipsum\" sentence.\n\t * @returns {String}\n\t */\n\tfunction paragraph(lang, wordCount, startWithCommon) {\n\t\tvar data = langs[lang];\n\t\tif (!data) {\n\t\t\treturn '';\n\t\t}\n\n\t\tvar result = [];\n\t\tvar totalWords = 0;\n\t\tvar words;\n\t\t\n\t\twordCount = parseInt(wordCount, 10);\n\t\t\n\t\tif (startWithCommon && data.common) {\n\t\t\twords = data.common.slice(0, wordCount);\n\t\t\tif (words.length > 5)\n\t\t\t\twords[4] += ',';\n\t\t\ttotalWords += words.length;\n\t\t\tresult.push(sentence(words, '.'));\n\t\t}\n\t\t\n\t\twhile (totalWords < wordCount) {\n\t\t\twords = sample(data.words, Math.min(randint(3, 12) * randint(1, 5), wordCount - totalWords));\n\t\t\ttotalWords += words.length;\n\t\t\tinsertCommas(words);\n\t\t\tresult.push(sentence(words));\n\t\t}\n\t\t\n\t\treturn result.join(' ');\n\t}\n\n\treturn {\n\t\t/**\n\t\t * Adds new language words for Lorem Ipsum generator\n\t\t * @param {String} lang Two-letter lang definition\n\t\t * @param {Object} data Words for language. Maight be either a space-separated \n\t\t * list of words (String), Array of words or object with <code>text</code> and\n\t\t * <code>common</code> properties\n\t\t */\n\t\taddLang: function(lang, data) {\n\t\t\tif (_.isString(data)) {\n\t\t\t\tdata = {words: _.compact(data.split(' '))};\n\t\t\t} else if (_.isArray(data)) {\n\t\t\t\tdata = {words: data};\n\t\t\t}\n\n\t\t\tlangs[lang] = data;\n\t\t}\n\t}\n});/**\n * A back-end bootstrap module with commonly used methods for loading user data\n * @param {Function} require\n * @param {Underscore} _  \n */\nemmet.define('bootstrap', function(require, _) {\nvar snippets = {\n\t\"variables\": {\n\t\t\"lang\": \"en\",\n\t\t\"locale\": \"en-US\",\n\t\t\"charset\": \"UTF-8\",\n\t\t\"indentation\": \"\\t\",\n\t\t\"newline\": \"\\n\"\n\t},\n\t\n\t\"css\": {\n\t\t\"filters\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"@i\": \"@import url(|);\",\n\t\t\t\"@import\": \"@import url(|);\",\n\t\t\t\"@m\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@media\": \"@media ${1:screen} {\\n\\t|\\n}\",\n\t\t\t\"@f\": \"@font-face {\\n\\tfont-family:|;\\n\\tsrc:url(|);\\n}\",\n\t\t\t\"@f+\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\n\t\t\t\"@kf\": \"@-webkit-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-o-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@-moz-keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\\n@keyframes ${1:identifier} {\\n\\t${2:from} { ${3} }${6}\\n\\t${4:to} { ${5} }\\n}\",\n\n\n\t\t\t\"anim\": \"animation:|;\",\n\t\t\t\"anim-\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode};\",\n\t\t\t\"animdel\": \"animation-delay:${1:time};\",\n\t\t\t\n\t\t\t\"animdir\": \"animation-direction:${1:normal};\",\n\t\t\t\"animdir:n\": \"animation-direction:normal;\",\n\t\t\t\"animdir:r\": \"animation-direction:reverse;\",\n\t\t\t\"animdir:a\": \"animation-direction:alternate;\",\n\t\t\t\"animdir:ar\": \"animation-direction:alternate-reverse;\",\n\t\t\t\n\t\t\t\"animdur\": \"animation-duration:${1:0}s;\",\n\t\t\t\n\t\t\t\"animfm\": \"animation-fill-mode:${1:both};\",\n\t\t\t\"animfm:f\": \"animation-fill-mode:forwards;\",\n\t\t\t\"animfm:b\": \"animation-fill-mode:backwards;\",\n\t\t\t\"animfm:bt\": \"animation-fill-mode:both;\",\n\t\t\t\"animfm:bh\": \"animation-fill-mode:both;\",\n\t\t\t\n\t\t\t\"animic\": \"animation-iteration-count:${1:1};\",\n\t\t\t\"animic:i\": \"animation-iteration-count:infinite;\",\n\t\t\t\n\t\t\t\"animn\": \"animation-name:${1:none};\",\n\n\t\t\t\"animps\": \"animation-play-state:${1:running};\",\n\t\t\t\"animps:p\": \"animation-play-state:paused;\",\n\t\t\t\"animps:r\": \"animation-play-state:running;\",\n\n\t\t\t\"animtf\": \"animation-timing-function:${1:linear};\",\n\t\t\t\"animtf:e\": \"animation-timing-function:ease;\",\n\t\t\t\"animtf:ei\": \"animation-timing-function:ease-in;\",\n\t\t\t\"animtf:eo\": \"animation-timing-function:ease-out;\",\n\t\t\t\"animtf:eio\": \"animation-timing-function:ease-in-out;\",\n\t\t\t\"animtf:l\": \"animation-timing-function:linear;\",\n\t\t\t\"animtf:cb\": \"animation-timing-function:cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1});\",\n\t\t\t\n\t\t\t\"ap\": \"appearance:${none};\",\n\n\t\t\t\"!\": \"!important\",\n\t\t\t\"pos\": \"position:${1:relative};\",\n\t\t\t\"pos:s\": \"position:static;\",\n\t\t\t\"pos:a\": \"position:absolute;\",\n\t\t\t\"pos:r\": \"position:relative;\",\n\t\t\t\"pos:f\": \"position:fixed;\",\n\t\t\t\"t\": \"top:|;\",\n\t\t\t\"t:a\": \"top:auto;\",\n\t\t\t\"r\": \"right:|;\",\n\t\t\t\"r:a\": \"right:auto;\",\n\t\t\t\"b\": \"bottom:|;\",\n\t\t\t\"b:a\": \"bottom:auto;\",\n\t\t\t\"l\": \"left:|;\",\n\t\t\t\"l:a\": \"left:auto;\",\n\t\t\t\"z\": \"z-index:|;\",\n\t\t\t\"z:a\": \"z-index:auto;\",\n\t\t\t\"fl\": \"float:${1:left};\",\n\t\t\t\"fl:n\": \"float:none;\",\n\t\t\t\"fl:l\": \"float:left;\",\n\t\t\t\"fl:r\": \"float:right;\",\n\t\t\t\"cl\": \"clear:${1:both};\",\n\t\t\t\"cl:n\": \"clear:none;\",\n\t\t\t\"cl:l\": \"clear:left;\",\n\t\t\t\"cl:r\": \"clear:right;\",\n\t\t\t\"cl:b\": \"clear:both;\",\n\n\t\t\t\"colm\": \"columns:|;\",\n\t\t\t\"colmc\": \"column-count:|;\",\n\t\t\t\"colmf\": \"column-fill:|;\",\n\t\t\t\"colmg\": \"column-gap:|;\",\n\t\t\t\"colmr\": \"column-rule:|;\",\n\t\t\t\"colmrc\": \"column-rule-color:|;\",\n\t\t\t\"colmrs\": \"column-rule-style:|;\",\n\t\t\t\"colmrw\": \"column-rule-width:|;\",\n\t\t\t\"colms\": \"column-span:|;\",\n\t\t\t\"colmw\": \"column-width:|;\",\n\n\t\t\t\"d\": \"display:${1:block};\",\n\t\t\t\"d:n\": \"display:none;\",\n\t\t\t\"d:b\": \"display:block;\",\n\t\t\t\"d:i\": \"display:inline;\",\n\t\t\t\"d:ib\": \"display:inline-block;\",\n\t\t\t\"d:ib+\": \"display: inline-block;\\n*display: inline;\\n*zoom: 1;\",\n\t\t\t\"d:li\": \"display:list-item;\",\n\t\t\t\"d:ri\": \"display:run-in;\",\n\t\t\t\"d:cp\": \"display:compact;\",\n\t\t\t\"d:tb\": \"display:table;\",\n\t\t\t\"d:itb\": \"display:inline-table;\",\n\t\t\t\"d:tbcp\": \"display:table-caption;\",\n\t\t\t\"d:tbcl\": \"display:table-column;\",\n\t\t\t\"d:tbclg\": \"display:table-column-group;\",\n\t\t\t\"d:tbhg\": \"display:table-header-group;\",\n\t\t\t\"d:tbfg\": \"display:table-footer-group;\",\n\t\t\t\"d:tbr\": \"display:table-row;\",\n\t\t\t\"d:tbrg\": \"display:table-row-group;\",\n\t\t\t\"d:tbc\": \"display:table-cell;\",\n\t\t\t\"d:rb\": \"display:ruby;\",\n\t\t\t\"d:rbb\": \"display:ruby-base;\",\n\t\t\t\"d:rbbg\": \"display:ruby-base-group;\",\n\t\t\t\"d:rbt\": \"display:ruby-text;\",\n\t\t\t\"d:rbtg\": \"display:ruby-text-group;\",\n\t\t\t\"v\": \"visibility:${1:hidden};\",\n\t\t\t\"v:v\": \"visibility:visible;\",\n\t\t\t\"v:h\": \"visibility:hidden;\",\n\t\t\t\"v:c\": \"visibility:collapse;\",\n\t\t\t\"ov\": \"overflow:${1:hidden};\",\n\t\t\t\"ov:v\": \"overflow:visible;\",\n\t\t\t\"ov:h\": \"overflow:hidden;\",\n\t\t\t\"ov:s\": \"overflow:scroll;\",\n\t\t\t\"ov:a\": \"overflow:auto;\",\n\t\t\t\"ovx\": \"overflow-x:${1:hidden};\",\n\t\t\t\"ovx:v\": \"overflow-x:visible;\",\n\t\t\t\"ovx:h\": \"overflow-x:hidden;\",\n\t\t\t\"ovx:s\": \"overflow-x:scroll;\",\n\t\t\t\"ovx:a\": \"overflow-x:auto;\",\n\t\t\t\"ovy\": \"overflow-y:${1:hidden};\",\n\t\t\t\"ovy:v\": \"overflow-y:visible;\",\n\t\t\t\"ovy:h\": \"overflow-y:hidden;\",\n\t\t\t\"ovy:s\": \"overflow-y:scroll;\",\n\t\t\t\"ovy:a\": \"overflow-y:auto;\",\n\t\t\t\"ovs\": \"overflow-style:${1:scrollbar};\",\n\t\t\t\"ovs:a\": \"overflow-style:auto;\",\n\t\t\t\"ovs:s\": \"overflow-style:scrollbar;\",\n\t\t\t\"ovs:p\": \"overflow-style:panner;\",\n\t\t\t\"ovs:m\": \"overflow-style:move;\",\n\t\t\t\"ovs:mq\": \"overflow-style:marquee;\",\n\t\t\t\"zoo\": \"zoom:1;\",\n\t\t\t\"zm\": \"zoom:1;\",\n\t\t\t\"cp\": \"clip:|;\",\n\t\t\t\"cp:a\": \"clip:auto;\",\n\t\t\t\"cp:r\": \"clip:rect(${1:top} ${2:right} ${3:bottom} ${4:left});\",\n\t\t\t\"bxz\": \"box-sizing:${1:border-box};\",\n\t\t\t\"bxz:cb\": \"box-sizing:content-box;\",\n\t\t\t\"bxz:bb\": \"box-sizing:border-box;\",\n\t\t\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:color};\",\n\t\t\t\"bxsh:r\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:spread }rgb(${6:0}, ${7:0}, ${8:0});\",\n\t\t\t\"bxsh:ra\": \"box-shadow:${1:inset }${2:h} ${3:v} ${4:blur} ${5:spread }rgba(${6:0}, ${7:0}, ${8:0}, .${9:5});\",\n\t\t\t\"bxsh:n\": \"box-shadow:none;\",\n\t\t\t\"m\": \"margin:|;\",\n\t\t\t\"m:a\": \"margin:auto;\",\n\t\t\t\"mt\": \"margin-top:|;\",\n\t\t\t\"mt:a\": \"margin-top:auto;\",\n\t\t\t\"mr\": \"margin-right:|;\",\n\t\t\t\"mr:a\": \"margin-right:auto;\",\n\t\t\t\"mb\": \"margin-bottom:|;\",\n\t\t\t\"mb:a\": \"margin-bottom:auto;\",\n\t\t\t\"ml\": \"margin-left:|;\",\n\t\t\t\"ml:a\": \"margin-left:auto;\",\n\t\t\t\"p\": \"padding:|;\",\n\t\t\t\"pt\": \"padding-top:|;\",\n\t\t\t\"pr\": \"padding-right:|;\",\n\t\t\t\"pb\": \"padding-bottom:|;\",\n\t\t\t\"pl\": \"padding-left:|;\",\n\t\t\t\"w\": \"width:|;\",\n\t\t\t\"w:a\": \"width:auto;\",\n\t\t\t\"h\": \"height:|;\",\n\t\t\t\"h:a\": \"height:auto;\",\n\t\t\t\"maw\": \"max-width:|;\",\n\t\t\t\"maw:n\": \"max-width:none;\",\n\t\t\t\"mah\": \"max-height:|;\",\n\t\t\t\"mah:n\": \"max-height:none;\",\n\t\t\t\"miw\": \"min-width:|;\",\n\t\t\t\"mih\": \"min-height:|;\",\n\t\t\t\"mar\": \"max-resolution:${1:res};\",\n\t\t\t\"mir\": \"min-resolution:${1:res};\",\n\t\t\t\"ori\": \"orientation:|;\",\n\t\t\t\"ori:l\": \"orientation:landscape;\",\n\t\t\t\"ori:p\": \"orientation:portrait;\",\n\t\t\t\"ol\": \"outline:|;\",\n\t\t\t\"ol:n\": \"outline:none;\",\n\t\t\t\"olo\": \"outline-offset:|;\",\n\t\t\t\"olw\": \"outline-width:|;\",\n\t\t\t\"olw:tn\": \"outline-width:thin;\",\n\t\t\t\"olw:m\": \"outline-width:medium;\",\n\t\t\t\"olw:tc\": \"outline-width:thick;\",\n\t\t\t\"ols\": \"outline-style:|;\",\n\t\t\t\"ols:n\": \"outline-style:none;\",\n\t\t\t\"ols:dt\": \"outline-style:dotted;\",\n\t\t\t\"ols:ds\": \"outline-style:dashed;\",\n\t\t\t\"ols:s\": \"outline-style:solid;\",\n\t\t\t\"ols:db\": \"outline-style:double;\",\n\t\t\t\"ols:g\": \"outline-style:groove;\",\n\t\t\t\"ols:r\": \"outline-style:ridge;\",\n\t\t\t\"ols:i\": \"outline-style:inset;\",\n\t\t\t\"ols:o\": \"outline-style:outset;\",\n\t\t\t\"olc\": \"outline-color:#${1:000};\",\n\t\t\t\"olc:i\": \"outline-color:invert;\",\n\t\t\t\"bd\": \"border:|;\",\n\t\t\t\"bd+\": \"border:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bd:n\": \"border:none;\",\n\t\t\t\"bdbk\": \"border-break:${1:close};\",\n\t\t\t\"bdbk:c\": \"border-break:close;\",\n\t\t\t\"bdcl\": \"border-collapse:|;\",\n\t\t\t\"bdcl:c\": \"border-collapse:collapse;\",\n\t\t\t\"bdcl:s\": \"border-collapse:separate;\",\n\t\t\t\"bdc\": \"border-color:#${1:000};\",\n\t\t\t\"bdc:t\": \"border-color:transparent;\",\n\t\t\t\"bdi\": \"border-image:url(|);\",\n\t\t\t\"bdi:n\": \"border-image:none;\",\n\t\t\t\"bdti\": \"border-top-image:url(|);\",\n\t\t\t\"bdti:n\": \"border-top-image:none;\",\n\t\t\t\"bdri\": \"border-right-image:url(|);\",\n\t\t\t\"bdri:n\": \"border-right-image:none;\",\n\t\t\t\"bdbi\": \"border-bottom-image:url(|);\",\n\t\t\t\"bdbi:n\": \"border-bottom-image:none;\",\n\t\t\t\"bdli\": \"border-left-image:url(|);\",\n\t\t\t\"bdli:n\": \"border-left-image:none;\",\n\t\t\t\"bdci\": \"border-corner-image:url(|);\",\n\t\t\t\"bdci:n\": \"border-corner-image:none;\",\n\t\t\t\"bdci:c\": \"border-corner-image:continue;\",\n\t\t\t\"bdtli\": \"border-top-left-image:url(|);\",\n\t\t\t\"bdtli:n\": \"border-top-left-image:none;\",\n\t\t\t\"bdtli:c\": \"border-top-left-image:continue;\",\n\t\t\t\"bdtri\": \"border-top-right-image:url(|);\",\n\t\t\t\"bdtri:n\": \"border-top-right-image:none;\",\n\t\t\t\"bdtri:c\": \"border-top-right-image:continue;\",\n\t\t\t\"bdbri\": \"border-bottom-right-image:url(|);\",\n\t\t\t\"bdbri:n\": \"border-bottom-right-image:none;\",\n\t\t\t\"bdbri:c\": \"border-bottom-right-image:continue;\",\n\t\t\t\"bdbli\": \"border-bottom-left-image:url(|);\",\n\t\t\t\"bdbli:n\": \"border-bottom-left-image:none;\",\n\t\t\t\"bdbli:c\": \"border-bottom-left-image:continue;\",\n\t\t\t\"bdf\": \"border-fit:${1:repeat};\",\n\t\t\t\"bdf:c\": \"border-fit:clip;\",\n\t\t\t\"bdf:r\": \"border-fit:repeat;\",\n\t\t\t\"bdf:sc\": \"border-fit:scale;\",\n\t\t\t\"bdf:st\": \"border-fit:stretch;\",\n\t\t\t\"bdf:ow\": \"border-fit:overwrite;\",\n\t\t\t\"bdf:of\": \"border-fit:overflow;\",\n\t\t\t\"bdf:sp\": \"border-fit:space;\",\n\t\t\t\"bdlen\": \"border-length:|;\",\n\t\t\t\"bdlen:a\": \"border-length:auto;\",\n\t\t\t\"bdsp\": \"border-spacing:|;\",\n\t\t\t\"bds\": \"border-style:|;\",\n\t\t\t\"bds:n\": \"border-style:none;\",\n\t\t\t\"bds:h\": \"border-style:hidden;\",\n\t\t\t\"bds:dt\": \"border-style:dotted;\",\n\t\t\t\"bds:ds\": \"border-style:dashed;\",\n\t\t\t\"bds:s\": \"border-style:solid;\",\n\t\t\t\"bds:db\": \"border-style:double;\",\n\t\t\t\"bds:dtds\": \"border-style:dot-dash;\",\n\t\t\t\"bds:dtdtds\": \"border-style:dot-dot-dash;\",\n\t\t\t\"bds:w\": \"border-style:wave;\",\n\t\t\t\"bds:g\": \"border-style:groove;\",\n\t\t\t\"bds:r\": \"border-style:ridge;\",\n\t\t\t\"bds:i\": \"border-style:inset;\",\n\t\t\t\"bds:o\": \"border-style:outset;\",\n\t\t\t\"bdw\": \"border-width:|;\",\n\t\t\t\"bdtw\": \"border-top-width:|;\",\n\t\t\t\"bdrw\": \"border-right-width:|;\",\n\t\t\t\"bdbw\": \"border-bottom-width:|;\",\n\t\t\t\"bdlw\": \"border-left-width:|;\",\n\t\t\t\"bdt\": \"border-top:|;\",\n\t\t\t\"bt\": \"border-top:|;\",\n\t\t\t\"bdt+\": \"border-top:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdt:n\": \"border-top:none;\",\n\t\t\t\"bdts\": \"border-top-style:|;\",\n\t\t\t\"bdts:n\": \"border-top-style:none;\",\n\t\t\t\"bdtc\": \"border-top-color:#${1:000};\",\n\t\t\t\"bdtc:t\": \"border-top-color:transparent;\",\n\t\t\t\"bdr\": \"border-right:|;\",\n\t\t\t\"br\": \"border-right:|;\",\n\t\t\t\"bdr+\": \"border-right:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdr:n\": \"border-right:none;\",\n\t\t\t\"bdrst\": \"border-right-style:|;\",\n\t\t\t\"bdrst:n\": \"border-right-style:none;\",\n\t\t\t\"bdrc\": \"border-right-color:#${1:000};\",\n\t\t\t\"bdrc:t\": \"border-right-color:transparent;\",\n\t\t\t\"bdb\": \"border-bottom:|;\",\n\t\t\t\"bb\": \"border-bottom:|;\",\n\t\t\t\"bdb+\": \"border-bottom:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdb:n\": \"border-bottom:none;\",\n\t\t\t\"bdbs\": \"border-bottom-style:|;\",\n\t\t\t\"bdbs:n\": \"border-bottom-style:none;\",\n\t\t\t\"bdbc\": \"border-bottom-color:#${1:000};\",\n\t\t\t\"bdbc:t\": \"border-bottom-color:transparent;\",\n\t\t\t\"bdl\": \"border-left:|;\",\n\t\t\t\"bl\": \"border-left:|;\",\n\t\t\t\"bdl+\": \"border-left:${1:1px} ${2:solid} ${3:#000};\",\n\t\t\t\"bdl:n\": \"border-left:none;\",\n\t\t\t\"bdls\": \"border-left-style:|;\",\n\t\t\t\"bdls:n\": \"border-left-style:none;\",\n\t\t\t\"bdlc\": \"border-left-color:#${1:000};\",\n\t\t\t\"bdlc:t\": \"border-left-color:transparent;\",\n\t\t\t\"bdrs\": \"border-radius:|;\",\n\t\t\t\"bdtrrs\": \"border-top-right-radius:|;\",\n\t\t\t\"bdtlrs\": \"border-top-left-radius:|;\",\n\t\t\t\"bdbrrs\": \"border-bottom-right-radius:|;\",\n\t\t\t\"bdblrs\": \"border-bottom-left-radius:|;\",\n\t\t\t\"bg\": \"background:#${1:000};\",\n\t\t\t\"bg+\": \"background:${1:#fff} url(${2}) ${3:0} ${4:0} ${5:no-repeat};\",\n\t\t\t\"bg:n\": \"background:none;\",\n\t\t\t\"bg:ie\": \"filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='${1:x}.png',sizingMethod='${2:crop}');\",\n\t\t\t\"bgc\": \"background-color:#${1:fff};\",\n\t\t\t\"bgc:t\": \"background-color:transparent;\",\n\t\t\t\"bgi\": \"background-image:url(|);\",\n\t\t\t\"bgi:n\": \"background-image:none;\",\n\t\t\t\"bgr\": \"background-repeat:|;\",\n\t\t\t\"bgr:n\": \"background-repeat:no-repeat;\",\n\t\t\t\"bgr:x\": \"background-repeat:repeat-x;\",\n\t\t\t\"bgr:y\": \"background-repeat:repeat-y;\",\n\t\t\t\"bgr:sp\": \"background-repeat:space;\",\n\t\t\t\"bgr:rd\": \"background-repeat:round;\",\n\t\t\t\"bga\": \"background-attachment:|;\",\n\t\t\t\"bga:f\": \"background-attachment:fixed;\",\n\t\t\t\"bga:s\": \"background-attachment:scroll;\",\n\t\t\t\"bgp\": \"background-position:${1:0} ${2:0};\",\n\t\t\t\"bgpx\": \"background-position-x:|;\",\n\t\t\t\"bgpy\": \"background-position-y:|;\",\n\t\t\t\"bgbk\": \"background-break:|;\",\n\t\t\t\"bgbk:bb\": \"background-break:bounding-box;\",\n\t\t\t\"bgbk:eb\": \"background-break:each-box;\",\n\t\t\t\"bgbk:c\": \"background-break:continuous;\",\n\t\t\t\"bgcp\": \"background-clip:${1:padding-box};\",\n\t\t\t\"bgcp:bb\": \"background-clip:border-box;\",\n\t\t\t\"bgcp:pb\": \"background-clip:padding-box;\",\n\t\t\t\"bgcp:cb\": \"background-clip:content-box;\",\n\t\t\t\"bgcp:nc\": \"background-clip:no-clip;\",\n\t\t\t\"bgo\": \"background-origin:|;\",\n\t\t\t\"bgo:pb\": \"background-origin:padding-box;\",\n\t\t\t\"bgo:bb\": \"background-origin:border-box;\",\n\t\t\t\"bgo:cb\": \"background-origin:content-box;\",\n\t\t\t\"bgsz\": \"background-size:|;\",\n\t\t\t\"bgsz:a\": \"background-size:auto;\",\n\t\t\t\"bgsz:ct\": \"background-size:contain;\",\n\t\t\t\"bgsz:cv\": \"background-size:cover;\",\n\t\t\t\"c\": \"color:#${1:000};\",\n\t\t\t\"c:r\": \"color:rgb(${1:0}, ${2:0}, ${3:0});\",\n\t\t\t\"c:ra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, .${4:5});\",\n\t\t\t\"cm\": \"/* |${child} */\",\n\t\t\t\"cnt\": \"content:'|';\",\n\t\t\t\"cnt:n\": \"content:normal;\",\n\t\t\t\"cnt:oq\": \"content:open-quote;\",\n\t\t\t\"cnt:noq\": \"content:no-open-quote;\",\n\t\t\t\"cnt:cq\": \"content:close-quote;\",\n\t\t\t\"cnt:ncq\": \"content:no-close-quote;\",\n\t\t\t\"cnt:a\": \"content:attr(|);\",\n\t\t\t\"cnt:c\": \"content:counter(|);\",\n\t\t\t\"cnt:cs\": \"content:counters(|);\",\n\n\n\t\t\t\"tbl\": \"table-layout:|;\",\n\t\t\t\"tbl:a\": \"table-layout:auto;\",\n\t\t\t\"tbl:f\": \"table-layout:fixed;\",\n\t\t\t\"cps\": \"caption-side:|;\",\n\t\t\t\"cps:t\": \"caption-side:top;\",\n\t\t\t\"cps:b\": \"caption-side:bottom;\",\n\t\t\t\"ec\": \"empty-cells:|;\",\n\t\t\t\"ec:s\": \"empty-cells:show;\",\n\t\t\t\"ec:h\": \"empty-cells:hide;\",\n\t\t\t\"lis\": \"list-style:|;\",\n\t\t\t\"lis:n\": \"list-style:none;\",\n\t\t\t\"lisp\": \"list-style-position:|;\",\n\t\t\t\"lisp:i\": \"list-style-position:inside;\",\n\t\t\t\"lisp:o\": \"list-style-position:outside;\",\n\t\t\t\"list\": \"list-style-type:|;\",\n\t\t\t\"list:n\": \"list-style-type:none;\",\n\t\t\t\"list:d\": \"list-style-type:disc;\",\n\t\t\t\"list:c\": \"list-style-type:circle;\",\n\t\t\t\"list:s\": \"list-style-type:square;\",\n\t\t\t\"list:dc\": \"list-style-type:decimal;\",\n\t\t\t\"list:dclz\": \"list-style-type:decimal-leading-zero;\",\n\t\t\t\"list:lr\": \"list-style-type:lower-roman;\",\n\t\t\t\"list:ur\": \"list-style-type:upper-roman;\",\n\t\t\t\"lisi\": \"list-style-image:|;\",\n\t\t\t\"lisi:n\": \"list-style-image:none;\",\n\t\t\t\"q\": \"quotes:|;\",\n\t\t\t\"q:n\": \"quotes:none;\",\n\t\t\t\"q:ru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C';\",\n\t\t\t\"q:en\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019';\",\n\t\t\t\"ct\": \"content:|;\",\n\t\t\t\"ct:n\": \"content:normal;\",\n\t\t\t\"ct:oq\": \"content:open-quote;\",\n\t\t\t\"ct:noq\": \"content:no-open-quote;\",\n\t\t\t\"ct:cq\": \"content:close-quote;\",\n\t\t\t\"ct:ncq\": \"content:no-close-quote;\",\n\t\t\t\"ct:a\": \"content:attr(|);\",\n\t\t\t\"ct:c\": \"content:counter(|);\",\n\t\t\t\"ct:cs\": \"content:counters(|);\",\n\t\t\t\"coi\": \"counter-increment:|;\",\n\t\t\t\"cor\": \"counter-reset:|;\",\n\t\t\t\"va\": \"vertical-align:${1:top};\",\n\t\t\t\"va:sup\": \"vertical-align:super;\",\n\t\t\t\"va:t\": \"vertical-align:top;\",\n\t\t\t\"va:tt\": \"vertical-align:text-top;\",\n\t\t\t\"va:m\": \"vertical-align:middle;\",\n\t\t\t\"va:bl\": \"vertical-align:baseline;\",\n\t\t\t\"va:b\": \"vertical-align:bottom;\",\n\t\t\t\"va:tb\": \"vertical-align:text-bottom;\",\n\t\t\t\"va:sub\": \"vertical-align:sub;\",\n\t\t\t\"ta\": \"text-align:${1:left};\",\n\t\t\t\"ta:l\": \"text-align:left;\",\n\t\t\t\"ta:c\": \"text-align:center;\",\n\t\t\t\"ta:r\": \"text-align:right;\",\n\t\t\t\"ta:j\": \"text-align:justify;\",\n\t\t\t\"ta-lst\": \"text-align-last:|;\",\n\t\t\t\"tal:a\": \"text-align-last:auto;\",\n\t\t\t\"tal:l\": \"text-align-last:left;\",\n\t\t\t\"tal:c\": \"text-align-last:center;\",\n\t\t\t\"tal:r\": \"text-align-last:right;\",\n\t\t\t\"td\": \"text-decoration:${1:none};\",\n\t\t\t\"td:n\": \"text-decoration:none;\",\n\t\t\t\"td:u\": \"text-decoration:underline;\",\n\t\t\t\"td:o\": \"text-decoration:overline;\",\n\t\t\t\"td:l\": \"text-decoration:line-through;\",\n\t\t\t\"te\": \"text-emphasis:|;\",\n\t\t\t\"te:n\": \"text-emphasis:none;\",\n\t\t\t\"te:ac\": \"text-emphasis:accent;\",\n\t\t\t\"te:dt\": \"text-emphasis:dot;\",\n\t\t\t\"te:c\": \"text-emphasis:circle;\",\n\t\t\t\"te:ds\": \"text-emphasis:disc;\",\n\t\t\t\"te:b\": \"text-emphasis:before;\",\n\t\t\t\"te:a\": \"text-emphasis:after;\",\n\t\t\t\"th\": \"text-height:|;\",\n\t\t\t\"th:a\": \"text-height:auto;\",\n\t\t\t\"th:f\": \"text-height:font-size;\",\n\t\t\t\"th:t\": \"text-height:text-size;\",\n\t\t\t\"th:m\": \"text-height:max-size;\",\n\t\t\t\"ti\": \"text-indent:|;\",\n\t\t\t\"ti:-\": \"text-indent:-9999px;\",\n\t\t\t\"tj\": \"text-justify:|;\",\n\t\t\t\"tj:a\": \"text-justify:auto;\",\n\t\t\t\"tj:iw\": \"text-justify:inter-word;\",\n\t\t\t\"tj:ii\": \"text-justify:inter-ideograph;\",\n\t\t\t\"tj:ic\": \"text-justify:inter-cluster;\",\n\t\t\t\"tj:d\": \"text-justify:distribute;\",\n\t\t\t\"tj:k\": \"text-justify:kashida;\",\n\t\t\t\"tj:t\": \"text-justify:tibetan;\",\n\t\t\t\"tov\": \"text-overflow:${ellipsis};\",\n\t\t\t\"tov:e\": \"text-overflow:ellipsis;\",\n\t\t\t\"tov:c\": \"text-overflow:clip;\",\n\t\t\t\"to\": \"text-outline:|;\",\n\t\t\t\"to+\": \"text-outline:${1:0} ${2:0} ${3:#000};\",\n\t\t\t\"to:n\": \"text-outline:none;\",\n\t\t\t\"tr\": \"text-replace:|;\",\n\t\t\t\"tr:n\": \"text-replace:none;\",\n\t\t\t\"tt\": \"text-transform:${1:uppercase};\",\n\t\t\t\"tt:n\": \"text-transform:none;\",\n\t\t\t\"tt:c\": \"text-transform:capitalize;\",\n\t\t\t\"tt:u\": \"text-transform:uppercase;\",\n\t\t\t\"tt:l\": \"text-transform:lowercase;\",\n\t\t\t\"tw\": \"text-wrap:|;\",\n\t\t\t\"tw:n\": \"text-wrap:normal;\",\n\t\t\t\"tw:no\": \"text-wrap:none;\",\n\t\t\t\"tw:u\": \"text-wrap:unrestricted;\",\n\t\t\t\"tw:s\": \"text-wrap:suppress;\",\n\t\t\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000};\",\n\t\t\t\"tsh:r\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgb(${4:0}, ${5:0}, ${6:0});\",\n\t\t\t\"tsh:ra\": \"text-shadow:${1:h} ${2:v} ${3:blur} rgba(${4:0}, ${5:0}, ${6:0}, .${7:5});\",\n\t\t\t\"tsh+\": \"text-shadow:${1:0} ${2:0} ${3:0} ${4:#000};\",\n\t\t\t\"tsh:n\": \"text-shadow:none;\",\n\t\t\t\"trf\": \"transform:|;\",\n\t\t\t\"trf:skx\": \"transform: skewX(${1:angle});\",\n\t\t\t\"trf:sky\": \"transform: skewY(${1:angle});\",\n\t\t\t\"trf:sc\": \"transform: scale(${1:x}, ${2:y});\",\n\t\t\t\"trf:scx\": \"transform: scaleX(${1:x});\",\n\t\t\t\"trf:scy\": \"transform: scaleY(${1:y});\",\n\t\t\t\"trf:r\": \"transform: rotate(${1:angle});\",\n\t\t\t\"trf:t\": \"transform: translate(${1:x}, ${2:y});\",\n\t\t\t\"trf:tx\": \"transform: translateX(${1:x});\",\n\t\t\t\"trf:ty\": \"transform: translateY(${1:y});\",\n\t\t\t\"trfo\": \"transform-origin:|;\",\n\t\t\t\"trfs\": \"transform-style:${1:preserve-3d};\",\n\t\t\t\"trs\": \"transition:${1:prop} ${2:time};\",\n\t\t\t\"trsde\": \"transition-delay:${1:time};\",\n\t\t\t\"trsdu\": \"transition-duration:${1:time};\",\n\t\t\t\"trsp\": \"transition-property:${1:prop};\",\n\t\t\t\"trstf\": \"transition-timing-function:${1:tfunc};\",\n\t\t\t\"lh\": \"line-height:|;\",\n\t\t\t\"whs\": \"white-space:|;\",\n\t\t\t\"whs:n\": \"white-space:normal;\",\n\t\t\t\"whs:p\": \"white-space:pre;\",\n\t\t\t\"whs:nw\": \"white-space:nowrap;\",\n\t\t\t\"whs:pw\": \"white-space:pre-wrap;\",\n\t\t\t\"whs:pl\": \"white-space:pre-line;\",\n\t\t\t\"whsc\": \"white-space-collapse:|;\",\n\t\t\t\"whsc:n\": \"white-space-collapse:normal;\",\n\t\t\t\"whsc:k\": \"white-space-collapse:keep-all;\",\n\t\t\t\"whsc:l\": \"white-space-collapse:loose;\",\n\t\t\t\"whsc:bs\": \"white-space-collapse:break-strict;\",\n\t\t\t\"whsc:ba\": \"white-space-collapse:break-all;\",\n\t\t\t\"wob\": \"word-break:|;\",\n\t\t\t\"wob:n\": \"word-break:normal;\",\n\t\t\t\"wob:k\": \"word-break:keep-all;\",\n\t\t\t\"wob:ba\": \"word-break:break-all;\",\n\t\t\t\"wos\": \"word-spacing:|;\",\n\t\t\t\"wow\": \"word-wrap:|;\",\n\t\t\t\"wow:nm\": \"word-wrap:normal;\",\n\t\t\t\"wow:n\": \"word-wrap:none;\",\n\t\t\t\"wow:u\": \"word-wrap:unrestricted;\",\n\t\t\t\"wow:s\": \"word-wrap:suppress;\",\n\t\t\t\"wow:b\": \"word-wrap:break-word;\",\n\t\t\t\"wm\": \"writing-mode:${1:lr-tb};\",\n\t\t\t\"wm:lrt\": \"writing-mode:lr-tb;\",\n\t\t\t\"wm:lrb\": \"writing-mode:lr-bt;\",\n\t\t\t\"wm:rlt\": \"writing-mode:rl-tb;\",\n\t\t\t\"wm:rlb\": \"writing-mode:rl-bt;\",\n\t\t\t\"wm:tbr\": \"writing-mode:tb-rl;\",\n\t\t\t\"wm:tbl\": \"writing-mode:tb-lr;\",\n\t\t\t\"wm:btl\": \"writing-mode:bt-lr;\",\n\t\t\t\"wm:btr\": \"writing-mode:bt-rl;\",\n\t\t\t\"lts\": \"letter-spacing:|;\",\n\t\t\t\"lts-n\": \"letter-spacing:normal;\",\n\t\t\t\"f\": \"font:|;\",\n\t\t\t\"f+\": \"font:${1:1em} ${2:Arial,sans-serif};\",\n\t\t\t\"fw\": \"font-weight:|;\",\n\t\t\t\"fw:n\": \"font-weight:normal;\",\n\t\t\t\"fw:b\": \"font-weight:bold;\",\n\t\t\t\"fw:br\": \"font-weight:bolder;\",\n\t\t\t\"fw:lr\": \"font-weight:lighter;\",\n\t\t\t\"fs\": \"font-style:${italic};\",\n\t\t\t\"fs:n\": \"font-style:normal;\",\n\t\t\t\"fs:i\": \"font-style:italic;\",\n\t\t\t\"fs:o\": \"font-style:oblique;\",\n\t\t\t\"fv\": \"font-variant:|;\",\n\t\t\t\"fv:n\": \"font-variant:normal;\",\n\t\t\t\"fv:sc\": \"font-variant:small-caps;\",\n\t\t\t\"fz\": \"font-size:|;\",\n\t\t\t\"fza\": \"font-size-adjust:|;\",\n\t\t\t\"fza:n\": \"font-size-adjust:none;\",\n\t\t\t\"ff\": \"font-family:|;\",\n\t\t\t\"ff:s\": \"font-family:serif;\",\n\t\t\t\"ff:ss\": \"font-family:sans-serif;\",\n\t\t\t\"ff:c\": \"font-family:cursive;\",\n\t\t\t\"ff:f\": \"font-family:fantasy;\",\n\t\t\t\"ff:m\": \"font-family:monospace;\",\n\t\t\t\"ff:a\": \"font-family: Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif;\",\n\t\t\t\"ff:t\": \"font-family: \\\"Times New Roman\\\", Times, Baskerville, Georgia, serif;\",\n\t\t\t\"ff:v\": \"font-family: Verdana, Geneva, sans-serif;\",\n\t\t\t\"fef\": \"font-effect:|;\",\n\t\t\t\"fef:n\": \"font-effect:none;\",\n\t\t\t\"fef:eg\": \"font-effect:engrave;\",\n\t\t\t\"fef:eb\": \"font-effect:emboss;\",\n\t\t\t\"fef:o\": \"font-effect:outline;\",\n\t\t\t\"fem\": \"font-emphasize:|;\",\n\t\t\t\"femp\": \"font-emphasize-position:|;\",\n\t\t\t\"femp:b\": \"font-emphasize-position:before;\",\n\t\t\t\"femp:a\": \"font-emphasize-position:after;\",\n\t\t\t\"fems\": \"font-emphasize-style:|;\",\n\t\t\t\"fems:n\": \"font-emphasize-style:none;\",\n\t\t\t\"fems:ac\": \"font-emphasize-style:accent;\",\n\t\t\t\"fems:dt\": \"font-emphasize-style:dot;\",\n\t\t\t\"fems:c\": \"font-emphasize-style:circle;\",\n\t\t\t\"fems:ds\": \"font-emphasize-style:disc;\",\n\t\t\t\"fsm\": \"font-smooth:|;\",\n\t\t\t\"fsm:a\": \"font-smooth:auto;\",\n\t\t\t\"fsm:n\": \"font-smooth:never;\",\n\t\t\t\"fsm:aw\": \"font-smooth:always;\",\n\t\t\t\"fst\": \"font-stretch:|;\",\n\t\t\t\"fst:n\": \"font-stretch:normal;\",\n\t\t\t\"fst:uc\": \"font-stretch:ultra-condensed;\",\n\t\t\t\"fst:ec\": \"font-stretch:extra-condensed;\",\n\t\t\t\"fst:c\": \"font-stretch:condensed;\",\n\t\t\t\"fst:sc\": \"font-stretch:semi-condensed;\",\n\t\t\t\"fst:se\": \"font-stretch:semi-expanded;\",\n\t\t\t\"fst:e\": \"font-stretch:expanded;\",\n\t\t\t\"fst:ee\": \"font-stretch:extra-expanded;\",\n\t\t\t\"fst:ue\": \"font-stretch:ultra-expanded;\",\n\t\t\t\"op\": \"opacity:|;\",\n\t\t\t\"op+\": \"opacity: $1;\\nfilter: alpha(opacity=$2);\",\n\t\t\t\"op:ie\": \"filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);\",\n\t\t\t\"op:ms\": \"-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';\",\n\t\t\t\"rsz\": \"resize:|;\",\n\t\t\t\"rsz:n\": \"resize:none;\",\n\t\t\t\"rsz:b\": \"resize:both;\",\n\t\t\t\"rsz:h\": \"resize:horizontal;\",\n\t\t\t\"rsz:v\": \"resize:vertical;\",\n\t\t\t\"cur\": \"cursor:${pointer};\",\n\t\t\t\"cur:a\": \"cursor:auto;\",\n\t\t\t\"cur:d\": \"cursor:default;\",\n\t\t\t\"cur:c\": \"cursor:crosshair;\",\n\t\t\t\"cur:ha\": \"cursor:hand;\",\n\t\t\t\"cur:he\": \"cursor:help;\",\n\t\t\t\"cur:m\": \"cursor:move;\",\n\t\t\t\"cur:p\": \"cursor:pointer;\",\n\t\t\t\"cur:t\": \"cursor:text;\",\n\t\t\t\"pgbb\": \"page-break-before:|;\",\n\t\t\t\"pgbb:au\": \"page-break-before:auto;\",\n\t\t\t\"pgbb:al\": \"page-break-before:always;\",\n\t\t\t\"pgbb:l\": \"page-break-before:left;\",\n\t\t\t\"pgbb:r\": \"page-break-before:right;\",\n\t\t\t\"pgbi\": \"page-break-inside:|;\",\n\t\t\t\"pgbi:au\": \"page-break-inside:auto;\",\n\t\t\t\"pgbi:av\": \"page-break-inside:avoid;\",\n\t\t\t\"pgba\": \"page-break-after:|;\",\n\t\t\t\"pgba:au\": \"page-break-after:auto;\",\n\t\t\t\"pgba:al\": \"page-break-after:always;\",\n\t\t\t\"pgba:l\": \"page-break-after:left;\",\n\t\t\t\"pgba:r\": \"page-break-after:right;\",\n\t\t\t\"orp\": \"orphans:|;\",\n\t\t\t\"us\": \"user-select:${none};\",\n\t\t\t\"wid\": \"widows:|;\",\n\t\t\t\"wfsm\": \"-webkit-font-smoothing:${antialiased};\",\n\t\t\t\"wfsm:a\": \"-webkit-font-smoothing:antialiased;\",\n\t\t\t\"wfsm:s\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:sa\": \"-webkit-font-smoothing:subpixel-antialiased;\",\n\t\t\t\"wfsm:n\": \"-webkit-font-smoothing:none;\"\n\t\t}\n\t},\n\t\n\t\"html\": {\n\t\t\"filters\": \"html\",\n\t\t\"profile\": \"html\",\n\t\t\"snippets\": {\n\t\t\t\"!!!\":    \"<!doctype html>\",\n\t\t\t\"!!!4t\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\",\n\t\t\t\"!!!4s\":  \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01//EN\\\" \\\"http://www.w3.org/TR/html4/strict.dtd\\\">\",\n\t\t\t\"!!!xt\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\",\n\t\t\t\"!!!xs\":  \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\",\n\t\t\t\"!!!xxs\": \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.1//EN\\\" \\\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\\\">\",\n\n\t\t\t\"c\": \"<!-- |${child} -->\",\n\t\t\t\"cc:ie6\": \"<!--[if lte IE 6]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:ie\": \"<!--[if IE]>\\n\\t${child}|\\n<![endif]-->\",\n\t\t\t\"cc:noie\": \"<!--[if !IE]><!-->\\n\\t${child}|\\n<!--<![endif]-->\"\n\t\t},\n\t\t\n\t\t\"abbreviations\": {\n\t\t\t\"!\": \"html:5\",\n\t\t\t\"a\": \"<a href=\\\"\\\">\",\n\t\t\t\"a:link\": \"<a href=\\\"http://|\\\">\",\n\t\t\t\"a:mail\": \"<a href=\\\"mailto:|\\\">\",\n\t\t\t\"abbr\": \"<abbr title=\\\"\\\">\",\n\t\t\t\"acronym\": \"<acronym title=\\\"\\\">\",\n\t\t\t\"base\": \"<base href=\\\"\\\" />\",\n\t\t\t\"basefont\": \"<basefont/>\",\n\t\t\t\"br\": \"<br/>\",\n\t\t\t\"frame\": \"<frame/>\",\n\t\t\t\"hr\": \"<hr/>\",\n\t\t\t\"bdo\": \"<bdo dir=\\\"\\\">\",\n\t\t\t\"bdo:r\": \"<bdo dir=\\\"rtl\\\">\",\n\t\t\t\"bdo:l\": \"<bdo dir=\\\"ltr\\\">\",\n\t\t\t\"col\": \"<col/>\",\n\t\t\t\"link\": \"<link rel=\\\"stylesheet\\\" href=\\\"\\\" />\",\n\t\t\t\"link:css\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:style}.css\\\" />\",\n\t\t\t\"link:print\": \"<link rel=\\\"stylesheet\\\" href=\\\"${1:print}.css\\\" media=\\\"print\\\" />\",\n\t\t\t\"link:favicon\": \"<link rel=\\\"shortcut icon\\\" type=\\\"image/x-icon\\\" href=\\\"${1:favicon.ico}\\\" />\",\n\t\t\t\"link:touch\": \"<link rel=\\\"apple-touch-icon\\\" href=\\\"${1:favicon.png}\\\" />\",\n\t\t\t\"link:rss\": \"<link rel=\\\"alternate\\\" type=\\\"application/rss+xml\\\" title=\\\"RSS\\\" href=\\\"${1:rss.xml}\\\" />\",\n\t\t\t\"link:atom\": \"<link rel=\\\"alternate\\\" type=\\\"application/atom+xml\\\" title=\\\"Atom\\\" href=\\\"${1:atom.xml}\\\" />\",\n\t\t\t\"meta\": \"<meta/>\",\n\t\t\t\"meta:utf\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=UTF-8\\\" />\",\n\t\t\t\"meta:win\": \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=windows-1251\\\" />\",\n\t\t\t\"meta:vp\": \"<meta name=\\\"viewport\\\" content=\\\"width=${1:device-width}, user-scalable=${2:no}, initial-scale=${3:1.0}, maximum-scale=${4:1.0}, minimum-scale=${5:1.0}\\\" />\",\n\t\t\t\"meta:compat\": \"<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"${1:IE=7}\\\" />\",\n\t\t\t\"style\": \"<style>\",\n\t\t\t\"script\": \"<script>\",\n\t\t\t\"script:src\": \"<script src=\\\"\\\">\",\n\t\t\t\"img\": \"<img src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"iframe\": \"<iframe src=\\\"\\\" frameborder=\\\"0\\\">\",\n\t\t\t\"embed\": \"<embed src=\\\"\\\" type=\\\"\\\" />\",\n\t\t\t\"object\": \"<object data=\\\"\\\" type=\\\"\\\">\",\n\t\t\t\"param\": \"<param name=\\\"\\\" value=\\\"\\\" />\",\n\t\t\t\"map\": \"<map name=\\\"\\\">\",\n\t\t\t\"area\": \"<area shape=\\\"\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:d\": \"<area shape=\\\"default\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:c\": \"<area shape=\\\"circle\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:r\": \"<area shape=\\\"rect\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"area:p\": \"<area shape=\\\"poly\\\" coords=\\\"\\\" href=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"form\": \"<form action=\\\"\\\">\",\n\t\t\t\"form:get\": \"<form action=\\\"\\\" method=\\\"get\\\">\",\n\t\t\t\"form:post\": \"<form action=\\\"\\\" method=\\\"post\\\">\",\n\t\t\t\"label\": \"<label for=\\\"\\\">\",\n\t\t\t\"input\": \"<input type=\\\"${1:text}\\\" />\",\n\t\t\t\"inp\": \"<input type=\\\"${1:text}\\\" name=\\\"\\\" id=\\\"\\\" />\",\n\t\t\t\"input:hidden\": \"input[type=hidden name]\",\n\t\t\t\"input:h\": \"input:hidden\",\n\t\t\t\"input:text\": \"inp\",\n\t\t\t\"input:t\": \"inp\",\n\t\t\t\"input:search\": \"inp[type=search]\",\n\t\t\t\"input:email\": \"inp[type=email]\",\n\t\t\t\"input:url\": \"inp[type=url]\",\n\t\t\t\"input:password\": \"inp[type=password]\",\n\t\t\t\"input:p\": \"input:password\",\n\t\t\t\"input:datetime\": \"inp[type=datetime]\",\n\t\t\t\"input:date\": \"inp[type=date]\",\n\t\t\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\t\t\"input:month\": \"inp[type=month]\",\n\t\t\t\"input:week\": \"inp[type=week]\",\n\t\t\t\"input:time\": \"inp[type=time]\",\n\t\t\t\"input:number\": \"inp[type=number]\",\n\t\t\t\"input:color\": \"inp[type=color]\",\n\t\t\t\"input:checkbox\": \"inp[type=checkbox]\",\n\t\t\t\"input:c\": \"input:checkbox\",\n\t\t\t\"input:radio\": \"inp[type=radio]\",\n\t\t\t\"input:r\": \"input:radio\",\n\t\t\t\"input:range\": \"inp[type=range]\",\n\t\t\t\"input:file\": \"inp[type=file]\",\n\t\t\t\"input:f\": \"input:file\",\n\t\t\t\"input:submit\": \"<input type=\\\"submit\\\" value=\\\"\\\" />\",\n\t\t\t\"input:s\": \"input:submit\",\n\t\t\t\"input:image\": \"<input type=\\\"image\\\" src=\\\"\\\" alt=\\\"\\\" />\",\n\t\t\t\"input:i\": \"input:image\",\n\t\t\t\"input:button\": \"<input type=\\\"button\\\" value=\\\"\\\" />\",\n\t\t\t\"input:b\": \"input:button\",\n\t\t\t\"isindex\": \"<isindex/>\",\n\t\t\t\"input:reset\": \"input:button[type=reset]\",\n\t\t\t\"select\": \"<select name=\\\"\\\" id=\\\"\\\">\",\n\t\t\t\"select:disabled\": \"select[disabled]\",\n\t\t\t\"select:d\": \"select[disabled]\",\n\t\t\t\"option\": \"<option value=\\\"\\\">\",\n\t\t\t\"textarea\": \"<textarea name=\\\"\\\" id=\\\"\\\" cols=\\\"${1:30}\\\" rows=\\\"${2:10}\\\">\",\n\t\t\t\"marquee\": \"<marquee behavior=\\\"\\\" direction=\\\"\\\">\",\n\t\t\t\"menu:context\": \"menu[type=context]>\",\n\t\t\t\"menu:c\": \"menu:context\",\n\t\t\t\"menu:toolbar\": \"menu[type=toolbar]>\",\n\t\t\t\"menu:t\": \"menu:toolbar\",\n\t\t\t\"video\": \"<video src=\\\"\\\">\",\n\t\t\t\"audio\": \"<audio src=\\\"\\\">\",\n\t\t\t\"html:xml\": \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\",\n\t\t\t\"keygen\": \"<keygen/>\",\n\t\t\t\"command\": \"<command/>\",\n\t\t\t\"button:submit\" : \"button[type=submit]\",\n\t\t\t\"button:s\" : \"button[type=submit]\",\n\t\t\t\"button:reset\" : \"button[type=reset]\",\n\t\t\t\"button:r\" : \"button[type=reset]\",\n\t\t\t\"button:disabled\" : \"button[disabled]\",\n\t\t\t\"button:d\" : \"button[disabled]\",\n\t\t\t\"fieldset:disabled\" : \"fieldset[disabled]\",\n\t\t\t\"fieldset:d\" : \"fieldset[disabled]\",\n\t\t\t\n\t\t\t\"bq\": \"blockquote\",\n\t\t\t\"acr\": \"acronym\",\n\t\t\t\"fig\": \"figure\",\n\t\t\t\"figc\": \"figcaption\",\n\t\t\t\"ifr\": \"iframe\",\n\t\t\t\"emb\": \"embed\",\n\t\t\t\"obj\": \"object\",\n\t\t\t\"src\": \"source\",\n\t\t\t\"cap\": \"caption\",\n\t\t\t\"colg\": \"colgroup\",\n\t\t\t\"fst\": \"fieldset\",\n\t\t\t\"fst:d\": \"fieldset[disabled]\",\n\t\t\t\"btn\": \"button\",\n\t\t\t\"btn:b\": \"button[type=button]\",\n\t\t\t\"btn:r\": \"button[type=reset]\",\n\t\t\t\"btn:s\": \"button[type=submit]\",\n\t\t\t\"btn:d\": \"button[disabled]\",\n\t\t\t\"optg\": \"optgroup\",\n\t\t\t\"opt\": \"option\",\n\t\t\t\"tarea\": \"textarea\",\n\t\t\t\"leg\": \"legend\",\n\t\t\t\"sect\": \"section\",\n\t\t\t\"art\": \"article\",\n\t\t\t\"hdr\": \"header\",\n\t\t\t\"ftr\": \"footer\",\n\t\t\t\"adr\": \"address\",\n\t\t\t\"dlg\": \"dialog\",\n\t\t\t\"str\": \"strong\",\n\t\t\t\"prog\": \"progress\",\n\t\t\t\"fset\": \"fieldset\",\n\t\t\t\"fset:d\": \"fieldset[disabled]\",\n\t\t\t\"datag\": \"datagrid\",\n\t\t\t\"datal\": \"datalist\",\n\t\t\t\"kg\": \"keygen\",\n\t\t\t\"out\": \"output\",\n\t\t\t\"det\": \"details\",\n\t\t\t\"cmd\": \"command\",\n\t\t\t\"doc\": \"html>(head>meta[charset=UTF-8]+title{${1:Document}})+body\",\n\t\t\t\"doc4\": \"html>(head>meta[http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=${charset}\\\"]+title{${1:Document}})+body\",\n\n\t\t\t\"html:4t\":  \"!!!4t+doc4[lang=${lang}]\",\n\t\t\t\"html:4s\":  \"!!!4s+doc4[lang=${lang}]\",\n\t\t\t\"html:xt\":  \"!!!xt+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xs\":  \"!!!xs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:xxs\": \"!!!xxs+doc4[xmlns=http://www.w3.org/1999/xhtml xml:lang=${lang}]\",\n\t\t\t\"html:5\":   \"!!!+doc[lang=${lang}]\",\n\t\t\t\n\t\t\t\"ol+\": \"ol>li\",\n\t\t\t\"ul+\": \"ul>li\",\n\t\t\t\"dl+\": \"dl>dt+dd\",\n\t\t\t\"map+\": \"map>area\",\n\t\t\t\"table+\": \"table>tr>td\",\n\t\t\t\"colgroup+\": \"colgroup>col\",\n\t\t\t\"colg+\": \"colgroup>col\",\n\t\t\t\"tr+\": \"tr>td\",\n\t\t\t\"select+\": \"select>option\",\n\t\t\t\"optgroup+\": \"optgroup>option\",\n\t\t\t\"optg+\": \"optgroup>option\"\n\t\t}\n\t},\n\t\n\t\"xml\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html\"\n\t},\n\t\n\t\"xsl\": {\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\",\n\t\t\"filters\": \"html, xsl\",\n\t\t\"abbreviations\": {\n\t\t\t\"tm\": \"<xsl:template match=\\\"\\\" mode=\\\"\\\">\",\n\t\t\t\"tmatch\": \"tm\",\n\t\t\t\"tn\": \"<xsl:template name=\\\"\\\">\",\n\t\t\t\"tname\": \"tn\",\n\t\t\t\"call\": \"<xsl:call-template name=\\\"\\\"/>\",\n\t\t\t\"ap\": \"<xsl:apply-templates select=\\\"\\\" mode=\\\"\\\"/>\",\n\t\t\t\"api\": \"<xsl:apply-imports/>\",\n\t\t\t\"imp\": \"<xsl:import href=\\\"\\\"/>\",\n\t\t\t\"inc\": \"<xsl:include href=\\\"\\\"/>\",\n\n\t\t\t\"ch\": \"<xsl:choose>\",\n\t\t\t\"xsl:when\": \"<xsl:when test=\\\"\\\">\",\n\t\t\t\"wh\": \"xsl:when\",\n\t\t\t\"ot\": \"<xsl:otherwise>\",\n\t\t\t\"if\": \"<xsl:if test=\\\"\\\">\",\n\n\t\t\t\"par\": \"<xsl:param name=\\\"\\\">\",\n\t\t\t\"pare\": \"<xsl:param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"var\": \"<xsl:variable name=\\\"\\\">\",\n\t\t\t\"vare\": \"<xsl:variable name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"wp\": \"<xsl:with-param name=\\\"\\\" select=\\\"\\\"/>\",\n\t\t\t\"key\": \"<xsl:key name=\\\"\\\" match=\\\"\\\" use=\\\"\\\"/>\",\n\n\t\t\t\"elem\": \"<xsl:element name=\\\"\\\">\",\n\t\t\t\"attr\": \"<xsl:attribute name=\\\"\\\">\",\n\t\t\t\"attrs\": \"<xsl:attribute-set name=\\\"\\\">\",\n\n\t\t\t\"cp\": \"<xsl:copy select=\\\"\\\"/>\",\n\t\t\t\"co\": \"<xsl:copy-of select=\\\"\\\"/>\",\n\t\t\t\"val\": \"<xsl:value-of select=\\\"\\\"/>\",\n\t\t\t\"each\": \"<xsl:for-each select=\\\"\\\">\",\n\t\t\t\"for\": \"each\",\n\t\t\t\"tex\": \"<xsl:text></xsl:text>\",\n\n\t\t\t\"com\": \"<xsl:comment>\",\n\t\t\t\"msg\": \"<xsl:message terminate=\\\"no\\\">\",\n\t\t\t\"fall\": \"<xsl:fallback>\",\n\t\t\t\"num\": \"<xsl:number value=\\\"\\\"/>\",\n\t\t\t\"nam\": \"<namespace-alias stylesheet-prefix=\\\"\\\" result-prefix=\\\"\\\"/>\",\n\t\t\t\"pres\": \"<xsl:preserve-space elements=\\\"\\\"/>\",\n\t\t\t\"strip\": \"<xsl:strip-space elements=\\\"\\\"/>\",\n\t\t\t\"proc\": \"<xsl:processing-instruction name=\\\"\\\">\",\n\t\t\t\"sort\": \"<xsl:sort select=\\\"\\\" order=\\\"\\\"/>\",\n\n\t\t\t\"choose+\": \"xsl:choose>xsl:when+xsl:otherwise\",\n\t\t\t\"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\"\n\t\t}, \n\t\t\"snippets\": {\n\t\t\t\"!!!\": \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\"\n\t\t}\n\t},\n\t\n\t\"haml\": {\n\t\t\"filters\": \"haml\",\n\t\t\"extends\": \"html\",\n\t\t\"profile\": \"xml\"\n\t},\n\t\n\t\"scss\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"sass\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"less\": {\n\t\t\"extends\": \"css\"\n\t},\n\t\n\t\"stylus\": {\n\t\t\"extends\": \"css\"\n\t},\n\n\t\"styl\": {\n\t\t\"extends\": \"stylus\"\n\t}\n}\n;\nvar res = require('resources');\nvar userData = res.getVocabulary('user') || {};\nres.setVocabulary(require('utils').deepMerge(userData, snippets), 'user');\n});\n\n\n\n// WEBPACK FOOTER //\n// ./~/emmet/emmet.js"],"sourceRoot":""}